//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : 三维数字矿山平台
//  @ File Name : spatialmeasuretool.cpp
//  @ Date : 2014/7/6
//  @ Author : 盛佳良
//  @ Implement : 
//  @ Company : 中国矿业大学(北京)
//  @ Copyright:  2014-2020
//  @ Description : 

#include "vrmine\vr_spatialanalyse\spatialanalyse/distancemeasuretool.h"
#include "vrmine/vr_geometry/geometry/line.h"
#include "vrmine/vr_spatialobject/base/geoline.h"
#include "vrmine/vr_spatiallayer/demlayer.h"
#include "vrmine/vr_spatiallayer/imagelayer.h"
#include "vrmine/vr_geometry/geometry/point.h"
#include "vrmine/vr_spatialobject/base/geopoint.h"
#include "vrmine/vr_style/style/pointstyle.h"
using namespace VirtualMine::BaseRender;
using namespace VirtualMine::Base;
using namespace VirtualMine::Geometry;
using namespace VirtualMine::Core;
using namespace VirtualMine::SpatialLayer;
using namespace VirtualMine::Style;
namespace VirtualMine
{
	namespace SpatialAnalyse
	{
		CDistanceMeasureTool::CDistanceMeasureTool(VirtualMine::Scene::CGeoSpatialControl* ref_pSceneControl)
			:CSpatialMeasureTool(ref_pSceneControl),mpRenderLine(NULL),mpRenderMoveLine(NULL),mpRenderPoints(NULL)
		{
		
		}

		CDistanceMeasureTool::~CDistanceMeasureTool()
		{
		
		}

		void CDistanceMeasureTool::mouseReleaseEvent(const int& x ,const int& y , const int& button)
		{
			if (button == 2)
			{
				this->mPoints.clear();
				this->mMarkPoints.clear();
				this->mMovePoints.clear();
				renderMoveLine();
				this->mTieDiDistance = 0;
				this->mZhiXianDistance = 0;
			}
			else if (this->mIsMouseDown && !this->mIsMouseDrag)
			{
				Ogre::Vector3 intersectPoint(Ogre::Vector3::ZERO);
				if (this->ref_mpSceneControl->getGeoSceneManager()->getRayIntersectedPoint(x,y,intersectPoint))
				{
					this->mPoints.push_back(Ogre::Vector3(intersectPoint.x,intersectPoint.y,intersectPoint.z));
					this->mMarkPoints.push_back(Ogre::Vector3(intersectPoint.x,intersectPoint.y,intersectPoint.z));
				}

				this->renderLine();
				this->renderPoints();
				this->mMovePoints.clear();
				renderMoveLine();
				if (this->mMarkPoints.size()>=2)
				{
					std::string export("");
					export.append("直线距离： ");
					export.append(Ogre::StringConverter::toString(this->getZhiXianDistance(),10));
					export.append("   贴地距离: ");
					export.append(Ogre::StringConverter::toString(this->getTieDiDistance(),10));
					export.append("\n");
					VirtualMine::SpatialInterface::CExportInfoEvent evt;
					evt.setInfo(export);
					CEventDispatcher::setEvent(&evt);	
				}	
			}
			mIsMouseDown = false;
			mIsMouseDrag = false;	
		}

		void CDistanceMeasureTool::mousePressEvent(const int& x ,const int& y , const int& button)
		{
			CSpatialMeasureTool::mousePressEvent(x,y,button);
			
		}

		void CDistanceMeasureTool::mouseDoubleClickEvent(const int& x ,const int& y , const int& button)
		{

		}

		void CDistanceMeasureTool::mouseMoveEvent(const int& x ,const int& y, const int& button)
		{
			CSpatialMeasureTool::mouseMoveEvent(x,y,button);
			
			if (this->mMarkPoints.size()>0)		
			{
				Ogre::Vector3 intersectPoint(Ogre::Vector3::ZERO);
				this->ref_mpSceneControl->getGeoSceneManager()->getRayIntersectedPoint(x,y,intersectPoint);
				//intersectPoint.y += 2;

				this->mMovePoints.clear();
				this->mMovePoints.push_back(this->mMarkPoints[this->mMarkPoints.size()-1]);
				this->mMovePoints.push_back(intersectPoint);	
				this->renderMoveLine();
			}		
		}

		void CDistanceMeasureTool::renderLine()
		{

			if (this->mpRenderLine == NULL)
			{
				this->mpRenderLine = new CMultiLine();
				this->mpRenderLine->setGeoSceneManager(this->ref_mpSceneControl->getGeoSceneManager());
			}

			this->mpRenderLine->dispose();

			if (this->mPoints.size() > 1)
			{
				CGeoLine* pGeoLine = NULL;
				VirtualMine::SpatialInterface::IGeoObject* pGeoObject = this->mpRenderLine->getGeoObject(0);
				if (pGeoObject)
				{
					pGeoLine = dynamic_cast<CGeoLine*>(pGeoObject);
				}
				else
				{
					pGeoLine = new CGeoLine();
					this->mpRenderLine->addGeoObject(pGeoLine);
				}
				CLine* pLine = dynamic_cast<CLine*>(pGeoLine->getGeometry());
				pLine->removeAllPoints();

				this->interpolationPoints(this->mPoints);

				for (size_t i = 0 ; i < this->mPoints.size(); ++i)
				{
					Ogre::Vector3& point = this->mPoints.at(i);
					pLine->addPoint(point.x,point.y,point.z);
				}
				if (this->mpRenderLine->getNode() == NULL)
					this->mpRenderLine->setNode(this->ref_mpSceneControl->getGeoSceneManager()->getRootSceneNode()->createChildSceneNode());
				this->mpRenderLine->build();
				this->mpRenderLine->render();
			}
		}

		void CDistanceMeasureTool::interpolationPoints(CoorVector& points)
		{
			if (points.size() < 1) return;

			this->mInterpolationValue = 20;
#if 0
			CoorVector::iterator pointIte = this->mPoints.begin();

			while(pointIte!=this->mPoints.end())
			{
				Ogre::Vector3 v1 = (Ogre::Vector3)*pointIte;
				pointIte++;
				if(pointIte == this->mPoints.end()) break;
				Ogre::Vector3 v2 = (Ogre::Vector3)*pointIte;
				if ((v2-v1).length() > this->mInterpolationValue)
				{
					Ogre::Vector3 tempV;
					tempV.x = (v2.x + v1.x) / 2.0f;
					tempV.z = (v2.z + v1.z) / 2.0f;
					if (pDemLayer == NULL)
					{
						tempV.y = (v2.y + v1.y) / 2.0f;
						tempV.y += 2;
					}
					else
					{
						tempV.y = pDemLayer->getHeight(tempV.x,tempV.z);
						tempV.y += 2;
					}
					this->mPoints.insert(pointIte,tempV);
					pointIte = this->mPoints.begin();
				}
				else
				{
					pointIte++;
				}		
			}
#else
			CoorVector tempCoors;
			for (size_t i = 0 ; i < points.size(); ++i)
			{
				tempCoors.push_back(points.at(i));
				if (i == points.size() - 1)
				{
					break;
				}
				Ogre::Vector3 prePoint = points.at(i);
				Ogre::Vector3 nextPoint = points.at(i+1);
				Ogre::Real dis = prePoint.distance(nextPoint);
				int numOfInterpolate = dis / this->mInterpolationValue;
				if (numOfInterpolate > 0)
				{
					Ogre::Vector3 dir = nextPoint - prePoint;
					dir.normalise();
					for (int j = 0 ; j < numOfInterpolate ; ++j)
					{
						Ogre::Vector3 interpolatePoint = prePoint + dir * (j + 1) * this->mInterpolationValue;
						Ogre::Vector3 intersectPoint;
						//this->ref_mpSceneControl->getGeoSceneManager()->getRayIntersectedPoint(interpolatePoint.x,interpolatePoint.z,intersectPoint);
						interpolatePoint.y = this->ref_mpSceneControl->getHeight(interpolatePoint.x,interpolatePoint.z*(-1));
						//interpolatePoint.y +=2;
						tempCoors.push_back(interpolatePoint);
					}
				}
			}
			points.clear();
			CoorVector::iterator bItr = tempCoors.begin();
			CoorVector::iterator eItr = tempCoors.end();
			while (bItr != eItr)
			{
				points.push_back(*bItr);
				++bItr;
			}
			tempCoors.clear();
#endif
		}

		void CDistanceMeasureTool::renderMoveLine()
		{

			if (this->mpRenderMoveLine == NULL)
			{
				this->mpRenderMoveLine = new CMultiLine();
				this->mpRenderMoveLine->setGeoSceneManager(this->ref_mpSceneControl->getGeoSceneManager());
			}

			this->mpRenderMoveLine->dispose();

			if (this->mMovePoints.size() > 1)
			{
				CGeoLine* pGeoLine = NULL;
				VirtualMine::SpatialInterface::IGeoObject* pGeoObject = this->mpRenderMoveLine->getGeoObject(0);
				if (pGeoObject)
				{
					pGeoLine = dynamic_cast<CGeoLine*>(pGeoObject);
				}
				else
				{
					pGeoLine = new CGeoLine();
					this->mpRenderMoveLine->addGeoObject(pGeoLine);
				}
				CLine* pLine = dynamic_cast<CLine*>(pGeoLine->getGeometry());
				pLine->removeAllPoints();

				this->interpolationPoints(this->mMovePoints);

				for (size_t i = 0 ; i < this->mMovePoints.size(); ++i)
				{
					Ogre::Vector3& point = this->mMovePoints.at(i);

					pLine->addPoint(point.x,point.y,point.z*(-1));
				}
				if (this->mpRenderMoveLine->getNode() == NULL)
					this->mpRenderMoveLine->setNode(this->ref_mpSceneControl->getGeoSceneManager()->getRootSceneNode()->createChildSceneNode());
				this->mpRenderMoveLine->build();
				this->mpRenderMoveLine->render();
			}
		}

		void CDistanceMeasureTool::renderPoints()
		{
			if (this->mpRenderPoints == NULL)
			{
				this->mpRenderPoints = new CMultiPoint();
				this->mpRenderPoints->setGeoSceneManager(this->ref_mpSceneControl->getGeoSceneManager());
			}

			this->mpRenderPoints->dispose();

			if (this->mMarkPoints.size() > 0)
			{
				for (size_t i = 0 ; i < this->mMarkPoints.size(); ++i)
				{
					Ogre::Vector3& point = this->mMarkPoints.at(i);
					CPoint* pPoint = new CPoint();
					pPoint->setCoor(point.x,point.y,point.z);

					CGeoPoint* geoPoint = new CGeoPoint();
					geoPoint->setGeometry(pPoint,true);
					CPointStyle* pStyle = dynamic_cast<CPointStyle*>(geoPoint->getStyle());
					pStyle->setPointRenderMode(CPointStyle::PRM_ICON);

					this->mpRenderPoints->addGeoObject(geoPoint);
				}
				if (this->mpRenderPoints->getNode() == NULL)
					this->mpRenderPoints->setNode(this->ref_mpSceneControl->getGeoSceneManager()->getRootSceneNode()->createChildSceneNode());
				this->mpRenderPoints->build();
				this->mpRenderPoints->render();				
			}
		}

		float CDistanceMeasureTool::getTieDiDistance()
		{
			this->mTieDiDistance = 0;
			CoorVector::iterator itrStart = this->mPoints.begin();
			CoorVector::iterator itrEnd = this->mPoints.end();
			itrEnd--;
			while (itrStart != itrEnd)
			{
				Ogre::Vector3 p1 = *itrStart;
				Ogre::Vector3 p2 = *(++itrStart);
				mTieDiDistance += (p2-p1).length();
			}
			return this->mTieDiDistance;
		}

		float CDistanceMeasureTool::getZhiXianDistance()
		{
			this->mZhiXianDistance = 0;
			CoorVector::iterator itrStart = this->mMarkPoints.begin();
			CoorVector::iterator itrEnd = this->mMarkPoints.end();
			itrEnd--;
			while (itrStart != itrEnd)
			{
				Ogre::Vector3 p1 = *itrStart;
				Ogre::Vector3 p2 = *(++itrStart);
				mZhiXianDistance += (p2-p1).length();
			}
			return this->mZhiXianDistance;
		}

		void CDistanceMeasureTool::removeLineObject()
		{

		}

		void CDistanceMeasureTool::removeMoveLineObject()
		{

		}

		void CDistanceMeasureTool::removePointsObject()
		{

		}

		void CDistanceMeasureTool::clear()
		{
			if (this->mpRenderPoints!=NULL)
			{
				this->mpRenderPoints->dispose();
				delete this->mpRenderPoints;
				this->mpRenderPoints = NULL;
			}
			
			if (this->mpRenderMoveLine!=NULL)
			{
				this->mpRenderMoveLine->dispose();
				delete this->mpRenderMoveLine;
				this->mpRenderMoveLine = NULL;
			}

			if (this->mpRenderLine!=NULL)
			{
				this->mpRenderLine->dispose();
				delete this->mpRenderLine;
				this->mpRenderLine = NULL;
			}
		}
	}
}