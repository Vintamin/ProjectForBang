//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : 三维数字矿山平台
//  @ File Name : pointmeasuretool.cpp
//  @ Date : 2014/7/6
//  @ Author : 盛佳良
//  @ Implement : 
//  @ Company : 中国矿业大学(北京)
//  @ Copyright:  2014-2020
//  @ Description : 

#include "vrmine\vr_spatialanalyse\spatialanalyse/pointmeasuretool.h"
#include "vrmine/vr_geometry/geometry/point.h"
#include "vrmine/vr_spatialobject/base/geopoint.h"
#include "vrmine/vr_spatiallayer/demlayer.h"
#include "vrmine/vr_style/style/pointstyle.h"
#include "vrmine/vr_spatialinterface/event/eventobject.h"
#include "vrmine/vr_spatialinterface/iscene.h"
#include "vrmine/vr_coordinatesystem/coordinatesystem/coortrans.h"
#include "vrmine/vr_coordinatesystem/coordinatesystem/spatialreferencefactory.h"
#include "vrmine/vr_coordinatesystem/coordinatesystem/spatialreference_wgs84.h"
#include "vrmine/vr_coordinatesystem/coordinatesystem/spatialreference_xian80.h"
#include "vrmine/vr_coordinatesystem/coordinatesystem/coordinatetype.h"
#include "vrmine/vr_coordinatesystem/coordinatesystem/spatialreference_beijing54.h"
#include "vrmine/vr_spatialinterface/ispatialreference.h"

using namespace VirtualMine::BaseRender;
using namespace VirtualMine::Base;
using namespace VirtualMine::Geometry;
using namespace VirtualMine::Core;
using namespace VirtualMine::SpatialLayer;
using namespace VirtualMine::Style;
using namespace Ogre;
using namespace VirtualMine::CoordinateSystem;
using namespace VirtualMine::SpatialInterface;

namespace VirtualMine
{
	namespace SpatialAnalyse
	{
		CPointMeasureTool::CPointMeasureTool(VirtualMine::Scene::CGeoSpatialControl* ref_pSceneControl)
			:CSpatialMeasureTool(ref_pSceneControl),mpRenderPoints(NULL)
		{

		}

		CPointMeasureTool::~CPointMeasureTool()
		{

		}

		void CPointMeasureTool::mouseReleaseEvent(const int& x ,const int& y , const int& button)
		{
			if (this->mIsMouseDown && !this->mIsMouseDrag)
			{
				Ogre::Vector3 intersectPoint(Ogre::Vector3::ZERO);
				if (this->ref_mpSceneControl->getGeoSceneManager()->getRayIntersectedPoint(x,y,intersectPoint))
				{
					this->mPoints.push_back(Ogre::Vector3(intersectPoint.x,intersectPoint.y,intersectPoint.z));

					if (this->mPoints.size() >= 1)
					{
						Ogre::Vector3 pt = this->mPoints[this->mPoints.size()-1];
						//关于坐标转换
						VirtualMine::CoordinateSystem::CSpatialReferenceLib* pSRLib = VirtualMine::CoordinateSystem::CSpatialReferenceLib::getSingletonPtr();
						pSRLib->registerSpatialReference(new VirtualMine::CoordinateSystem::CSpatialReference_WGS84());
						pSRLib->registerSpatialReference(new VirtualMine::CoordinateSystem::CSpatialReference_XiAn80());

						double x(0), y(0);
						double lon(0),lat(0);

						//pSRLib->getSpatialReference(Xian80)->GaussPrjCalculate(112,32,x,y);
						pSRLib->getSpatialReference(Xian80)->GaussPrjCalculate(111.3736,27.6638,x,y);

						x = pt.x + VirtualMine::SpatialInterface::IScene::ReferenceCenter.x;
						y = (pt.z / VirtualMine::SpatialInterface::IScene::CoefficientOfCoordinateTransform)+ VirtualMine::SpatialInterface::IScene::ReferenceCenter.z;
						
						pSRLib->getSpatialReference(Xian80)->GaussPrjInvCalculate(x,y,lon,lat);
						float a = (float)lon;
						float b = (float)lat;
						std::string export("");
						export.append("点坐标： X: ");
						export.append(Ogre::StringConverter::toString(pt.z * (-1) + VirtualMine::SpatialInterface::IScene::ReferenceCenter.z,14));
						//export.append(Ogre::StringConverter::toString(pt.x));
						export.append("   Y: ");
						export.append(Ogre::StringConverter::toString(pt.x + VirtualMine::SpatialInterface::IScene::ReferenceCenter.x,14));
						//export.append(Ogre::StringConverter::toString(pt.y + VirtualMine::SpatialInterface::IScene::ReferenceCenter.y,10));
						//export.append(Ogre::StringConverter::toString(pt.y));
						export.append("   Z: ");
						export.append(Ogre::StringConverter::toString(pt.y + VirtualMine::SpatialInterface::IScene::ReferenceCenter.y,10));
						//export.append(Ogre::StringConverter::toString((pt.z / VirtualMine::SpatialInterface::IScene::CoefficientOfCoordinateTransform)+ VirtualMine::SpatialInterface::IScene::ReferenceCenter.z,10));
						//export.append(Ogre::StringConverter::toString(pt.z));
						export.append("   经度: ");
						export.append(Ogre::StringConverter::toString(a,10));
						export.append("   纬度: ");
						export.append(Ogre::StringConverter::toString(b,10));
						export.append("\n");
						VirtualMine::SpatialInterface::CExportInfoEvent evt;
						evt.setInfo(export);
						CEventDispatcher::setEvent(&evt);

						this->renderPoints();
					}	
				}
			}
			mIsMouseDown = false;
			mIsMouseDrag = false;			
		}

		bool CPointMeasureTool::handleEvent(VirtualMine::Core::CEvent* evt)
		{
			CEvent::Type type = evt->type();
			switch(type)
			{
			case CEvent::MouseButtonPress:
				{
					CMouseEvent* pMouseEvent = dynamic_cast<CMouseEvent*>(evt);
					this->mousePressEvent(pMouseEvent->getX(),pMouseEvent->getY(),pMouseEvent->getButton());
					evt->accept();
					break;
				}
			case CEvent::MouseMove:
				{
					CMouseEvent* pMouseEvent = dynamic_cast<CMouseEvent*>(evt);
					this->mouseMoveEvent(pMouseEvent->getX(),pMouseEvent->getY(),pMouseEvent->getButton());
					evt->accept();
					break;	
				}
			case CEvent::MouseButtonRelease:
				{
					CMouseEvent* pMouseEvent = dynamic_cast<CMouseEvent*>(evt);
					this->mouseReleaseEvent(pMouseEvent->getX(),pMouseEvent->getY(),pMouseEvent->getButton());
					break;
				}
			default:
				break;
			}
			return evt->isAccepted();
		}

		void CPointMeasureTool::mousePressEvent(const int& x ,const int& y , const int& button)
		{
			CSpatialMeasureTool::mousePressEvent(x,y,button);
		}

		void CPointMeasureTool::mouseDoubleClickEvent(const int& x ,const int& y , const int& button)
		{

		}

		void CPointMeasureTool::renderPoints()
		{
			if (this->mPoints.size() > 0)
			{
				if (this->mpRenderPoints == NULL)
				{
					this->mpRenderPoints = new CMultiPoint();
					this->mpRenderPoints->setGeoSceneManager(this->ref_mpSceneControl->getGeoSceneManager());
				}

				this->mpRenderPoints->dispose();

				for (size_t i = 0 ; i < this->mPoints.size(); ++i)
				{
					Ogre::Vector3& point = this->mPoints.at(i);
					CPoint* pPoint = new CPoint();
					pPoint->setCoor(point.x,point.y,point.z);

					CGeoPoint* geoPoint = new CGeoPoint();
					geoPoint->setGeometry(pPoint,true);
					CPointStyle* pStyle = dynamic_cast<CPointStyle*>(geoPoint->getStyle());
					pStyle->setPointRenderMode(CPointStyle::PRM_ICON);

					this->mpRenderPoints->addGeoObject(geoPoint);
				}
				if (this->mpRenderPoints->getNode() == NULL)
					this->mpRenderPoints->setNode(this->ref_mpSceneControl->getGeoSceneManager()->getRootSceneNode()->createChildSceneNode());
				this->mpRenderPoints->build();
				this->mpRenderPoints->render();				
			}
		}

		void CPointMeasureTool::clear()
		{
			this->mPoints.clear();
			if (this->mpRenderPoints!=NULL)
			{
				this->mpRenderPoints->dispose();
				delete this->mpRenderPoints;
				this->mpRenderPoints = NULL;
			}		
		}
	}
}