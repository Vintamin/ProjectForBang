

//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : 三维数字矿山平台
//  @ File Name : Concave_Polygon.cpp
//  @ Date : 2015/6/21
//  @ Author : 王向上
//  @ Implement : 
//  @ Company : 中国矿业大学(北京)
//  @ Copyright:  2014-2020
//  @ Description : 
#include "vrmine/vr_spatialanalyse/spatialanalyse/Concave_Polygon.h"

//#include <string>

namespace VirtualMine
{
	namespace SpatialAnalyse
	{
		Concave_Polygon concave;

Concave_Polygon::Concave_Polygon()
{
	
	font = GLUT_BITMAP_8_BY_13;
	drawMode = 0;
	vertexIndex = 0;    

}

Concave_Polygon::~Concave_Polygon()
{

}

//创建凹多边形，参数2返回绘制模式，参数3返回绘制模式对应的点的vector；
int Concave_Polygon::creatTri(std::vector<GLPoint>& a,std::vector<int>& b,std::vector<std::vector<GLPoint>>& c)
{
	
	GLPoints2=a;
	listId1 = tessellate1();    // a concave qua
	
	
	b=concave.count;
    c=concave.GLPointsset;
	
	concave.count.clear();
	concave.GLPointsset.clear();

	return 0;
}


///////////////////////////////////////////////////////////////////////////////
// create a tessellation object and compile a quad into a display list
///////////////////////////////////////////////////////////////////////////////

GLuint Concave_Polygon::tessellate1()
{
	//GLint len;
	GLuint id = glGenLists(1);  // create a display list//生成显示列表
	        // failed to create a list, return 0

	GLUtesselator *tess = gluNewTess(); // create a tessellator//镶嵌
	if(!tess) return 0;  // failed to create tessellation object, return 0

	
	int size2 = GLPoints2.size();
  
 GLdouble** Dy = new GLdouble*[size2]; 


 for (int i = 0;i < size2; ++i)
 {
	 Dy[i] = new GLdouble[3];
 }
 
for (int i=0;i<GLPoints2.size();++i)
{
	GLPoint GLpoint4;
	GLpoint4 = GLPoints2.at(i);

	


	
	Dy[i][0] = GLpoint4.X;
	Dy[i][1] = GLpoint4.Y;
	Dy[i][2] = GLpoint4.Z;
}

	gluTessCallback(tess, GLU_TESS_BEGIN, (void (CALLBACK *)())tessBeginCB);
	gluTessCallback(tess, GLU_TESS_END, (void (CALLBACK *)())tessEndCB);
	gluTessCallback(tess, GLU_TESS_ERROR, (void (CALLBACK *)())tessErrorCB);
	gluTessCallback(tess, GLU_TESS_VERTEX, (void (CALLBACK *)())tessVertexCB);

	glNewList(id, GL_COMPILE);
	gluTessBeginPolygon(tess, 0);// with NULL data//该函数和gluTessEndPolygon共同限制一个多边形的描述
	gluTessBeginContour(tess);//该函数和gluTessEndContour共同限制一个轮廓描述
	
	
	for (int i=0;i<GLPoints2.size();++i)
	{
		gluTessVertex(tess,Dy[i], Dy[i]);
	   
	}
	gluTessEndContour(tess);
	gluTessEndPolygon(tess);
	glEndList();

	gluDeleteTess(tess);        // delete after tessellation


 	return id;      // return handle ID of a display list
}


///////////////////////////////////////////////////////////////////////////////
// convert enum of OpenGL primitive type to a string(char*)
// OpenGL supports only 10 primitive types.
///////////////////////////////////////////////////////////////////////////////
 Ogre::RenderOperation::OperationType Concave_Polygon::getPrimitiveType(int j)
{
	switch(j)
	{
	case 0:
		return Ogre::RenderOperation::OT_POINT_LIST;
		break;
	case 1:
		return Ogre::RenderOperation::OT_LINE_LIST;
		break;
	case 3:
		return Ogre::RenderOperation::OT_LINE_STRIP;
		break;
	case 4:
		return Ogre::RenderOperation::OT_TRIANGLE_LIST;
		break;
	case 5:
		return Ogre::RenderOperation::OT_TRIANGLE_STRIP;
		break;
	case 6:
		return Ogre::RenderOperation::OT_TRIANGLE_FAN;
		break;
	}
}
void Concave_Polygon::idleCB()
{
	glutPostRedisplay();//必须选择性的告诉GLUT去调用显示函数
}


 void CALLBACK Concave_Polygon::tessBeginCB(GLenum  which  )
{
	
	glBegin(which);


	concave.mEnum = which;
	//this->mEnum=which;
	concave.count.push_back(concave.mEnum);

	// DEBUG //
	//concave.ss << "glBegin(" << concave.getPrimitiveType(which) << ");\n";

	
}



void CALLBACK Concave_Polygon::tessEndCB()
{
	concave.GLPointsset.push_back(concave.GLPoints);

	concave.GLPoints.clear();
	
	glEnd();
	// DEBUG //
	
}



void CALLBACK Concave_Polygon::tessVertexCB(const GLvoid *data)
{
	// cast back to double type
	const GLdouble *ptr = (const GLdouble*)data;

	glVertex3dv(ptr);


GLdouble first1P = *ptr;
	GLdouble first2P = *(ptr+1);
	GLdouble first3P = *(ptr+2);

	GLPoint point;
	point.X = first1P;
	point.Y = first2P;
	point.Z = first3P;

concave.GLPoints.push_back(point);
	
}

void CALLBACK Concave_Polygon::tessCombineCB(const GLdouble newVertex[3], const GLdouble *neighborVertex[4],
	const GLfloat neighborWeight[4], GLdouble **outData)
{
	// copy new intersect vertex to local array
	// Because newVertex is temporal and cannot be hold by tessellator until next
	// vertex callback called, it must be copied to the safe place in the app.
	// Once gluTessEndPolygon() called, then you can safly deallocate the array.
	vertices[vertexIndex][0] = newVertex[0];
	vertices[vertexIndex][1] = newVertex[1];
	vertices[vertexIndex][2] = newVertex[2];

	// compute vertex color with given weights and colors of 4 neighbors
	// the neighborVertex[4] must hold required info, in this case, color.
	// neighborVertex was actually the third param of gluTessVertex() and is
	// passed into here to compute the color of the intersect vertex.
	vertices[vertexIndex][3] = neighborWeight[0] * neighborVertex[0][3] +   // red
		neighborWeight[1] * neighborVertex[1][3] +
		neighborWeight[2] * neighborVertex[2][3] +
		neighborWeight[3] * neighborVertex[3][3];
	vertices[vertexIndex][4] = neighborWeight[0] * neighborVertex[0][4] +   // green
		neighborWeight[1] * neighborVertex[1][4] +
		neighborWeight[2] * neighborVertex[2][4] +
		neighborWeight[3] * neighborVertex[3][4];
	vertices[vertexIndex][5] = neighborWeight[0] * neighborVertex[0][5] +   // blue
		neighborWeight[1] * neighborVertex[1][5] +
		neighborWeight[2] * neighborVertex[2][5] +
		neighborWeight[3] * neighborVertex[3][5];


	// return output data (vertex coords and others)
	*outData = vertices[vertexIndex];   // assign the address of new intersect vertex

	++vertexIndex;  // increase index for next vertex
}



void CALLBACK Concave_Polygon::tessErrorCB(GLenum errorCode)
{
	const GLubyte *errorStr;

	errorStr = gluErrorString(errorCode);
	
}
	}
}