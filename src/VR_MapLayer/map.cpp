//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : 二三维爆破信息仿真系统
//  @ File Name : cmap.cpp
//  @ Date : 2015/8/1
//  @ Author : 
//
//


#include "vrmine/vr_maplayer/map.h"
#include "vrmine/vr_maplayer/pointlayer.h"
#include "vrmine/vr_maplayer/polylinelayer.h"
#include "vrmine/vr_maplayer/polygonlayer.h"
#include "vrmine/vr_maplayer/complexlayer.h"
#include "vrmine/vr_maplayer/shotholelayer.h"
#include "vrmine/vr_maplayer/rocklayer2D.h"

using namespace VirtualMine::Core;

namespace VirtualMine
{
	namespace Map
	{
		CMap::CMap()
		{
			this->mName = "unameMap";
		}

		CMap::~CMap()
		{

		}

		std::string CMap::getName()
		{
			return this->mName;
		}
		void CMap::setName(const std::string& name)
		{
			this->mName = name;
		}

		void CMap::computeBoundingBox()
		{
			if (this->mLayers.size() > 0)
			{
				std::vector<CMap2DLayer*>::iterator bItr = this->mLayers.begin();
				std::vector<CMap2DLayer*>::iterator eItr = this->mLayers.end();
				while (bItr != eItr)
				{
					(*bItr)->computeBoundingBox();
					this->mBoundingBox.merge((*bItr)->getBoundingBox());
					++bItr;
				}
				 
			}
		}

		CMap2DLayer* CMap::addLayer(const std::string& type)
		{
			CMap2DLayer* pLayer = NULL;
			if (type == GeoDataType::GDT_POINT)
			{
				pLayer = new CPointLayer();
			}
			else if (type == GeoDataType::GDT_LINE)
			{
				pLayer = new CPolylineLayer();
			}
			else if (type == GeoDataType::GDT_POLYGON)
			{
				pLayer = new CPolygonLayer();
			}
			if (type == GeoDataType::GDT_TERRANE)
			{
				//pLayer = new CPointLayer();
				pLayer = new  CRockLayer2D();
			}
			else if (type == GeoDataType::GDT_SHOTHOLE)
			{
				pLayer = new C2DShotHoleLayer();
			}
			else if (type == GeoDataType::GDT_LANEWAYSECTION)
			{
				pLayer = new C2DLanewaySectionLayer();
			}
			else if (type == GeoDataType::GDT_ESCAPEROUTE)
			{
				pLayer = new C2DEscapeRouteLayer();
			}
			//kk施工进度
			else if (type == GeoDataType::GDT_CONPROGRESS)
			{
				pLayer = new C2DConProgressLayer();
			}
			if (pLayer)
			{
				mLayers.push_back(pLayer);
			}
			return pLayer;
		}

		void CMap::removeLayer(const std::string& layerName) 
		{
			if (this->mLayers.size() > 0)
			{
				std::vector<CMap2DLayer*>::iterator bItr = this->mLayers.begin();
				std::vector<CMap2DLayer*>::iterator eItr = this->mLayers.end();
				while (bItr != eItr)
				{
					if ((*bItr)->getName() == layerName)
					{
						delete *bItr;
						this->mLayers.erase(bItr);
						return;
					}
					++bItr;
				}

			}
		}

		CMap2DLayer* CMap::getLayer(const std::string& layerName) 
		{
			return NULL;
		}

		QPixmap& CMap::getMapImage()
		{
			return this->mMapImage;
		}

		void CMap::setBoundingBox(const Ogre::AxisAlignedBox& boundingBox)
		{
			this->mBoundingBox = boundingBox;
		}
		Ogre::AxisAlignedBox& CMap::getBoundingBox()
		{
			return this->mBoundingBox;
		}

		bool CMap::pointSelect(const QPointF& mousePrjPos,const double& tolerance)
		{
			bool r = false;
			if (this->getVisible())
			{
				std::vector<QPixmap> curLayerImages;
				for (size_t i = 0; i < this->mLayers.size();++i)
				{
					r |= this->mLayers[i]->pointSelect(mousePrjPos,tolerance);
				}
			}
			return r;
		}


		bool CMap::draw(QPainter& painter,
			const int& viewWidth,const int& viewHeight,
			const QPointF& viewLeftTopPosition,
			const QPointF& viewRightBottomPosition,
			const float& curScale)
		{
			bool r = false;
			if (this->getVisible())
			{
				std::vector<QPixmap> curLayerImages;
				for (size_t i = 0; i < this->mLayers.size();++i)
				{
					if(this->mLayers[i]->draw(painter,viewWidth,viewHeight,
						viewLeftTopPosition,viewRightBottomPosition,curScale))
					{
						curLayerImages.push_back(this->mLayers[i]->getLayerImage());
					}
				}
				if (curLayerImages.size() > 0)
				{
					QPixmap renderBufferImage(viewWidth,viewHeight);
					renderBufferImage.fill(Qt::transparent);
					QPainter curBufferPainter(&renderBufferImage);
					for (size_t i = 0; i < curLayerImages.size(); ++i)
					{
						curBufferPainter.drawPixmap(0,0,curLayerImages[i]);
					}
					this->mMapImage = renderBufferImage;
					r = true;
				}
			}
			return r;
		}

		std::vector<CMap2DLayer*> CMap::getLayers()
		{
			return this->mLayers;
		}

	}}
