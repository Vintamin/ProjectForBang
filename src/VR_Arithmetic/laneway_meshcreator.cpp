//
//

//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : 三维数字矿山平台
//  @ File Name : igeomeshcreator.cpp
//  @ Date : 2014/8/5
//  @ Author : 朱炜鹏
//  @ Implement : 
//  @ Company : 中国矿业大学(北京)
//  @ Copyright:  2014-2020
//  @ Description : 


#include "vrmine/vr_arithmetic/arithmetic/laneway_meshcreator.h"
#include "vrmine/vr_core/geodatatype.h"
#include "vrmine/vr_spatialobject/mine/lanwayobject.h"
#include <string>

using namespace VirtualMine::Geometry;
using namespace VirtualMine::Style;
using namespace VirtualMine::MathEngine;
using namespace VirtualMine::SpatialInterface;
using namespace VirtualMine::Mine;


namespace VirtualMine
{
	namespace Arithmetic
	{
		CLaneway_MeshCreator::CLaneway_MeshCreator()
		{
			/*std::string type = "ArcLaneway";
			this->setType(type);*/
			this->setType(VirtualMine::Core::GeoDataType::GDT_LANWAY);
			this->mpStyle = new CLanewayStyle(); 
		}

		CLaneway_MeshCreator::~CLaneway_MeshCreator()
		{

		}

		void CLaneway_MeshCreator::createData(VirtualMine::SpatialInterface::GeoObjectVector& geoObjectVector,std::vector<VirtualMine::SpatialInterface::CGeoExtentionData*>& geoExtentionDatas)
		{
			this->ref_mGeoExtantionDataVector = &geoExtentionDatas;

			this->ref_mGeoObjectVector = geoObjectVector;
			CGeoObject* firstObject = dynamic_cast<CGeoObject*>(this->ref_mGeoObjectVector[0]);
			this->mpStyle = dynamic_cast<VirtualMine::Style::CLanewayStyle*>(firstObject->getStyle());

			if (this->mLanewayCrossNodes.size()>0)
			{
				this->mLanewayCrossNodes.clear();
			}

			if (this->mLanewayLines.size()>0)
			{
				this->mLanewayLines.clear();
			}


			this->createLanewayLineCollection();   //从原始数据提取巷道线路

			this->createIntersectionCollection();  //检索巷道数据，构建巷道交叉节点

			this->buildLinePart();                 //构建直线和拐点部分

			this->buildIntersectionPart();         //构建交叉的截面部分

		}

		void CLaneway_MeshCreator::createLanewayLineCollection()
		{	
			for (VirtualMine::SpatialInterface::GeoObjectVector::iterator ite = this->ref_mGeoObjectVector.begin();ite!=this->ref_mGeoObjectVector.end();ite++)
			{
				IGeoObject* geoObject = (*ite);
				CLanewayStyle* tempstyle = dynamic_cast<VirtualMine::Style::CLanewayStyle*>(geoObject->getStyle());
				IGeometry* temp = geoObject->getGeometry();
				CLaneWayLineGeometry* line = dynamic_cast<CLaneWayLineGeometry*>(geoObject->getGeometry());
				this->mLanewayLines.push_back(line);
			}
		}

		bool CLaneway_MeshCreator::hasCrossNode(const Ogre::String& name)
		{
			for (std::vector<CLaneWayCrossNodeGeometry*>::iterator ite = this->mLanewayCrossNodes.begin();ite!=this->mLanewayCrossNodes.end();ite++)
			{
				CLaneWayCrossNodeGeometry* crossNode = (*ite);
				if (crossNode->getCrossNode()->getName() == name)
				{
					return true;
				}
			}
			return false;
		}

		VirtualMine::Geometry::CLaneWayLineGeometry* CLaneway_MeshCreator::getLanewayLine(const Ogre::String& lineName)
		{
			
			for (std::vector<CLaneWayLineGeometry*>::iterator ite = this->mLanewayLines.begin();ite!=this->mLanewayLines.end();ite++)
			{
				CLaneWayLineGeometry* line = (*ite);
				if (line->getName() == lineName)
				{
					return line;
				}
			}
			return NULL;
		}
		
		void CLaneway_MeshCreator::createIntersectionCollection()
		{
			for (std::vector<CLaneWayLineGeometry*>::iterator ite = this->mLanewayLines.begin();ite!=this->mLanewayLines.end();ite++)
			{
				CLaneWayLineGeometry* line = (*ite);
				std::vector<CLaneWayNodeGeometry*> nodes = line->getNodes();
				for (std::vector<CLaneWayNodeGeometry*>::iterator iteNode = nodes.begin();iteNode!=nodes.end();iteNode++)
				{
					CLaneWayNodeGeometry* node = (*iteNode);
					if (node->getIsIntersection())
					{
						if (!this->hasCrossNode(node->getName()))
						{
							CLaneWayCrossNodeGeometry* crossNode = new CLaneWayCrossNodeGeometry();
							crossNode->setCrossNode(node);
							//kk  StringVector换成std::vector<Ogre::String>
							std::vector<Ogre::String> lineNames = node->getBelongLanewayLine();
							for (std::vector<Ogre::String>::iterator iteline =lineNames.begin();iteline!=lineNames.end();iteline++ )
							{
								Ogre::String lineName = (*iteline);
								CLaneWayLineGeometry* lineGeometry =  this->getLanewayLine(lineName);
								if (lineGeometry == NULL)
								{
									break;
								}

								CLaneWayNodeGeometry* tempNode = lineGeometry->getNode(node->getName());
							
								if (tempNode == NULL)
								{
									break;
								}
								if (tempNode->getPreNode()!=NULL)
								{
									crossNode->addAdjacentNode(tempNode->getPreNode());
								}
								if (tempNode->getNextNode()!=NULL)
								{
									crossNode->addAdjacentNode(tempNode->getNextNode());
								}
							}
							crossNode->clockwiseSortPoints();
							this->mLanewayCrossNodes.push_back(crossNode);							
						}						
					}
				}
			}
		}

		VirtualMine::Geometry::CLaneWaySection* CLaneway_MeshCreator::createSection(VirtualMine::Style::CLanewayStyle* lanewayStyle)
		{
				CLaneWaySection* section = new CLaneWaySection();
				int count=(int)(180.0f/10.0f);
				int countCircle=(int)(360.0/17.14f);
				LanewaySectionType sectionType = lanewayStyle->getSectionType();

				if (sectionType == LanewaySectionType::Arch)
				{
					Ogre::Real width = lanewayStyle->getWidth();
					Ogre::Real height = lanewayStyle->getHeight();
					Ogre::Vector3* points=new Ogre::Vector3[count+4];
					points[0].x=width; 
					points[0].y=height;
					points[0].z=0;

					points[1].x=width;
					points[1].y=0;
					points[1].z=0;

					points[2].x=-width;
					points[2].y=0;
					points[2].z=0;

					points[3].x=-width;
					points[3].y=height;
					points[3].z=0;

					Ogre::Vector3 forward = Ogre::Vector3::UNIT_Z;

					for(int i=0;i<count;i++)
					{
						Ogre::Quaternion q;
						q.FromAngleAxis(Ogre::Radian(-10.0f*(i+1)*Ogre::Math::PI/180),forward);
						points[4+i] = q * points[2];
						points[4+i].y+=height;
					}
					section->setPoints(points,count+4);
				}
				else if (sectionType == LanewaySectionType::Trapezoid)
				{
					Ogre::Real width = lanewayStyle->getWidth();
					Ogre::Real height = lanewayStyle->getHeight();
					Ogre::Vector3* points=new Ogre::Vector3[count+4];
					points[0].x=width*0.505f;
					points[0].y=height;
					points[0].z=0;

					points[1].x=width;
					points[1].y=0;
					points[1].z=0;

					points[2].x=-width;
					points[2].y=0;
					points[2].z=0;

					points[3].x=-width*0.505f;
					points[3].y=height;
					points[3].z=0;

					Ogre::Vector3 forward = Ogre::Vector3::UNIT_Z;

					Ogre::Vector3 tempPt;
					tempPt = points[2];
					tempPt.x = points[3].x;
					for(int i=0;i<count;i++)
					{
						Ogre::Quaternion q;
						q.FromAngleAxis(Ogre::Radian(-10.0f*(i+1)*Ogre::Math::PI/180),forward);
						points[4+i] = q * tempPt;
						points[4+i].y=height;
					}
					section->setPoints(points,count+4);
				}
				else if (sectionType == LanewaySectionType::Circle)
				{
					Ogre::Real width = lanewayStyle->getWidth();
					Ogre::Real height = lanewayStyle->getHeight();
					Ogre::Vector3* points=new Ogre::Vector3[countCircle+1];
					points[0].x=-width; 
					points[0].y=0;
					points[0].z=0;


					Ogre::Vector3 forward = Ogre::Vector3::UNIT_Z;

					for(int i=0;i<countCircle;i++)
					{
						Ogre::Quaternion q;
						q.FromAngleAxis(Ogre::Radian(-17.14f*(i+1)*Ogre::Math::PI/180),forward);
						points[1+i] = q * points[0];
						//points[1+i].y+=0;
					}
					section->setPoints(points,countCircle+1);
				}
				return section;
		}

		Ogre::Vector3 CLaneway_MeshCreator::getCrossOffsetPos(CLaneWayNodeGeometry* sourcePos,CLaneWayCrossNodeGeometry* crossNode,CLanewayStyle* lanewayStyle)
		{
			Ogre::Vector3 result;
			float width = lanewayStyle->getWidth();

			Ogre::Vector3 dir = sourcePos->getPosition() - crossNode->getCrossNode()->getPosition();
			float dirAngle = CMathCalculator::CalculateAngleOfPlane(dir);

			Ogre::Vector3 start=sourcePos->getPosition(); 
			start.y=0;
			Ogre::Vector3 center=crossNode->getCrossNode()->getPosition();
			center.y=0;
			Ogre::Vector3 offsetDirection = start - center;
			offsetDirection.normalise();

			Ogre::Vector3 realDir = sourcePos->getPosition() - crossNode->getCrossNode()->getPosition();
			realDir.normalise();

			float maxLength=0;
			for (int i = 0;i<crossNode->getAdjancentNodesCount();i++)
			{
				CLaneWayNodeGeometry* node = crossNode->getAdjancentNode(i);
				if (node->getPosition() != sourcePos->getPosition())
				{
					Ogre::Vector3 newStart=node->getPosition();
					newStart.y=0;		
					Ogre::Vector3 newDirection = newStart-center;
					newDirection.normalise();

					float edge;
					float angle = CMathCalculator::CalculateAngleOfTwoVector(offsetDirection,newDirection);
					float angleAbs = Ogre::Math::Abs(angle);
					if(angleAbs<0.0001)
						edge=0;
					else
					{
						edge = (width) / Ogre::Math::Tan(angleAbs/2.0f);
						edge = edge/Ogre::Math::Abs(Ogre::Math::Cos(dirAngle));
					}	   
					if(edge>maxLength)
					{
						maxLength=edge;
						result=crossNode->getCrossNode()->getPosition() + edge*realDir;
					}	  
				} 
			}
			return result;
		}

		void CLaneway_MeshCreator::buildLinePart()
		{
			#pragma region 创建截面
			//for (std::vector<CLaneWayLineGeometry*>::iterator iteLine = this->mLanewayLines.begin(); iteLine!=this->mLanewayLines.end();iteLine++ )
			for(size_t i = 0;i<this->mLanewayLines.size();++i)
			{
				//CLaneWayLineGeometry* line = (*iteLine);
				CLaneWayLineGeometry* line = this->mLanewayLines[i];
				
				this->mpStyle = dynamic_cast<VirtualMine::Style::CLanewayStyle*>(this->ref_mGeoObjectVector[i]->getStyle());

				if (line->getNodesCount() < 2)	
					break;

				for (int i = 0;i<line->getNodesCount();i++)
				{
					CLaneWayNodeGeometry* node = line->getNode(i);

					if (node == NULL)
					{
						break;
					}
					#pragma region 直线巷道
					if (node->getNextNode() != NULL)
					{
						//计算截面偏角
						Ogre::Vector3 direction = node->getNextNode()->getPosition() - node->getPosition();
						direction.y = 0;
						direction.normalise();
						float azimuthAngle = VirtualMine::MathEngine::CMathCalculator::CalculateAzimuth(direction);

						//计算第一个截面
						CLaneWaySection* sectionOne = this->createSection(this->mpStyle);
						sectionOne->Rotate(Ogre::Radian(azimuthAngle));

						if (node->getIsIntersection())
						{
							CLaneWayCrossNodeGeometry* crossNodeOne = NULL;
							for (std::vector<CLaneWayCrossNodeGeometry*>::iterator iteCross = this->mLanewayCrossNodes.begin(); iteCross!=this->mLanewayCrossNodes.end();iteCross++)
							{
								CLaneWayCrossNodeGeometry* crossNode = (*iteCross);
								if (crossNode == NULL || crossNode->getCrossNode() == NULL)
								{
									break;
								}
								if (crossNode->getCrossNode()->getPosition() == node->getPosition())
								{
									crossNodeOne = crossNode;
									break;
								}
							}
							if (crossNodeOne == NULL)
							{
								break;
							}
							Ogre::Vector3 startPos = this->getCrossOffsetPos(node->getNextNode(),crossNodeOne,this->mpStyle);
							sectionOne->setPosition(startPos);
						}
						else
						{
							if (node->getPreNode() == NULL)
							{
								sectionOne->setPosition(node->getPosition());
							}
							else
							{						
								Ogre::Vector3 firstVector = node->getPreNode()->getPosition() - node->getPosition();
								
								firstVector.y = 0;
								firstVector.normalise();

								Ogre::Vector3 dir = node->getNextNode()->getPosition() - node->getPosition();
								float dirAngle = VirtualMine::MathEngine::CMathCalculator::CalculateAngleOfPlane(dir);
								Ogre::Vector3 secondVector = dir;
								secondVector.y = 0;
								secondVector.normalise();

								float angle = VirtualMine::MathEngine::CMathCalculator::CalculateAngleOfTwoVector(firstVector,secondVector);
								angle = Ogre::Math::Abs(angle);
								float startOffset = this->mpStyle->getSmoothFactor() * this->mpStyle->getWidth() / Ogre::Math::Tan(angle/2.0f);
								startOffset = startOffset/Ogre::Math::Abs(Ogre::Math::Cos(dirAngle));
								Ogre::Vector3 startPos = node->getPosition() + startOffset*secondVector;
								sectionOne->setPosition(startPos);
							}
						}


						//计算第二个截面
						CLaneWaySection* sectionTwo = this->createSection(this->mpStyle);
						sectionTwo->Rotate(Ogre::Radian(azimuthAngle));

						if (node->getNextNode()->getIsIntersection())
						{
							CLaneWayCrossNodeGeometry* crossNodeTwo = NULL;
							for (std::vector<CLaneWayCrossNodeGeometry*>::iterator iteCross = this->mLanewayCrossNodes.begin(); iteCross!=this->mLanewayCrossNodes.end();iteCross++)
							{
								CLaneWayCrossNodeGeometry* crossNode = (*iteCross);
								
								if (crossNode == NULL || crossNode->getCrossNode() == NULL)
								{
									break;
								}
								if (crossNode->getCrossNode()->getPosition() == node->getNextNode()->getPosition())
								{
									crossNodeTwo = crossNode;
									break;
								}							
							}
							if (crossNodeTwo == NULL)
							{
								break;
							}
						
							Ogre::Vector3 endtPos = this->getCrossOffsetPos(node,crossNodeTwo,this->mpStyle);
							sectionTwo->setPosition(endtPos);
						}
						else
						{
							if (node->getNextNode()->getNextNode() == NULL)
							{
								sectionTwo->setPosition(node->getNextNode()->getPosition());
							}
							else
							{
								Ogre::Vector3 dir2 = node->getPosition() - node->getNextNode()->getPosition();
								float dir2Angle = VirtualMine::MathEngine::CMathCalculator::CalculateAngleOfPlane(dir2);
								Ogre::Vector3 firstVector2 = dir2;
								firstVector2.y = 0;
								firstVector2.normalise();

								Ogre::Vector3 secondVector2 = node->getNextNode()->getNextNode()->getPosition() - node->getNextNode()->getPosition();
								secondVector2.y = 0;
								secondVector2.normalise();

								float angle2 = VirtualMine::MathEngine::CMathCalculator::CalculateAngleOfTwoVector(firstVector2,secondVector2);
								angle2 = Ogre::Math::Abs(angle2);
								float endOffset = this->mpStyle->getSmoothFactor() * this->mpStyle->getWidth()/ Ogre::Math::Tan(angle2/2.0f);
								endOffset = endOffset/Ogre::Math::Abs(Ogre::Math::Cos(dir2Angle));
			
								Ogre::Vector3 endPos = node->getNextNode()->getPosition() + endOffset*firstVector2;

								sectionTwo->setPosition(endPos);
							}
						}
						line->addSection(sectionOne);
						line->addSection(sectionTwo);
					}
					#pragma endregion 

					#pragma region 拐点平滑
					if (node->getPreNode()!=NULL && node->getNextNode()!=NULL && !node->getIsIntersection())
					{
						std::vector<CLaneWaySection*> nodeSections;
						Ogre::Vector3 dirOrigin = node->getPreNode()->getPosition() - node->getPosition();
						float dirOriginAngle = VirtualMine::MathEngine::CMathCalculator::CalculateAngleOfPlane(dirOrigin);
						Ogre::Vector3 originDir = dirOrigin;			
						originDir.y = 0;
						originDir.normalise();
						Ogre::Vector3 dirEnd =  node->getNextNode()->getPosition() - node->getPosition();
						float dirEndAngle = VirtualMine::MathEngine::CMathCalculator::CalculateAngleOfPlane(dirEnd);
						Ogre::Vector3 endDir = dirEnd;
						endDir.y = 0;
						endDir.normalise();
						float angle = VirtualMine::MathEngine::CMathCalculator::CalculateAngleOfTwoVector(originDir,endDir);

						Ogre::Vector3 rotateAxis = originDir.crossProduct(endDir);
						rotateAxis.y = Ogre::Math::Abs(rotateAxis.y );
						rotateAxis.normalise();
						float angleAbs = Ogre::Math::Abs(angle);
						
						Ogre::Quaternion q;
						q.FromAngleAxis(Ogre::Radian(angle/2.0f),Ogre::Vector3::UNIT_Y);
						//q.FromAngleAxis(Ogre::Radian(angle/2.0f),rotateAxis);
						Ogre::Vector3 circlePt = node->getPosition() + (q * originDir)* (this->mpStyle->getSmoothFactor()*this->mpStyle->getWidth()/Ogre::Math::Sin(angleAbs/2.0f));

						float azimuthAngle1 =  VirtualMine::MathEngine::CMathCalculator::CalculateAzimuth(originDir*(-1.0f));
						CLaneWaySection* sectionStart = this->createSection(this->mpStyle);
						sectionStart->Rotate(Ogre::Radian(azimuthAngle1));
						float startOffset = this->mpStyle->getSmoothFactor()*this->mpStyle->getWidth() / Ogre::Math::Tan(angleAbs/2.0f);
						startOffset = startOffset/Ogre::Math::Abs(Ogre::Math::Cos(dirOriginAngle));
						Ogre::Vector3 startPos = node->getPosition() + startOffset*(originDir);
						sectionStart->setPosition(startPos);
						nodeSections.push_back(sectionStart);

						Ogre::Vector3 radius = startPos - circlePt;
						radius.normalise();

						if (angleAbs < Ogre::Math::PI * 0.9)
						{
							for (int i = 1;i<5;i++)
							{
								CLaneWaySection* section = this->createSection(this->mpStyle);
								section->Rotate(Ogre::Radian(azimuthAngle1-(angle/angleAbs)*i*(Ogre::Math::PI-angleAbs)/5));

								Ogre::Quaternion q;
								//q.FromAngleAxis(Ogre::Radian(-(angle/angleAbs)*i*(Ogre::Math::PI-angleAbs)/5),Ogre::Vector3::UNIT_Y);
								q.FromAngleAxis(Ogre::Radian(-(angle/angleAbs)*i*(Ogre::Math::PI-angleAbs)/5),rotateAxis);
								Ogre::Vector3 pos =  q*radius *this->mpStyle->getSmoothFactor()*this->mpStyle->getWidth() + circlePt ;
								section->setPosition(pos);
								nodeSections.push_back(section);
							}
						}

						float azimuthAngle2 = VirtualMine::MathEngine::CMathCalculator::CalculateAzimuth(endDir);
						CLaneWaySection* sectionEnd = this->createSection(this->mpStyle);
						sectionEnd->Rotate(Ogre::Radian(azimuthAngle2));
						float endOffset = this->mpStyle->getSmoothFactor()*this->mpStyle->getWidth() / Ogre::Math::Tan(angleAbs/2.0f);
						endOffset = endOffset/Ogre::Math::Abs(Ogre::Math::Cos(dirEndAngle));
						Ogre::Vector3 endPos = node->getPosition() + endOffset*endDir;
						sectionEnd->setPosition(endPos);
						nodeSections.push_back(sectionEnd);			

						line->addFlexSections(nodeSections);
					}
					#pragma endregion 
				}	
			}

			#pragma endregion 

#pragma region 构建顶点和索引集合


		///*	Ogre::MaterialPtr material = Ogre::MaterialManager::getSingletonPtr()->getByName("testMaterial000",VirtualMine::Core::VR_MINE_DEFAULT_RESOURCE_GROUP);

		//	if (!material.isNull())
		//	{
		//		Ogre::Pass* pass = material->getTechnique(0)->getPass(0);
		//		pass->setCullingMode(Ogre::CULL_NONE);
		//		pass->createTextureUnitState("laneway.jpg");
		//		material->load();
		//	}*/
			//for (std::vector<CLaneWayLineGeometry*>::iterator iteLine = this->mLanewayLines.begin(); iteLine!=this->mLanewayLines.end();iteLine++ )
			for(size_t i = 0;i<this->mLanewayLines.size();++i)
			{
				//CLaneWayLineGeometry* line = (*iteLine);

				CLaneWayLineGeometry* line = this->mLanewayLines[i];

				CLaneWayObject* lanewayObject = dynamic_cast<CLaneWayObject*>(this->ref_mGeoObjectVector[i]);

				VirtualMine::Style::CLanewayStyle* tempStyle = dynamic_cast<VirtualMine::Style::CLanewayStyle*>(this->ref_mGeoObjectVector[i]->getStyle());

				CGeoExtentionData* geoExtentionData = new CGeoExtentionData(this->ref_mpSceneMgr);
				//added by sjl->2015-7-24
				geoExtentionData->setOwnerObject(lanewayObject);
				//kk不能重复manualobject名字,在这里要加个数字

				char t[256];
				std::string s;

				sprintf(t, "%d", this->mauobjectnum);
				s = t;
		
				Ogre::ManualObject* renderObject = this->ref_mpSceneMgr->createManualObject(line->getName() + "_line" +s);
				//kk
				this->mauobjectnum++;
				Ogre::Any any((VirtualMine::Core::CBaseObject*)(lanewayObject));

				Ogre::MaterialPtr mat = Ogre::MaterialManager::getSingletonPtr()->getByName(tempStyle->getSupportImg(),VirtualMine::Core::VR_MINE_DEFAULT_RESOURCE_GROUP);
#pragma region 注释
				//int nodesCount = line->getNodesCount();
				//for (int i = 0 ; i< nodesCount; ++i)
				//{
				//	CLaneWayNodeGeometry* tempNode = line->getNode(i);
				//	if (tempNode->getPosition().y >= -50 && tempNode->getPosition().y <= 50)
				//	{
				//		if (i == nodesCount - 1)
				//		{
				//			if (!mat.isNull())
				//			{
				//				std::string name = tempStyle->getSupportImg();
				//				Ogre::GpuProgramParametersSharedPtr gpSp = mat->getTechnique(0)->getPass(0)->getFragmentProgramParameters();
				//				/*gpSp->setNamedConstant("addMode",1);
				//				gpSp->setNamedConstant("addColor", Ogre::ColourValue(0.0,0.0,0.0,1.0));*/
				//			}
				//		}
				//	}
				//	else
				//	{
				//		break;
				//	}
				//}
#pragma endregion
				renderObject->setUserAny(any);

#pragma region 开始创建 ManualObject
				renderObject->begin(mat->getName(), Ogre::RenderOperation::OT_TRIANGLE_LIST,VirtualMine::Core::VR_MINE_DEFAULT_RESOURCE_GROUP);

				for (int indexSec = 0;indexSec<line->getSectionCount();indexSec++)
				{
					CLaneWaySection* section = line->getSection(indexSec);	

					float distance = 0.0f;
					if (indexSec % 2 != 0)
					{
						CLaneWaySection* preSection = line->getSection(indexSec-1);
						distance = (preSection->getPoints()[0]-section->getPoints()[0]).length();
					}

					for (int i = 0;i<section->getPointsCount();i++)
					{
						//设置位置
						renderObject->position(section->getPoints()[i]);
						if (indexSec % 2 == 0)
						{
							if (i == 0)
							{
								renderObject->textureCoord(0,0);
							}
							if (i == 1)
							{
								renderObject->textureCoord(0,0.25);
							}
							if (i == 2)
							{
								renderObject->textureCoord(0,0.5);
							}
							if (i == 3)
							{
								renderObject->textureCoord(0,0.75);
							}
							if (i>3)
							{
								renderObject->textureCoord(0,0.75 + (i-3)*0.25/18);
							}
						}
						else
						{
							if (i == 0)
							{
								renderObject->textureCoord(distance/3,0);
							}
							if (i == 1)
							{
								renderObject->textureCoord(distance/3,0.25);
							}
							if (i == 2)
							{
								renderObject->textureCoord(distance/3,0.5);
							}
							if (i == 3)
							{
								renderObject->textureCoord(distance/3,0.75);
							}
							if (i>3)
							{
								renderObject->textureCoord(distance/3,0.75 + (i-3)*0.25/18);
							}
						}

					}	
				}

				for (int i = 1;i<line->getSectionCount();i++)
				{
					if (i%2 == 0)  continue;
					for (int j = 1;j<line->getSection(0)->getPointsCount();j++)
					{
						renderObject->triangle((i-1)*22 +j-1, i*22+j-1, i*22+j);
						renderObject->triangle(i*22+j, (i-1)*22+j, (i-1)*22+j-1);
					}
				}
				renderObject->end();		
#pragma endregion 

#pragma region 创建ManualObject巷道拐角处				
				for (int indexSec = 0;indexSec<line->getFlexSectionsCount();indexSec++)
				{
					std::vector<CLaneWaySection*> sections = line->getFlexSections(indexSec);
					renderObject->begin(tempStyle->getSupportImg(), Ogre::RenderOperation::OT_TRIANGLE_LIST,VirtualMine::Core::VR_MINE_DEFAULT_RESOURCE_GROUP);
					                                                                                     
					int index2 = 0;
					for (std::vector<CLaneWaySection*>::iterator iteflexSection  = sections.begin();iteflexSection!=sections.end();iteflexSection++)
					{
						CLaneWaySection* section = (*iteflexSection);
						for (int i = 0;i<section->getPointsCount();i++)
						{
							renderObject->position(section->getPoints()[i]);
							if (i == 0)
							{
								renderObject->textureCoord((float)index2/sections.size(),0);
							}
							if (i == 1)
							{
								renderObject->textureCoord((float)index2/sections.size(),0.25);
							}
							if (i == 2)
							{
								renderObject->textureCoord((float)index2/sections.size(),0.5);
							}
							if (i == 3)
							{
								renderObject->textureCoord((float)index2/sections.size(),0.75);
							}
							if (i>3)
							{
								renderObject->textureCoord((float)index2/sections.size(),0.75 + (i-3)*0.25/18);
							}
						}
						index2++;
					}

					for (int i = 1;i<sections.size();i++)
					{
						for (int j = 1;j<line->getSection(0)->getPointsCount();j++)
						{
							renderObject->triangle((i-1)*22 +j-1, i*22+j-1, i*22+j);
							renderObject->triangle(i*22+j, (i-1)*22+j, (i-1)*22+j-1);
						}
					}
					renderObject->end();
				}
#pragma endregion 

#pragma endregion
				geoExtentionData->setExtentionData(renderObject);
				this->ref_mGeoExtantionDataVector->push_back(geoExtentionData);
			}	
		}

		void CLaneway_MeshCreator::buildIntersectionPart()
		{
			#pragma region 创建截面
			int index = 0;
			for (std::vector<CLaneWayCrossNodeGeometry*>::iterator iteCross = this->mLanewayCrossNodes.begin();iteCross!=this->mLanewayCrossNodes.end();iteCross++)
			{
				CLaneWayCrossNodeGeometry* crossNode = (*iteCross);

				if (crossNode == NULL || crossNode->getCrossNode() == NULL)
				{
					break;
				}
				///交叉点的邻近点为 0 
			    if (crossNode->getAdjancentNodesCount()  > 0)
			    {
				
					for (int i = 0;i<crossNode->getAdjancentNodesCount();i++)
					{
						CLaneWayNodeGeometry* node = crossNode->getAdjancentNode(i);
						//计算截面偏角
						Ogre::Vector3 direction = node->getPosition() - crossNode->getCrossNode()->getPosition();
						direction.y = 0;
						direction.normalise();
						float azimuthAngle = VirtualMine::MathEngine::CMathCalculator::CalculateAzimuth(direction);

						CLaneWaySection* section = this->createSection(this->mpStyle);
						section->Rotate(Ogre::Radian(azimuthAngle));

						Ogre::Vector3 startPos = this->getCrossOffsetPos(node,crossNode,this->mpStyle);
						section->setPosition(startPos);

						crossNode->addSection(section);				
					}
			    }

				
				index++;
			}
				
			#pragma endregion
			
			#pragma region 构建顶点和索引集合

			for (std::vector<CLaneWayCrossNodeGeometry*>::iterator iteCross = this->mLanewayCrossNodes.begin();iteCross!=this->mLanewayCrossNodes.end();iteCross++)
			{
				CLaneWayCrossNodeGeometry* crossNode = (*iteCross);

				assert(crossNode != NULL);

				CGeoExtentionData* geoExtentionData = new CGeoExtentionData(this->ref_mpSceneMgr);
				assert(geoExtentionData != NULL);
				Ogre::ManualObject* renderObject = this->ref_mpSceneMgr->createManualObject(crossNode->getCrossNode()->getName() + "_Intersection");
				assert(renderObject != NULL);

				renderObject->begin("testMaterial", Ogre::RenderOperation::OT_TRIANGLE_LIST,VirtualMine::Core::VR_MINE_DEFAULT_RESOURCE_GROUP);
			
					int pointCount = 0;
					for (int i = 0;i<crossNode->getSectionsCount();i++)
					{
						CLaneWaySection* section = crossNode->getSection(i);
						assert(section != NULL);

						for (int j = 0;j<section->getPointsCount();j++)
						{
							renderObject->position(section->getPoints()[j]);
							pointCount++;
						}		
					}

					for (int i = 0;i<crossNode->getSectionsCount();i++)
					{
						CLaneWaySection* section = crossNode->getSection(i);
						assert(section != NULL);

						renderObject->position(section->getPoints()[12]);
						pointCount++;		
					}

					Ogre::Vector3 topPt = Ogre::Vector3(0,0,0);
					Ogre::Vector3 bottomPt = Ogre::Vector3(0,0,0);

					if (crossNode->getSectionsCount() > 0)
					{
						for (int i = 0;i<crossNode->getSectionsCount();i++)
						{
							CLaneWaySection* section = crossNode->getSection(i);
							assert(section != NULL);

							topPt = topPt + section->getPoints()[12];
							bottomPt=bottomPt+section->getPoints()[1];
						}
					}
					if(crossNode->getSectionsCount() > 0)
					{
						topPt = topPt/crossNode->getSectionsCount();
						bottomPt = bottomPt/crossNode->getSectionsCount();
					}
					

					renderObject->position(topPt);
					pointCount++;

					renderObject->position(bottomPt);
					pointCount++;		

					if (crossNode->getAdjancentNodesCount() == 2)
					{
						//绘制底面
						for (int i = 0;i<crossNode->getSectionsCount();i++)
						{
							if (i ==crossNode->getSectionsCount()-1)
							{
								renderObject->triangle(i*22+2, i*22+1, 2);
								//renderObject->setMaterialName()

								renderObject->triangle(i*22+2, 1, 2);
							}
						}
					}
					else if (crossNode->getAdjancentNodesCount() > 2) ///原来是else
					{
						//绘制底面
						for (int i = 0; i < crossNode->getSectionsCount(); i++)
						{
							if (i != crossNode->getSectionsCount()-1)
							{
								renderObject->triangle(i*22+2, i*22+1, pointCount-1);
								renderObject->triangle(i*22+2, (i+1)*22+1, pointCount-1);
							}
							else
							{
								renderObject->triangle(i*22+2, i*22+1, pointCount-1);
								renderObject->triangle(i*22+2, 1, pointCount-1);
							}
						}

						//绘制顶面
						for (int i = 0;i<crossNode->getSectionsCount();i++)
						{
							int index = 22 * crossNode->getSectionsCount();
							if (i!=crossNode->getSectionsCount()-1)
							{
								renderObject->triangle(index+i+1,index+i,  pointCount-2);
							}
							else
							{
								renderObject->triangle(index+i,index,  pointCount-2);
							}		
						}
					}
			

					//绘制侧面
					for (int i = 0;i<crossNode->getSectionsCount();i++)
					{
						if (i != crossNode->getSectionsCount()-1)
						{
							renderObject->triangle(i*22+2,i*22+3, (i+1)*22);
							renderObject->triangle((i+1)*22,(i+1)*22+1, i*22+2);
						}
						else
						{
							renderObject->triangle(i*22+2,i*22+3, 0);
							renderObject->triangle(0, 1, i*22+2);
						}
					}

					for (int i = 0;i<crossNode->getSectionsCount();i++)
					{
						if (i != crossNode->getSectionsCount()-1)
						{
							for (int j=0;j<9;j++)
							{
								renderObject->triangle(i*22+3+j,(i+1)*22+21-j,  (i+1)*22+21-j-1);
								renderObject->triangle(i*22+3+j,i*22+3+j+1,(i+1)*22+21-j-1);
							}				
						}
						else
						{
							for (int j=0;j<9;j++)
							{
								renderObject->triangle(i*22+3+j,21-j,  21-j-1);
								renderObject->triangle(i*22+3+j,i*22+3+j+1, 21-j-1);
							}	
						}
					}			
					renderObject->end();	

					geoExtentionData->setExtentionData(renderObject);
					this->ref_mGeoExtantionDataVector->push_back(geoExtentionData);
				}
				
			
			#pragma endregion


			int i = 0;
		}
	}
}
