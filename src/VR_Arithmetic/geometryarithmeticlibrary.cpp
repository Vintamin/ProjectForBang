//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : 三维数字矿山平台
//  @ File Name : geometryarithmeticlibrary.cpp
//  @ Date : 2014/7/6
//  @ Author : 盛佳良
//  @ Implement : 
//  @ Company : 中国矿业大学(北京)
//  @ Copyright:  2014-2020
//  @ Description : 


#include "vrmine\vr_arithmetic\arithmetic\geometryarithmeticlibrary.h"
#include "OGRE\OgrePrerequisites.h"
#include "OGRE\OgreVector3.h"

namespace VirtualMine
{
	namespace Arithmetic
	{
		const double EP = 0.00000001;
		// 点结构
		typedef struct PT{
			double x;
			double y;
		}PT;

		//线结构
		typedef struct SEGMENT
		{
			PT* ptStart;
			PT* ptEnd;
		}SEGMENT;

		//三角形类
		class TRIANGLE
		{

		public:

			TRIANGLE(PT* pt1, PT* pt2, PT* pt3)
			{
				//确保三个点x坐标升序排序
				PT* temp;
				if(pt1->x > pt2->x){temp = pt1; pt1 = pt2; pt2 = temp;}
				if(pt3->x < pt1->x  && pt3->x )
				{
					temp = pt3; pt3 = pt1; pt1 = temp;
					if(pt3->x < pt2->x){temp=pt3;pt3=pt2;pt2=temp;}
				}
				if(pt3->x < pt2->x){temp=pt3;pt3=pt2;pt2=temp;}

				_ptFirst = pt1;
				_ptSecond = pt2;
				_ptThird = pt3;

				InitData();

			}
			PT* GetFirstPt(){return _ptFirst;}
			PT* GetSecondPt(){return _ptSecond;}
			PT* GetThirdPt(){return _ptThird;}

			SEGMENT GetSegment1(){SEGMENT seg = {_ptFirst,_ptSecond};return seg;}
			SEGMENT GetSegment2(){SEGMENT seg = {_ptFirst,_ptThird};return seg;}
			SEGMENT GetSegment3(){SEGMENT seg = {_ptSecond,_ptThird};return seg;}

			bool IsTriangleSame(TRIANGLE& tri)
			{
				if(tri.GetFirstPt() == _ptFirst &&
					tri.GetSecondPt() == _ptSecond &&
					tri.GetThirdPt() == _ptThird)
					return true;

				return false;
			}

			bool IsPtInCircle(PT* pt)
			{
				double offsetx = pt->x - _ptCenter.x;
				double offsety = pt->y - _ptCenter.y;
				if(sqrt(offsetx*offsetx + offsety*offsety) <= _Radius)
					return true;

				return false;

			}
		protected:

			// 获取三角形外接圆中心点及半径
			void InitData()
			{
				double x0 = _ptFirst->x;
				double y0 = _ptFirst->y;

				double x1 = _ptSecond->x;
				double y1 = _ptSecond->y;

				double x2 = _ptThird->x;
				double y2 = _ptThird->y;


				double y10 = y1 - y0;
				double y21 = y2 - y1;

				bool b21zero = y21 > - EP && y21 < EP;

				if (y10 > - EP && y10 < EP)
				{
					if (b21zero)  
					{
						if (x1 > x0)
						{
							if (x2 > x1) x1 = x2;
						}
						else
						{
							if (x2 < x0) x0 = x2;
						}
						_ptCenter.x = (x0 + x1) * .5F;
						_ptCenter.y = y0;
					}
					else  
					{
						double m1 = - (x2 - x1) / y21;

						double mx1 = (x1 + x2) * .5F;
						double my1 = (y1 + y2) * .5F;

						_ptCenter.x = (x0 + x1) * .5F;
						_ptCenter.y = m1 * (_ptCenter.x - mx1) + my1;
					}
				}
				else if (b21zero)  
				{
					double m0 = - (x1 - x0) / y10;

					double mx0 = (x0 + x1) * .5F;
					double my0 = (y0 + y1) * .5F;

					_ptCenter.x = (x1 + x2) * .5F;
					_ptCenter.y = m0 * (_ptCenter.x - mx0) + my0;
				}
				else  
				{
					double m0 = - (x1 - x0) / y10;
					double m1 = - (x2 - x1) / y21;

					double mx0 = (x0 + x1) * .5F;
					double my0 = (y0 + y1) * .5F;

					double mx1 = (x1 + x2) * .5F;
					double my1 = (y1 + y2) * .5F;

					_ptCenter.x = (m0 * mx0 - m1 * mx1 + my1 - my0) / (m0 - m1);
					_ptCenter.y = m0 * (_ptCenter.x - mx0) + my0;
				}

				double dx = x0 - _ptCenter.x;
				double dy = y0 - _ptCenter.y;

				_Radius2 = dx * dx + dy * dy;    // the radius of the circumcircle, squared
				_Radius = (double) sqrt(_Radius2);    // the proper radius

				_Radius2 *= 1.000001f;
			}
		private:
			PT* _ptFirst;
			PT* _ptSecond;
			PT* _ptThird;

			PT            _ptCenter;
			double        _Radius2;
			double        _Radius;
		};

		class CDelaunay
		{
		public:
			//判断三个点能否组成一个三角形
			static bool isPtsBuildTriangle(PT* pt1, PT* pt2, PT* pt3)
			{
				double offset_x1 = pt2->x - pt1->x;
				double offset_x2 = pt3->x - pt2->x;
				double offset_y1 = pt2->y - pt1->y;
				double offset_y2 = pt3->y - pt2->y;

				if((fabs(offset_x1) < EP) && (fabs(offset_x2) < EP))    //竖直
				{
					return false;
				}

				if(fabs(offset_x1) > EP && fabs(offset_x2) > EP)
				{
					if(fabs(offset_y1/offset_x1 - offset_y2/offset_x2) < EP)
						return false;
				}

				return true;
			}
			static void buildDelaunayEx(std::vector<PT>& vecPT, IntVector& indexVector)
			{
				int nSize = vecPT.size();
				if(nSize < 3)
					return;
				for(int i = 0; i < nSize - 2; ++i)
				{
					for(int j = i + 1;  j < nSize - 1; ++j)
					{
						for(int k = j + 1; k < nSize; ++k)
						{
							PT* pt1 = &vecPT[i];
							PT* pt2 = &vecPT[j];
							PT* pt3 = &vecPT[k];
							bool bFind = true;
							for(int m = 0; m < nSize; ++m)
							{
								PT* pt = &vecPT[m];
								if(pt != pt1 && pt != pt2 && pt != pt3 && isPtsBuildTriangle(pt1, pt2, pt3))
								{
									TRIANGLE tri(pt1, pt2, pt3);
									if(tri.IsPtInCircle(pt))
									{
										bFind = false;
										break;
									}
								}
							}
							if(bFind)
							{  
								indexVector.push_back(i);
								indexVector.push_back(j);
								indexVector.push_back(k);
							}

						}
					}
				}
			}
		};
		void CGeometryArithmeticLibrary::createLineBufferArea()
		{

		}

		void CGeometryArithmeticLibrary::triangulatePolygon(CoorVector& vertexes,IntVector& indexes)
		{
			/*Ogre::Real xmin,xmax,zmin,zmax,xmid,zmid;
			Ogre::Real dx,dz,dmax;

			xmin = vertexes[0].x;
			zmin = vertexes[0].z;
			xmax = xmin;
			zmax = zmin;
			int vertexCount = vertexes.size();
			for (int i = 1; i < vertexCount; i++)
			{
			if (vertexes[i].x < xmin)      xmin = Vertex[i].x;
			if (vertexes[i].x > xmax)      xmax = Vertex[i].x;
			if (vertexes[i].z < zmin)      zmin = Vertex[i].z;
			if (vertexes[i].z > zmax)      zmax = Vertex[i].z;
			}

			dx = xmax - xmin;
			dz = zmax - zmin;
			if ( dx > dz )
			dmax = dx;
			else
			dmax = dz;
			xmid = (xmax + xmin) / 2;
			zmid = (zmax + zmin) / 2;*/


		}

		/*void CGeometryArithmeticLibrary::triangulatePolygon()
		{

		}*/

		void CGeometryArithmeticLibrary::smoothingMeshData()
		{

		}
		void CGeometryArithmeticLibrary::createTINData(CoorVector& vertexes,IntVector& indexes)
		{
			std::vector<PT> vecPT;
			for (int i = 0 ; i < vertexes.size() ; ++i)
			{
				PT p ;
				p.x = vertexes[i].x;
				p.y = vertexes[i].z;
				vecPT.push_back(p);
			}
			CDelaunay::buildDelaunayEx(vecPT,indexes);
			vertexes.clear();
			//typedef std::vector<bool> boolVector;
			//typedef std::vector<triangle> TriangleVector;
			//CoorVector curVertexes(vertexes.begin(),vertexes.end());
			//boolVector completeVector;
			//TriangleVector triangles;
			//int MAX_TRIANGLE = 300000;
			//int pointCount = curVertexes.size();
			//for (int i = 0 ; i < MAX_TRIANGLE + 1 ; ++i)
			//{
			//	completeVector.push_back(false);
			//}

			//long Edges[3][3001]; 
			//long Nedge; /// 

			//// For Super Triangle
			//long   xmin,xmax,ymin,ymax,xmid,ymid;
			//double dx,dy,dmax;

			////get the bounds of these points
			//xmin = curVertexes[0].x;
			//ymin = curVertexes[0].y;
			//xmax = xmin;
			//ymax = ymin;
			//for ( i = 1; i <= pointCount; i++)
			//{
			//	if (curVertexes[i].x < xmin)      
			//		xmin = curVertexes[i].x;
			//	if (curVertexes[i].x > xmax)      
			//		xmax = curVertexes[i].x;
			//	if (curVertexes[i].y < ymin)      
			//		ymin = curVertexes[i].y;
			//	if (curVertexes[i].y > ymax)     
			//		ymax = curVertexes[i].y;
			//}

			//dx = xmax - xmin;
			//dy = ymax - ymin;
			//if ( dx > dy )
			//	dmax = dx;
			//else
			//	dmax = dy;
			//xmid = (xmax + xmin) / 2;
			//ymid = (ymax + ymin) / 2;

			////构建第一个三角形
			//Ogre::Vector3 p ;
			//p.x = xmid - 2 * (long)dmax;
			//p.y = ymid - (long)dmax;
			//curVertexes.push_back(p);
			//p.x = xmid;
			//p.y = ymid + 2 * (long)dmax;
			//curVertexes.push_back(p);
			//p.x = xmid + 2 * (long)dmax;
			//p.y = ymid - (long)dmax;
			//curVertexes.push_back(p);

			//triangle tri;
			//tri.vv0 = pointCount ;
			//tri.vv1 = pointCount + 1;
			//tri.vv2 = pointCount + 2;

			//triangles.push_back(tri);

			//completeVector[0] = false;
			//int ntri = 1;

			//////////////////
			//// Include each point one at a time into the existing mesh
			//for (int i = 0; i < pointCount; i++)
			//{
			//	Nedge = 0;
			//	/* Set up the edge buffer.
			//	'If the point (Vertex(i).x,Vertex(i).y) lies inside the circumcircle then the
			//	'three edges of that triangle are added to the edge buffer.
			//	*/
			//	int j = 0;
			//	do
			//	{
			//		j = j + 1;
			//		if ( completeVector[j] != true ) 
			//		{
			//			double xc,yc,r;
			//			bool inc = isTriangleInCircle(curVertexes[i].x, curVertexes[i].y, 
			//				curVertexes[Triangle[j].vv0].x, 
			//				curVertexes[Triangle[j].vv0].y, 
			//				curVertexes[Triangle[j].vv1].x, 
			//				curVertexes[Triangle[j].vv1].y, 
			//				curVertexes[Triangle[j].vv2].x, 
			//				curVertexes[Triangle[j].vv2].y, 
			//				xc, yc, r);

			//			if (inc)
			//			{
			//				Edges[1][Nedge + 1] = Triangle[j].vv0;
			//				Edges[2][Nedge + 1] = Triangle[j].vv1;
			//				Edges[1][Nedge + 2] = Triangle[j].vv1;
			//				Edges[2][Nedge + 2] = Triangle[j].vv2;
			//				Edges[1][Nedge + 3] = Triangle[j].vv2;
			//				Edges[2][Nedge + 3] = Triangle[j].vv0;
			//				Nedge = Nedge + 3;
			//				Triangle[j].vv0 = Triangle[ntri].vv0;
			//				Triangle[j].vv1 = Triangle[ntri].vv1;
			//				Triangle[j].vv2 = Triangle[ntri].vv2;
			//				completeVector[j] = completeVector[ntri];
			//				j = j - 1;
			//				ntri = ntri - 1;
			//			}
			//		}
			//	}while(j < ntri);


			//	//'Tag multiple edges
			//	//'Note: if all triangles are specified anticlockwise then all
			//	//'interior edges are opposite pointing in direction.
			//	for ( j = 1; j <= Nedge - 1; j++)
			//	{
			//		// 当表达式有多种运算符时，先处理算术运算符，接着处理比较运算符，然后再处理逻辑运算符。 /// ?
			//		// If Not Edges(1, j) = 0 And Not Edges(2, j) = 0 Then
			//		if ( !(Edges[1][j] == 0) && !(Edges[2][j] == 0) )
			//		{
			//			//TRACE("enter then. ij=%ld-%ld\n", i, j);
			//			for (int k = j + 1; k <= Nedge; k++)
			//			{
			//				if ( !(Edges[1][k] == 0 ) && !(Edges[2][k] == 0) )
			//				{
			//					if ( Edges[1][j] == Edges[2][k] )
			//					{
			//						if ( Edges[2][j] == Edges[1][k] )
			//						{
			//							Edges[1][j] = 0;
			//							Edges[2][j] = 0;
			//							Edges[1][k] = 0;
			//							Edges[2][k] = 0;
			//						}
			//					}
			//				}
			//			}
			//		}
			//	}

			//	//'Form new triangles for the current point
			//	//'Skipping over any tagged edges.
			//	//'All edges are arranged in clockwise order.
			//	for ( j = 1; j <= Nedge; j++)
			//	{
			//		if ( !(Edges[1][j] == 0) && !(Edges[2][j] == 0 ) )
			//		{
			//			ntri = ntri + 1;
			//			Triangle[ntri].vv0 = Edges[1][j];
			//			Triangle[ntri].vv1 = Edges[2][j];
			//			Triangle[ntri].vv2 = i;
			//			completeVector[ntri] = false;
			//		}
			//	}
			//}

		}

	}
}
