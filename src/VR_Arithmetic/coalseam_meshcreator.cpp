//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : 三维数字矿山平台
//  @ File Name : coalseam_meshcreator.cpp
//  @ Date : 2014/8/5
//  @ Author : 朱炜鹏
//  @ Implement : 
//  @ Company : 中国矿业大学(北京)
//  @ Copyright:  2014-2020
//  @ Description : 


#include "vrmine/vr_arithmetic/arithmetic/coalseam_meshcreator.h"
#include "vrmine/vr_core/geodatatype.h"
#include "vrmine/vr_spatialobject/mine/coalseamobject.h"
#include "vrmine/vr_geometry/geometry/coalseam.h"
#include "vrmine/vr_spatialobject/geoproperty/coalseamproperty.h"
#include "vrmine/vr_style/style/coalseamstyle.h"
#include "vrmine/vr_arithmetic/arithmetic/geometryarithmeticlibrary.h"
#include <OGRE/OgreBlendMode.h>
#include "vrmine/vr_spatialinterface/iscene.h"
#include "vrmine/vr_arithmetic/arithmetic/Delaunaymath.h"

using namespace std;

#define  borderNodesCount 100

namespace VirtualMine
{
	namespace Arithmetic
	{
		CCoalSeam_MeshCreator::CCoalSeam_MeshCreator()
		{
			this->setType(VirtualMine::Core::GeoDataType::GDT_COALSEAM);
		}

		CCoalSeam_MeshCreator::~CCoalSeam_MeshCreator()
		{

		}
//
//		void CCoalSeam_MeshCreator::createData2(VirtualMine::SpatialInterface::GeoObjectVector& geoObjectVector,std::vector<VirtualMine::SpatialInterface::CGeoExtentionData*>& geoExtentionDatas)
//		{
//			if (geoObjectVector.size() == 0)
//			{
//				return;
//			}
//
//			int coalCount = geoObjectVector.size();
//			if (coalCount < 1)
//			{
//				return;
//			}
//
//
//			//	std::vector<string> terraneName; //记录岩层的名字
//
//			for (int m = 0;  m < coalCount;m++)
//			{
//				//orderTerrane = m;
//
//				VirtualMine::Mine::CCoalSeamObject* coalObject = dynamic_cast<VirtualMine::Mine::CCoalSeamObject*>(geoObjectVector[m]);
//				if (coalObject == NULL)
//				{
//					return;
//				}
//				VirtualMine::Geometry::CCoalSeamGeometry* coalGeometry = dynamic_cast<VirtualMine::Geometry::CCoalSeamGeometry*>(coalObject->getGeometry());
//				VirtualMine::GeoProperty::CCoalSeamProperty* coalProperty = dynamic_cast<VirtualMine::GeoProperty::CCoalSeamProperty*>(coalObject->getGeoProperty());
//				VirtualMine::Style::CCoalSeamStyle* coalStyle = dynamic_cast<VirtualMine::Style::CCoalSeamStyle*>(coalObject->getStyle());
//
//				VirtualMine::SpatialInterface::CGeoExtentionData* data = new VirtualMine::SpatialInterface::CGeoExtentionData();
//
//				//	string tempName = coalProperty->getName();
//				//	terraneName.push_back(tempName);
//
//				Ogre::ManualObject* renderObject = this->ref_mpSceneMgr->createManualObject(coalProperty->getName());
//				data->setExtentionData(renderObject);
//
//				geoExtentionDatas.push_back(data);
//
//				//std::vector<Ogre::Vector3> coors;
//				//IntVector indexes;
//
//				if (coalGeometry!= NULL && coalProperty!=NULL && coalStyle !=NULL)
//				{
//					renderObject->begin("testMaterial", Ogre::RenderOperation::OT_TRIANGLE_LIST);
//
//					for (int i = 0;i<coalGeometry->getCount();i++)
//					{
//						VirtualMine::Geometry::CPoint point = coalGeometry->getPoint(i);
//						Ogre::Vector3 realPoint = Ogre::Vector3(point.getX(),point.getY(),point.getZ());
//						renderObject->position(realPoint);
//						//Ogre::Vector3 planePoint = realPoint;
//						//planePoint.y = 0;
//						//coors.push_back(planePoint);
//						//	tempVec2.push_back(realPoint);
//					}
//#if 0  构建边界点
//
//					int tempcount = m*borderNodesCount*borderNodesCount;
//					for (int i = 0 ;i < borderNodesCount; i++)
//					{
//						boderNodes.push_back(tempVec2[i+tempcount]);  //up
//
//					}
//					for (int i = 0 ;i < borderNodesCount; i++)
//					{
//						boderNodes.push_back(tempVec2[(i+1)*borderNodesCount-1+tempcount]);  //right
//
//					}
//					for (int i = 0 ;i < borderNodesCount; i++)
//					{
//						boderNodes.push_back(tempVec2[borderNodesCount*borderNodesCount-1-i+tempcount]);  //down
//
//
//					}
//					for (int i = 0 ;i < borderNodesCount; i++)
//					{
//						boderNodes.push_back(tempVec2[borderNodesCount*(borderNodesCount-1)-i*borderNodesCount+tempcount]);  //left
//
//					}
//
//#endif		
//					////VirtualMine::Arithmetic::CGeometryArithmeticLibrary::createTINData(coors,indexes);
//
//					//for (int i = 0;i<indexes.size()/3;i++)
//					//{
//					//	renderObject->triangle(indexes[3*i],indexes[3*i+1],indexes[3*i+2]);
//					//}
//
//					for (int indexcol = 0; indexcol<borderNodesCount -1;indexcol++)
//					{
//						for(int index = 0; index < borderNodesCount -1; index++)
//						{
//							renderObject->triangle(indexcol*borderNodesCount+index,indexcol*borderNodesCount+index+1,(indexcol+1)*borderNodesCount+index);
//							renderObject->triangle(indexcol*borderNodesCount+index+1, (indexcol+1)*borderNodesCount+index+1,(indexcol+1)*borderNodesCount+index);
//
//
//						}
//					}
//
//					renderObject->end();	
//				}
//
//			}
//
//
//#if 0  构建侧面
//
//
//			for (int i = 0; i < coalCount-1; i++)
//			{
//				Ogre::ManualObject* siderRenderObject = this->ref_mpSceneMgr->createManualObject(terraneName[i]+"_silder");
//				siderRenderObject->begin("testMaterial",Ogre::RenderOperation::OT_TRIANGLE_LIST,VirtualMine::Core::VR_MINE_DEFAULT_RESOURCE_GROUP);
//				VirtualMine::SpatialInterface::CGeoExtentionData* siderData = new VirtualMine::SpatialInterface::CGeoExtentionData();
//				siderData->setExtentionData(siderRenderObject);
//				geoExtentionDatas.push_back(siderData);
//				//构建顶点和索引
//				int tempTerraneCount = boderNodes.size()/coalCount; //每层边界点的个数
//				for (int n = 0; n <2*tempTerraneCount;n++)
//				{
//					//Ogre::Vector3 tempVec3 = boderNodes[i+tempTerraneCount*(orderTerrane-1)];
//					siderRenderObject->position(boderNodes[n+i*tempTerraneCount]);
//					siderRenderObject->textureCoord(0,n*(1.0/(tempTerraneCount-1)));
//
//				}
//
//				for (int k = 0;k<tempTerraneCount-1;k++)
//				{
//					siderRenderObject->triangle(k,k+1,tempTerraneCount+k);
//					siderRenderObject->triangle(k+1,tempTerraneCount+k,tempTerraneCount+1+k);
//				}
//
//				siderRenderObject->end();
//			}
//#endif			
//
//
//
//		}

		void CCoalSeam_MeshCreator::createData(VirtualMine::SpatialInterface::GeoObjectVector& geoObjectVector,std::vector<VirtualMine::SpatialInterface::CGeoExtentionData*>& geoExtentionDatas)
		{
			if (geoObjectVector.size() == 0)
			{
				return;
			}
		
			int coalCount = geoObjectVector.size();
			if (coalCount < 1)
			{
				return;
			}
		
			//int orderTerrane; //地层编号
			for (int i = 0;  i < coalCount;i++)
			{
				//orderTerrane = i; //
					VirtualMine::Mine::CCoalSeamObject* coalObject = dynamic_cast<VirtualMine::Mine::CCoalSeamObject*>(geoObjectVector[i]);
			if (coalObject == NULL)
			{
				return;
			}
			VirtualMine::Geometry::CCoalSeamGeometry* coalGeometry = dynamic_cast<VirtualMine::Geometry::CCoalSeamGeometry*>(coalObject->getGeometry());
			VirtualMine::GeoProperty::CCoalSeamProperty* coalProperty = dynamic_cast<VirtualMine::GeoProperty::CCoalSeamProperty*>(coalObject->getGeoProperty());
			VirtualMine::Style::CCoalSeamStyle* coalStyle = dynamic_cast<VirtualMine::Style::CCoalSeamStyle*>(coalObject->getStyle());
		
			VirtualMine::SpatialInterface::CGeoExtentionData* data = new VirtualMine::SpatialInterface::CGeoExtentionData();
			Ogre::ManualObject* renderObject = this->ref_mpSceneMgr->createManualObject(coalProperty->getName());
		
		
			Ogre::Any any((VirtualMine::Core::CBaseObject*)coalObject);
			renderObject->setUserAny(any);
		
			data->setExtentionData(renderObject);
		
			geoExtentionDatas.push_back(data);
				
			//int row = coalGeometry->getRow();
			//int column = coalGeometry->getCol();
		
			//Ogre::MaterialPtr material = Ogre::MaterialManager::getSingletonPtr()->create(coalProperty->getName(),VirtualMine::Core::VR_MINE_DEFAULT_RESOURCE_GROUP);
		
			//if (!material.isNull())
			//{
			//	Ogre::Pass* pass = material->getTechnique(0)->getPass(0);		
			//	pass->setCullingMode(Ogre::CULL_NONE);
			//	pass->createTextureUnitState(coalStyle->getTexture());
		
			//	/*Ogre::Pass* pass2 = material->getTechnique(0)->createPass();
			//	pass2->setSceneBlending(Ogre::SBT_TRANSPARENT_ALPHA);
			//	pass2->setCullingMode(Ogre::CULL_NONE);
			//	Ogre::TextureUnitState* unitestate = new Ogre::TextureUnitState(pass2);
			//	pass2->addTextureUnitState(unitestate);*/
			//	material->load();
			//}
		
			if (coalGeometry!= NULL && coalProperty!=NULL && coalStyle !=NULL)
			{
				//renderObject->begin(coalProperty->getName(), Ogre::RenderOperation::OT_TRIANGLE_LIST,VirtualMine::Core::VR_MINE_DEFAULT_RESOURCE_GROUP);
		
				renderObject->begin("coalMaterial", Ogre::RenderOperation::OT_TRIANGLE_LIST,VirtualMine::Core::VR_MINE_DEFAULT_RESOURCE_GROUP);
		
				VirtualMine::Geometry::CPoint upLeftPt;
				VirtualMine::Geometry::CPoint downRightPt;
				coalGeometry->computeRectangle(upLeftPt,downRightPt);
				float width = downRightPt.getX() - upLeftPt.getX();
				float height = downRightPt.getZ() - upLeftPt.getZ();
		
				std::vector<De_point> depointVector;
					
				std::vector<De_point> transferVector;
				std::vector<De_point> renderVertor;
		
				int count = coalGeometry->getCount();
				for (int i = 0; i < count; i++)
				{
					VirtualMine::Geometry::CPoint point =	coalGeometry->getPoint(i);
		
					De_point dePoint;
					dePoint.X = point.getX();
					dePoint.Y = point.getY();
					dePoint.Z = point.getZ() * (-1); ////ogre的Z轴指向屏幕外
					depointVector.push_back(dePoint);
				}
		
				//
				//for (int i = 0; i < count; i++)
				//{
				//	VirtualMine::Geometry::CPoint point =coalGeometry->getPoint(i);
				//	De_point dePoint;
				//	dePoint.X = point.getX();
				//	dePoint.Y = point.getY();
				//	dePoint.Z = point.getZ();
				//	depointVector.push_back(dePoint);
		
		
				//	//获取边界点
				//	std::vector<Ogre::Vector3> tempVec;
				//	Ogre::Vector3 tempVec3;
				//	tempVec3.x = point.getX();
				//	tempVec3.y = point.getY();
				//	tempVec3.z = point.getZ();
		
				//	tempVec.push_back(tempVec3);
		
				//	for (i = 0 ;i < borderNodesCount; i++)
				//	{
				//		boderNodes.push_back(tempVec[i]);  //up
				//		boderNodes.push_back(tempVec[(i+1)*borderNodesCount-1]);  //right
				//		boderNodes.push_back(tempVec[i*borderNodesCount]);  //left
				//		boderNodes.push_back(tempVec[borderNodesCount*(borderNodesCount-1)+i]);  //down
		
		
				//	}
		
				//}
		
				//if (orderTerrane > 0)		
				//{
				//	Ogre::ManualObject* siderRenderObject = this->ref_mpSceneMgr->createManualObject(coalProperty->getName());
				//	siderRenderObject->begin(coalProperty->getName()+"_Material",Ogre::RenderOperation::OT_TRIANGLE_LIST,VirtualMine::Core::VR_MINE_DEFAULT_RESOURCE_GROUP);
		
				//	//构建顶点和索引
				//	int tempTerraneCount = boderNodes.size()/coalCount; //每层边界点的个数
				//	for (int i = 0; i < boderNodes.size();i++)
				//	{
				//		Ogre::Vector3 tempVec3 = boderNodes[i+tempTerraneCount*(orderTerrane-1)];
				//		siderRenderObject->position(tempVec3);
				//		siderRenderObject->textureCoord(0,i*(1.0/(tempTerraneCount-1)));
		
				//	}
				//	for (int j = 1;j < coalCount+1; j++)
				//	{
				//		for (int i = 0;i<tempTerraneCount;i++)
				//		{
				//			siderRenderObject->triangle(i,i+1,tempTerraneCount*j+1+i);
				//			siderRenderObject->triangle(i+1,tempTerraneCount*j+1+i,tempTerraneCount*j+2+i);
				//		}
				//	}
		
				//	siderRenderObject->end();
		
		
				//}
				//
		

#if 1  Delaunay

				Tri_Delaunay Tr;
				std::map<point_2D,double> mapPoint;

				point_2D p2;
				point_2D p2_2;


				for (int i=0;i<depointVector.size();++i)
				{
					p2.X = depointVector.at(i).X;
					p2.Y = depointVector.at(i).Y;

					mapPoint.insert(std::map<point_2D,double>::value_type(p2,depointVector.at(i).Z));							
				}

				renderVertor = Tr.Triangle_Delaunay(depointVector);

				for (int i = 0; i < renderVertor.size(); ++i)
				{
					double val;
					De_point map_p;
					p2_2.X = renderVertor.at(i).X;
					p2_2.Y = renderVertor.at(i).Y;
					std::map<point_2D,double>::iterator ite;
					ite=mapPoint.find(p2_2);
					if (ite!=mapPoint.end())
					{
						val = ite->second;
					}

					map_p.X = p2_2.X;
					map_p.Y = p2_2.Y;
					map_p.Z = val;
					transferVector.push_back(map_p);
				}

				for (int i = 0; i < transferVector.size(); ++i)
				{
					//manual_D->position(V2.at(i).x,V2.at(i).y, V2.at(i).z);
					renderObject->position(transferVector.at(i).X,transferVector.at(i).Y,transferVector.at(i).Z);

					renderObject->textureCoord((transferVector.at(i).X-upLeftPt.getX())/width,(transferVector.at(i).Z-upLeftPt.getZ())/height);
				}

				for (int i=0;i<transferVector.size();i+=3)
				{
					renderObject->index(i);
					renderObject->index(i+1);
					renderObject->index(i+2);
				}
#endif
					
#if 0
				int row(100),column(100); 
				for (int i = 0;i<row;i++)
				{
					for (int j = 0;j<column;j++)
					{
						int posindex = i * column + j ;
						VirtualMine::Geometry::CPoint point = coalGeometry->getPoint(posindex);
						Ogre::Vector3 realPoint = Ogre::Vector3(point.getX(),point.getY(),point.getZ()* VirtualMine::SpatialInterface::IScene::CoefficientOfCoordinateTransform);
						renderObject->position(realPoint);
						//renderObject->textureCoord((float)i/(float)row,(float)j/(float)column);
						renderObject->textureCoord((point.getX()-upLeftPt.getX())/width,(point.getZ()-upLeftPt.getZ())/height);
					}			
				}
		
				for (int i = 0;i<row-1;i++)
				{
					for (int j = 0;j<column-1;j++)
					{
						renderObject->triangle((i*column)+j,(i*column)+j+1,(i+1)*column+j);
						renderObject->triangle((i+1)*column+j,i*column+j+1,(i+1)*column+j+1);
					}
				}
		
		
#endif
						
				renderObject->end();
			}
					
			}				
		}
			


	}
}