//
//

//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : 三维数字矿山平台
//  @ File Name : igeomeshcreator.cpp
//  @ Date : 2021/11/29
//  @ Author : 李佳康
//  @ Implement : 
//  @ Company : 中国矿业大学(北京)
//  @ Copyright:  2014-2020
//  @ Description : 


#include "vrmine/vr_arithmetic/arithmetic/lanewayprogress_meshcreator.h"
#include "vrmine/vr_core/geodatatype.h"
#include "vrmine/vr_spatialobject/mine/lanwayobjectpro.h"
#include <string>
//kk
#include "vrmine/vr_spatialrender/baserender/moveabletext.h"





using namespace VirtualMine::Geometry;
using namespace VirtualMine::Style;
using namespace VirtualMine::MathEngine;
using namespace VirtualMine::SpatialInterface;
using namespace VirtualMine::Mine;


namespace VirtualMine
{
	namespace Arithmetic
	{
		CLanewayProgress_MeshCreator::CLanewayProgress_MeshCreator()
		{
			/*std::string type = "ArcLaneway";
			this->setType(type);*/
			this->setType(VirtualMine::Core::GeoDataType::GDT_LANWAYPRO);
			this->mpStyle = new CLanewayStyle(); 
		}

		CLanewayProgress_MeshCreator::~CLanewayProgress_MeshCreator()
		{

		}

		void CLanewayProgress_MeshCreator::createData(VirtualMine::SpatialInterface::GeoObjectVector& geoObjectVector,std::vector<VirtualMine::SpatialInterface::CGeoExtentionData*>& geoExtentionDatas,std::vector<Ogre::SceneNode*> &mTextNodes)
		{
			this->ref_mGeoExtantionDataVector = &geoExtentionDatas;
			//kk
			this->mBuildTextNodes =&mTextNodes;

			this->ref_mGeoObjectVector = geoObjectVector;
			CGeoObject* firstObject = dynamic_cast<CGeoObject*>(this->ref_mGeoObjectVector[0]);
			this->mpStyle = dynamic_cast<VirtualMine::Style::CLanewayStyle*>(firstObject->getStyle());

			if (this->mLanewayCrossNodes.size()>0)
			{
				this->mLanewayCrossNodes.clear();
			}

			if (this->mLanewayLines.size()>0)
			{
				this->mLanewayLines.clear();
			}


			this->createLanewayLineCollection();   //从原始数据提取巷道线路，六条巷道线路

			this->createIntersectionCollection();  //检索巷道数据，构建巷道交叉节点，获取到点位的

			this->buildLinePart();                 //构建直线和拐点部分

			this->buildIntersectionPart();         //构建交叉的截面部分

		}

		void CLanewayProgress_MeshCreator::createLanewayLineCollection()
		{	
			for (VirtualMine::SpatialInterface::GeoObjectVector::iterator ite = this->ref_mGeoObjectVector.begin();ite!=this->ref_mGeoObjectVector.end();ite++)
			{
				IGeoObject* geoObject = (*ite);
				CLanewayStyle* tempstyle = dynamic_cast<VirtualMine::Style::CLanewayStyle*>(geoObject->getStyle());
				IGeometry* temp = geoObject->getGeometry();
				CLaneWayLineGeometry* line = dynamic_cast<CLaneWayLineGeometry*>(geoObject->getGeometry());
				this->mLanewayLines.push_back(line);
			}
		}

		bool CLanewayProgress_MeshCreator::hasCrossNode(const Ogre::String& name)
		{
			for (std::vector<CLaneWayCrossNodeGeometry*>::iterator ite = this->mLanewayCrossNodes.begin();ite!=this->mLanewayCrossNodes.end();ite++)
			{
				CLaneWayCrossNodeGeometry* crossNode = (*ite);
				if (crossNode->getCrossNode()->getName() == name)
				{
					return true;
				}
			}
			return false;
		}

		VirtualMine::Geometry::CLaneWayLineGeometry* CLanewayProgress_MeshCreator::getLanewayLine(const Ogre::String& lineName)
		{
			
			for (std::vector<CLaneWayLineGeometry*>::iterator ite = this->mLanewayLines.begin();ite!=this->mLanewayLines.end();ite++)
			{
				CLaneWayLineGeometry* line = (*ite);
				if (line->getName() == lineName)
				{
					return line;
				}
			}
			return NULL;
		}
		
		void CLanewayProgress_MeshCreator::createIntersectionCollection()
		{
			for (std::vector<CLaneWayLineGeometry*>::iterator ite = this->mLanewayLines.begin();ite!=this->mLanewayLines.end();ite++)
			{
				CLaneWayLineGeometry* line = (*ite);
				std::vector<CLaneWayNodeGeometry*> nodes = line->getNodes();
				for (std::vector<CLaneWayNodeGeometry*>::iterator iteNode = nodes.begin();iteNode!=nodes.end();iteNode++)
				{
					CLaneWayNodeGeometry* node = (*iteNode);
					if (node->getIsIntersection())
					{
						if (!this->hasCrossNode(node->getName()))
						{
							CLaneWayCrossNodeGeometry* crossNode = new CLaneWayCrossNodeGeometry();
							crossNode->setCrossNode(node);
							//kk这里把StringVector换成了std::vector<Ogre::String>，避免造成类型不明确（Ogre中也有自带的StringVector）
							std::vector<Ogre::String> lineNames = node->getBelongLanewayLine();
							for (std::vector<Ogre::String>::iterator iteline =lineNames.begin();iteline!=lineNames.end();iteline++ )
							{
								Ogre::String lineName = (*iteline);
								CLaneWayLineGeometry* lineGeometry =  this->getLanewayLine(lineName);
								if (lineGeometry == NULL)
								{
									break;
								}

								CLaneWayNodeGeometry* tempNode = lineGeometry->getNode(node->getName());
							
								if (tempNode == NULL)
								{
									break;
								}
								if (tempNode->getPreNode()!=NULL)
								{
									crossNode->addAdjacentNode(tempNode->getPreNode());
								}
								if (tempNode->getNextNode()!=NULL)
								{
									crossNode->addAdjacentNode(tempNode->getNextNode());
								}
							}
							crossNode->clockwiseSortPoints();
							this->mLanewayCrossNodes.push_back(crossNode);							
						}						
					}
				}
			}
		}

		VirtualMine::Geometry::CLaneWaySection* CLanewayProgress_MeshCreator::createSection(VirtualMine::Style::CLanewayStyle* lanewayStyle)
		{
				CLaneWaySection* section = new CLaneWaySection();
				int count=(int)(180.0f/10.0f);
				int countCircle=(int)(360.0/17.14f);
				LanewaySectionType sectionType = lanewayStyle->getSectionType();

				if (sectionType == LanewaySectionType::Arch)
				{
					Ogre::Real width = lanewayStyle->getWidth();
					Ogre::Real height = lanewayStyle->getHeight();
					Ogre::Vector3* points=new Ogre::Vector3[count+4];
					points[0].x=width; 
					points[0].y=height;
					points[0].z=0;

					points[1].x=width;
					points[1].y=0;
					points[1].z=0;

					points[2].x=-width;
					points[2].y=0;
					points[2].z=0;

					points[3].x=-width;
					points[3].y=height;
					points[3].z=0;

					Ogre::Vector3 forward = Ogre::Vector3::UNIT_Z;

					for(int i=0;i<count;i++)
					{
						Ogre::Quaternion q;
						q.FromAngleAxis(Ogre::Radian(-10.0f*(i+1)*Ogre::Math::PI/180),forward);
						points[4+i] = q * points[2];
						points[4+i].y+=height;
					}
					section->setPoints(points,count+4);
				}
				else if (sectionType == LanewaySectionType::Trapezoid)
				{
					Ogre::Real width = lanewayStyle->getWidth();
					Ogre::Real height = lanewayStyle->getHeight();
					Ogre::Vector3* points=new Ogre::Vector3[count+4];
					points[0].x=width*0.505f;
					points[0].y=height;
					points[0].z=0;

					points[1].x=width;
					points[1].y=0;
					points[1].z=0;

					points[2].x=-width;
					points[2].y=0;
					points[2].z=0;

					points[3].x=-width*0.505f;
					points[3].y=height;
					points[3].z=0;

					Ogre::Vector3 forward = Ogre::Vector3::UNIT_Z;

					Ogre::Vector3 tempPt;
					tempPt = points[2];
					tempPt.x = points[3].x;
					for(int i=0;i<count;i++)
					{
						Ogre::Quaternion q;
						q.FromAngleAxis(Ogre::Radian(-10.0f*(i+1)*Ogre::Math::PI/180),forward);
						points[4+i] = q * tempPt;
						points[4+i].y=height;
					}
					section->setPoints(points,count+4);
				}
				else if (sectionType == LanewaySectionType::Circle)
				{
					Ogre::Real width = lanewayStyle->getWidth();
					Ogre::Real height = lanewayStyle->getHeight();
					Ogre::Vector3* points=new Ogre::Vector3[countCircle+1];
					points[0].x=-width; 
					points[0].y=0;
					points[0].z=0;


					Ogre::Vector3 forward = Ogre::Vector3::UNIT_Z;

					for(int i=0;i<countCircle;i++)
					{
						Ogre::Quaternion q;
						q.FromAngleAxis(Ogre::Radian(-17.14f*(i+1)*Ogre::Math::PI/180),forward);
						points[1+i] = q * points[0];
						//points[1+i].y+=0;
					}
					section->setPoints(points,countCircle+1);
				}
				return section;
		}

		Ogre::Vector3 CLanewayProgress_MeshCreator::getCrossOffsetPos(CLaneWayNodeGeometry* sourcePos,CLaneWayCrossNodeGeometry* crossNode,CLanewayStyle* lanewayStyle)
		{
			Ogre::Vector3 result;
			float width = lanewayStyle->getWidth();

			Ogre::Vector3 dir = sourcePos->getPosition() - crossNode->getCrossNode()->getPosition();
			float dirAngle = CMathCalculator::CalculateAngleOfPlane(dir);

			Ogre::Vector3 start=sourcePos->getPosition(); 
			start.y=0;
			Ogre::Vector3 center=crossNode->getCrossNode()->getPosition();
			center.y=0;
			Ogre::Vector3 offsetDirection = start - center;
			offsetDirection.normalise();

			Ogre::Vector3 realDir = sourcePos->getPosition() - crossNode->getCrossNode()->getPosition();
			realDir.normalise();

			float maxLength=0;
			for (int i = 0;i<crossNode->getAdjancentNodesCount();i++)
			{
				CLaneWayNodeGeometry* node = crossNode->getAdjancentNode(i);
				if (node->getPosition() != sourcePos->getPosition())
				{
					Ogre::Vector3 newStart=node->getPosition();
					newStart.y=0;		
					Ogre::Vector3 newDirection = newStart-center;
					newDirection.normalise();

					float edge;
					float angle = CMathCalculator::CalculateAngleOfTwoVector(offsetDirection,newDirection);
					float angleAbs = Ogre::Math::Abs(angle);
					if(angleAbs<0.0001)
						edge=0;
					else
					{
						edge = (width) / Ogre::Math::Tan(angleAbs/2.0f);
						edge = edge/Ogre::Math::Abs(Ogre::Math::Cos(dirAngle));
					}	   
					if(edge>maxLength)
					{
						maxLength=edge;
						result=crossNode->getCrossNode()->getPosition() + edge*realDir;
					}	  
				} 
			}
			return result;
		}
		//构建直线和拐点部分
		void CLanewayProgress_MeshCreator::buildLinePart()
		{
			#pragma region 创建截面
			//for (std::vector<CLaneWayLineGeometry*>::iterator iteLine = this->mLanewayLines.begin(); iteLine!=this->mLanewayLines.end();iteLine++ )
			for(size_t i = 0;i<this->mLanewayLines.size();++i)
			{
				//CLaneWayLineGeometry* line = (*iteLine);
				CLaneWayLineGeometry* line = this->mLanewayLines[i];
				
				this->mpStyle = dynamic_cast<VirtualMine::Style::CLanewayStyle*>(this->ref_mGeoObjectVector[i]->getStyle());

				if (line->getNodesCount() < 2)	
					break;

				for (int i = 0;i<line->getNodesCount();i++)
				{
					CLaneWayNodeGeometry* node = line->getNode(i);

					if (node == NULL)
					{
						break;
					}
					#pragma region 直线巷道
					if (node->getNextNode() != NULL)
					{
						//计算截面偏角
						Ogre::Vector3 direction = node->getNextNode()->getPosition() - node->getPosition();
						direction.y = 0;
						direction.normalise();
						float azimuthAngle = VirtualMine::MathEngine::CMathCalculator::CalculateAzimuth(direction);

						//计算第一个截面
						CLaneWaySection* sectionOne = this->createSection(this->mpStyle);
						sectionOne->Rotate(Ogre::Radian(azimuthAngle));

						if (node->getIsIntersection())
						{
							CLaneWayCrossNodeGeometry* crossNodeOne = NULL;
							for (std::vector<CLaneWayCrossNodeGeometry*>::iterator iteCross = this->mLanewayCrossNodes.begin(); iteCross!=this->mLanewayCrossNodes.end();iteCross++)
							{
								CLaneWayCrossNodeGeometry* crossNode = (*iteCross);
								if (crossNode == NULL || crossNode->getCrossNode() == NULL)
								{
									break;
								}
								if (crossNode->getCrossNode()->getPosition() == node->getPosition())
								{
									crossNodeOne = crossNode;
									break;
								}
							}
							if (crossNodeOne == NULL)
							{
								break;
							}
							Ogre::Vector3 startPos = this->getCrossOffsetPos(node->getNextNode(),crossNodeOne,this->mpStyle);
							sectionOne->setPosition(startPos);
						}
						else
						{
							if (node->getPreNode() == NULL)
							{
								sectionOne->setPosition(node->getPosition());
							}
							else
							{						
								Ogre::Vector3 firstVector = node->getPreNode()->getPosition() - node->getPosition();
								
								firstVector.y = 0;
								firstVector.normalise();

								Ogre::Vector3 dir = node->getNextNode()->getPosition() - node->getPosition();
								float dirAngle = VirtualMine::MathEngine::CMathCalculator::CalculateAngleOfPlane(dir);
								Ogre::Vector3 secondVector = dir;
								secondVector.y = 0;
								secondVector.normalise();

								float angle = VirtualMine::MathEngine::CMathCalculator::CalculateAngleOfTwoVector(firstVector,secondVector);
								angle = Ogre::Math::Abs(angle);
								float startOffset = this->mpStyle->getSmoothFactor() * this->mpStyle->getWidth() / Ogre::Math::Tan(angle/2.0f);
								startOffset = startOffset/Ogre::Math::Abs(Ogre::Math::Cos(dirAngle));
								Ogre::Vector3 startPos = node->getPosition() + startOffset*secondVector;
								sectionOne->setPosition(startPos);
							}
						}


						////计算第二个截面
						CLaneWaySection* sectionTwo = this->createSection(this->mpStyle);
						sectionTwo->Rotate(Ogre::Radian(azimuthAngle));

						if (node->getNextNode()->getIsIntersection())
						{
							CLaneWayCrossNodeGeometry* crossNodeTwo = NULL;
							for (std::vector<CLaneWayCrossNodeGeometry*>::iterator iteCross = this->mLanewayCrossNodes.begin(); iteCross!=this->mLanewayCrossNodes.end();iteCross++)
							{
								CLaneWayCrossNodeGeometry* crossNode = (*iteCross);
								
								if (crossNode == NULL || crossNode->getCrossNode() == NULL)
								{
									break;
								}
								if (crossNode->getCrossNode()->getPosition() == node->getNextNode()->getPosition())
								{
									crossNodeTwo = crossNode;
									break;
								}							
							}
							if (crossNodeTwo == NULL)
							{
								break;
							}
						
							Ogre::Vector3 endtPos = this->getCrossOffsetPos(node,crossNodeTwo,this->mpStyle);
							sectionTwo->setPosition(endtPos);
						}
						else
						{
							if (node->getNextNode()->getNextNode() == NULL)
							{
								sectionTwo->setPosition(node->getNextNode()->getPosition());
							}
							else
							{
								Ogre::Vector3 dir2 = node->getPosition() - node->getNextNode()->getPosition();
								float dir2Angle = VirtualMine::MathEngine::CMathCalculator::CalculateAngleOfPlane(dir2);
								Ogre::Vector3 firstVector2 = dir2;
								firstVector2.y = 0;
								firstVector2.normalise();

								Ogre::Vector3 secondVector2 = node->getNextNode()->getNextNode()->getPosition() - node->getNextNode()->getPosition();
								secondVector2.y = 0;
								secondVector2.normalise();

								float angle2 = VirtualMine::MathEngine::CMathCalculator::CalculateAngleOfTwoVector(firstVector2,secondVector2);
								angle2 = Ogre::Math::Abs(angle2);
								float endOffset = this->mpStyle->getSmoothFactor() * this->mpStyle->getWidth()/ Ogre::Math::Tan(angle2/2.0f);
								endOffset = endOffset/Ogre::Math::Abs(Ogre::Math::Cos(dir2Angle));
			
								Ogre::Vector3 endPos = node->getNextNode()->getPosition() + endOffset*firstVector2;

								sectionTwo->setPosition(endPos);
							}
						}
						line->addSection(sectionOne);
						line->addSection(sectionTwo);
					}
					#pragma endregion 
					//kk原始代码
					#pragma region 拐点平滑
					if (node->getPreNode()!=NULL && node->getNextNode()!=NULL && !node->getIsIntersection())
					{
						std::vector<CLaneWaySection*> nodeSections;
						Ogre::Vector3 dirOrigin = node->getPreNode()->getPosition() - node->getPosition();
						float dirOriginAngle = VirtualMine::MathEngine::CMathCalculator::CalculateAngleOfPlane(dirOrigin);
						Ogre::Vector3 originDir = dirOrigin;			
						originDir.y = 0;
						originDir.normalise();
						Ogre::Vector3 dirEnd =  node->getNextNode()->getPosition() - node->getPosition();
						float dirEndAngle = VirtualMine::MathEngine::CMathCalculator::CalculateAngleOfPlane(dirEnd);
						Ogre::Vector3 endDir = dirEnd;
						endDir.y = 0;
						endDir.normalise();
						float angle = VirtualMine::MathEngine::CMathCalculator::CalculateAngleOfTwoVector(originDir,endDir);

						Ogre::Vector3 rotateAxis = originDir.crossProduct(endDir);
						rotateAxis.y = Ogre::Math::Abs(rotateAxis.y );
						rotateAxis.normalise();
						float angleAbs = Ogre::Math::Abs(angle);
						
						Ogre::Quaternion q;
						q.FromAngleAxis(Ogre::Radian(angle/2.0f),Ogre::Vector3::UNIT_Y);
						//q.FromAngleAxis(Ogre::Radian(angle/2.0f),rotateAxis);
						Ogre::Vector3 circlePt = node->getPosition() + (q * originDir)* (this->mpStyle->getSmoothFactor()*this->mpStyle->getWidth()/Ogre::Math::Sin(angleAbs/2.0f));

						float azimuthAngle1 =  VirtualMine::MathEngine::CMathCalculator::CalculateAzimuth(originDir*(-1.0f));
						CLaneWaySection* sectionStart = this->createSection(this->mpStyle);
						sectionStart->Rotate(Ogre::Radian(azimuthAngle1));
						float startOffset = this->mpStyle->getSmoothFactor()*this->mpStyle->getWidth() / Ogre::Math::Tan(angleAbs/2.0f);
						startOffset = startOffset/Ogre::Math::Abs(Ogre::Math::Cos(dirOriginAngle));
						Ogre::Vector3 startPos = node->getPosition() + startOffset*(originDir);
						sectionStart->setPosition(startPos);
						nodeSections.push_back(sectionStart);

						Ogre::Vector3 radius = startPos - circlePt;
						radius.normalise();

						if (angleAbs < Ogre::Math::PI * 0.9)
						{
							for (int i = 1;i<5;i++)
							{
								CLaneWaySection* section = this->createSection(this->mpStyle);
								section->Rotate(Ogre::Radian(azimuthAngle1-(angle/angleAbs)*i*(Ogre::Math::PI-angleAbs)/5));

								Ogre::Quaternion q;
								//q.FromAngleAxis(Ogre::Radian(-(angle/angleAbs)*i*(Ogre::Math::PI-angleAbs)/5),Ogre::Vector3::UNIT_Y);
								q.FromAngleAxis(Ogre::Radian(-(angle/angleAbs)*i*(Ogre::Math::PI-angleAbs)/5),rotateAxis);
								Ogre::Vector3 pos =  q*radius *this->mpStyle->getSmoothFactor()*this->mpStyle->getWidth() + circlePt ;
								section->setPosition(pos);
								nodeSections.push_back(section);
							}
						}

						float azimuthAngle2 = VirtualMine::MathEngine::CMathCalculator::CalculateAzimuth(endDir);
						CLaneWaySection* sectionEnd = this->createSection(this->mpStyle);
						sectionEnd->Rotate(Ogre::Radian(azimuthAngle2));
						float endOffset = this->mpStyle->getSmoothFactor()*this->mpStyle->getWidth() / Ogre::Math::Tan(angleAbs/2.0f);
						endOffset = endOffset/Ogre::Math::Abs(Ogre::Math::Cos(dirEndAngle));
						Ogre::Vector3 endPos = node->getPosition() + endOffset*endDir;
						sectionEnd->setPosition(endPos);
						nodeSections.push_back(sectionEnd);			

						line->addFlexSections(nodeSections);
					}
					#pragma endregion 
				}	
			}

			#pragma endregion 

#pragma region 构建顶点和索引集合


	
			for(size_t i = 0;i<1;++i)
			{
				//CLaneWayLineGeometry* line = (*iteLine);

				CLaneWayLineGeometry* line = this->mLanewayLines[i];

				//kk中间渲染的manuobject
				int start =5;
				int end =10;
				int start2 =11;
				int end2 =15;
				int start3 =16;
				int end3 =21;
				this->buildProgressPart(line,0,start,"ljkname",LanewaySuppoetType::Unknown,*line->getSection(0)->getPoints(),Ogre::String("第一天"));
				this->buildProgressPart(line,start-1,end,"ljkname1",LanewaySuppoetType::ProgressFir,*line->getSection(start)->getPoints(),Ogre::String("第二天"));
				this->buildProgressPart(line,start2-1,end2,"ljkname2",LanewaySuppoetType::ProgressSec,*line->getSection(start2)->getPoints(),Ogre::String("第三天"));
				this->buildProgressPart(line,start3-1,end3,"ljkname3",LanewaySuppoetType::ProgressFir,*line->getSection(start3)->getPoints(),Ogre::String("第四天"));
				this->buildProgressPart(line,end3-1,line->getSectionCount(),"ljkname4",LanewaySuppoetType::Unknown,*line->getSection(end3)->getPoints(),Ogre::String("第五天"));

	#pragma region 原始的渲染代码

//				CLaneWayObjectPro* lanewayObjectPro = dynamic_cast<CLaneWayObjectPro*>(this->ref_mGeoObjectVector[i]);
//				//kk第三个CLaneWayObjectPro
//				CLaneWayObjectPro* lanewayObjectPro3 = new CLaneWayObjectPro();
//
//
//				//kk在这句获取样式
//				VirtualMine::Style::CLanewayStyle* tempStyle = dynamic_cast<VirtualMine::Style::CLanewayStyle*>(this->ref_mGeoObjectVector[i]->getStyle());
//				////kk第二个style
//				//VirtualMine::Style::CLanewayStyle* tempStyle2 =  new VirtualMine::Style::CLanewayStyle();
//				//tempStyle2->setSupportType(LanewaySuppoetType::Progress);
//
//				CGeoExtentionData* geoExtentionData = new CGeoExtentionData(this->ref_mpSceneMgr);
//				//kk 第二个geoExtentionData
//				/*CGeoExtentionData* geoExtentionData2 = new CGeoExtentionData(this->ref_mpSceneMgr);*/
//				//kk 第三个geoExtentionData
//				CGeoExtentionData* geoExtentionData3 = new CGeoExtentionData(this->ref_mpSceneMgr);
//
//
//
//
//
//
//				//added by sjl->2015-7-24
//				//kk第一个geoExtentionData
//				geoExtentionData->setOwnerObject(lanewayObjectPro); 
//				//kk第三个geoExtentionData
//				geoExtentionData3->setOwnerObject(lanewayObjectPro3); 
//
//				//kk不能重复manualobject名字,在这里要加个数字
//
//				char t[256];
//				std::string s;
//
//				sprintf(t, "%d", this->mauobjectnum);
//				s = t;
//				//kk第一个ManualObject
//				Ogre::ManualObject* renderObject = this->ref_mpSceneMgr->createManualObject(line->getName() + "_linepro" +s);
//				//kk第二个ManualObject
//				/*Ogre::ManualObject* renderObject2 = this->ref_mpSceneMgr->createManualObject(line->getName() + "_linepro2" +s);*/
//				//kk第二个ManualObject
//				Ogre::ManualObject* renderObject3 = this->ref_mpSceneMgr->createManualObject(line->getName() + "_linepro3" +s);
//				//kk
//				this->mauobjectnum++;
//				Ogre::Any any((VirtualMine::Core::CBaseObject*)(lanewayObjectPro));
//
//				Ogre::MaterialPtr mat = Ogre::MaterialManager::getSingletonPtr()->getByName(tempStyle->getSupportImg(),VirtualMine::Core::VR_MINE_DEFAULT_RESOURCE_GROUP);
//				//kk第二个
//				/*Ogre::MaterialPtr mat2 = Ogre::MaterialManager::getSingletonPtr()->getByName(tempStyle2->getSupportImg(),VirtualMine::Core::VR_MINE_DEFAULT_RESOURCE_GROUP);*/
//
//
//#pragma region 注释
//				//int nodesCount = line->getNodesCount();
//				//for (int i = 0 ; i< nodesCount; ++i)
//				//{
//				//	CLaneWayNodeGeometry* tempNode = line->getNode(i);
//				//	if (tempNode->getPosition().y >= -50 && tempNode->getPosition().y <= 50)
//				//	{
//				//		if (i == nodesCount - 1)
//				//		{
//				//			if (!mat.isNull())
//				//			{
//				//				std::string name = tempStyle->getSupportImg();
//				//				Ogre::GpuProgramParametersSharedPtr gpSp = mat->getTechnique(0)->getPass(0)->getFragmentProgramParameters();
//				//				/*gpSp->setNamedConstant("addMode",1);
//				//				gpSp->setNamedConstant("addColor", Ogre::ColourValue(0.0,0.0,0.0,1.0));*/
//				//			}
//				//		}
//				//	}
//				//	else
//				//	{
//				//		break;
//				//	}
//				//}
//#pragma endregion
//				renderObject->setUserAny(any);
//				/*renderObject2->setUserAny(any);*/
//				renderObject3->setUserAny(any);
//
//				
//
//
//#pragma region 定义三维字显示
//				////kk定义一个geoExtentionData用于存放三维字
//				//CGeoExtentionData* geoExtentionDataText = new CGeoExtentionData(this->ref_mpSceneMgr);
//				//////设置CGeoExtentionData为字体类型
//				//geoExtentionDataText->setIsTextObject(true);
//
//				//Ogre::String lanewayName = "李佳康";											
//			
//				//int iWLen = MultiByteToWideChar( CP_ACP, 0, lanewayName.c_str(), lanewayName.size(), 0, 0 ); // 计算转换后宽字符串的长度。（不包含字符串结束符）  
//				//wchar_t *lpwsz = new wchar_t [iWLen + 1];  //wchar_t是C++的宽字符类型
//				//MultiByteToWideChar( CP_ACP, 0, lanewayName.c_str(), lanewayName.size(), lpwsz, iWLen ); // 正式转换。  
//				//lpwsz[iWLen] = L'\0';//将末尾转换为Unicode
//				//Ogre::DisplayString disName(lpwsz);
//
//				//////////////////////////////////////////////////////////////////////////////
//				//VirtualMine::BaseRender::MovableText* pText = new VirtualMine::BaseRender::MovableText(lanewayName,
//				//	Ogre::DisplayString(disName),Ogre::String("SimHei"),10,Ogre::ColourValue(1,0.843,0,1));//ColourValue::Green  
//				//pText->showOnTop(true);
//				//pText->setTextAlignment(VirtualMine::BaseRender::MovableText::H_CENTER,VirtualMine::BaseRender::MovableText::V_ABOVE);//MovableText:: V_CENTER
//				//Ogre::Vector3 *centerPoint  = new Ogre::Vector3();//Ogre::Vector3(3226.4448,-534.45,404.23);
//				//centerPoint->x = 3226.4448;
//				//centerPoint->y = -534.45;
//				//centerPoint->z = 404.23;
//				//Ogre::SceneNode* node = this->ref_mpSceneMgr->getRootSceneNode()->createChildSceneNode(*centerPoint);
//				////node->attachObject(pText);
//				//
//
//
//				//////转换为ManualObject
//				//Ogre::ManualObject* renderObjectText =dynamic_cast<Ogre::ManualObject*>(pText);
//
//				//geoExtentionDataText->setExtentionData(renderObjectText);
//
//				////geoExtentionDataText->setTextPosition(Ogre::Vector3(3226,-534,404));
//
//#pragma endregion
//
//#pragma region 开始创建 ManualObject
//				renderObject->begin(mat->getName(), Ogre::RenderOperation::OT_TRIANGLE_LIST,VirtualMine::Core::VR_MINE_DEFAULT_RESOURCE_GROUP);
//
//				for (int indexSec = 0;indexSec<start;indexSec++)
//				{
//
//
// 					CLaneWaySection* section = line->getSection(indexSec);	
//
//					float distance = 0.0f;
//					if (indexSec % 2 != 0)
//					{
//						CLaneWaySection* preSection = line->getSection(indexSec-1);
//						distance = (preSection->getPoints()[0]-section->getPoints()[0]).length();
//					}
//
//					for (int i = 0;i<section->getPointsCount();i++)
//					{
//						//设置位置
//						renderObject->position(section->getPoints()[i]);
//						if (indexSec % 2 == 0)
//						{
//							if (i == 0)
//							{
//								renderObject->textureCoord(0,0);
//							}
//							if (i == 1)
//							{
//								renderObject->textureCoord(0,0.25);
//							}
//							if (i == 2)
//							{
//								renderObject->textureCoord(0,0.5);
//							}
//							if (i == 3)
//							{
//								renderObject->textureCoord(0,0.75);
//							}
//							if (i>3)
//							{
//								renderObject->textureCoord(0,0.75 + (i-3)*0.25/18);
//							}
//						}
//						else
//						{
//							if (i == 0)
//							{
//								renderObject->textureCoord(distance/3,0);
//							}
//							if (i == 1)
//							{
//								renderObject->textureCoord(distance/3,0.25);
//							}
//							if (i == 2)
//							{
//								renderObject->textureCoord(distance/3,0.5);
//							}
//							if (i == 3)
//							{
//								renderObject->textureCoord(distance/3,0.75);
//							}
//							if (i>3)
//							{
//								renderObject->textureCoord(distance/3,0.75 + (i-3)*0.25/18);
//							}
//						}
//
//					}	
//				}
//				//i<line->getSectionCount()
//				for (int i = 0;i<start;i++)
//				{
//					if (i%2 == 0)  continue;
//
//					for (int j = 1;j<line->getSection(0)->getPointsCount();j++)
//					{
//						renderObject->triangle((i-1)*22 +j-1, i*22+j-1, i*22+j);
//						renderObject->triangle(i*22+j, (i-1)*22+j, (i-1)*22+j-1);
//					}
//				}
//				renderObject->end();		
//#pragma endregion
//
//#pragma region 创建ManualObject巷道拐角处				
//				for (int indexSec = 0;indexSec<start;indexSec++)
//				{
//					std::vector<CLaneWaySection*> sections = line->getFlexSections(indexSec);
//					renderObject->begin(tempStyle->getSupportImg(), Ogre::RenderOperation::OT_TRIANGLE_LIST,VirtualMine::Core::VR_MINE_DEFAULT_RESOURCE_GROUP);
//
//					int index2 = 0;
//					for (std::vector<CLaneWaySection*>::iterator iteflexSection  = sections.begin();iteflexSection!=sections.end();iteflexSection++)
//					{
//						CLaneWaySection* section = (*iteflexSection);
//						for (int i = 0;i<section->getPointsCount();i++)
//						{
//							renderObject->position(section->getPoints()[i]);
//							if (i == 0)
//							{
//								renderObject->textureCoord((float)index2/sections.size(),0);
//							}
//							if (i == 1)
//							{
//								renderObject->textureCoord((float)index2/sections.size(),0.25);
//							}
//							if (i == 2)
//							{
//								renderObject->textureCoord((float)index2/sections.size(),0.5);
//							}
//							if (i == 3)
//							{
//								renderObject->textureCoord((float)index2/sections.size(),0.75);
//							}
//							if (i>3)
//							{
//								renderObject->textureCoord((float)index2/sections.size(),0.75 + (i-3)*0.25/18);
//							}
//						}
//						index2++;
//					}
//
//					for (int i = 1;i<sections.size();i++)
//					{
//						for (int j = 1;j<line->getSection(0)->getPointsCount();j++)
//						{
//							renderObject->triangle((i-1)*22 +j-1, i*22+j-1, i*22+j);
//							renderObject->triangle(i*22+j, (i-1)*22+j, (i-1)*22+j-1);
//						}
//					}
//					renderObject->end();
//				}
//#pragma endregion 
//
//				
//
//#pragma region 开始创建 ManualObject3
//				renderObject3->begin(mat->getName(), Ogre::RenderOperation::OT_TRIANGLE_LIST,VirtualMine::Core::VR_MINE_DEFAULT_RESOURCE_GROUP);
//
//				for (int indexSec = end2-1 ;indexSec<line->getSectionCount();indexSec++)
//				{
//					CLaneWaySection* section = line->getSection(indexSec);	
//
//					float distance = 0.0f;
//					if (indexSec % 2 != 0)
//					{
//						CLaneWaySection* preSection = line->getSection(indexSec-1);
//						distance = (preSection->getPoints()[0]-section->getPoints()[0]).length();
//					}
//
//					for (int i = 0;i<section->getPointsCount();i++)
//					{
//						//设置位置
//						renderObject3->position(section->getPoints()[i]);
//						if (indexSec % 2 == 0)
//						{
//							if (i == 0)
//							{
//								renderObject3->textureCoord(0,0);
//							}
//							if (i == 1)
//							{
//								renderObject3->textureCoord(0,0.25);
//							}
//							if (i == 2)
//							{
//								renderObject3->textureCoord(0,0.5);
//							}
//							if (i == 3)
//							{
//								renderObject3->textureCoord(0,0.75);
//							}
//							if (i>3)
//							{
//								renderObject3->textureCoord(0,0.75 + (i-3)*0.25/18);
//							}
//						}
//						else
//						{
//							if (i == 0)
//							{
//								renderObject3->textureCoord(distance/3,0);
//							}
//							if (i == 1)
//							{
//								renderObject3->textureCoord(distance/3,0.25);
//							}
//							if (i == 2)
//							{
//								renderObject3->textureCoord(distance/3,0.5);
//							}
//							if (i == 3)
//							{
//								renderObject3->textureCoord(distance/3,0.75);
//							}
//							if (i>3)
//							{
//								renderObject3->textureCoord(distance/3,0.75 + (i-3)*0.25/18);
//							}
//						}
//
//					}	
//				}
//				//i<line->getSectionCount()
//				/*for (int i = 1;i<line->getSectionCount()/2;i++)
//				{
//					if (i%2 == 0)  continue;
//					for (int j = 1;j<line->getSection(0)->getPointsCount();j++)
//					{
//						renderObject2->triangle((i-1)*22 +j-1, i*22+j-1, i*22+j);
//						renderObject2->triangle(i*22+j, (i-1)*22+j, (i-1)*22+j-1);
//					}
//				}*/
//				//getSectionCount()/2
//				for (int i = 0;i<line->getSectionCount()-end2-1;i++)
//				{
//					if (i%2 == 0)  continue;
//					for (int j = 1;j<line->getSection(0)->getPointsCount();j++)
//					{
//						renderObject3->triangle((i-1)*22 +j-1, i*22+j-1, i*22+j);
//						renderObject3->triangle(i*22+j, (i-1)*22+j, (i-1)*22+j-1);
//					}
//				}
//				renderObject3->end();		
//#pragma endregion
//#pragma region 创建ManualObject3巷道拐角处				
//				for (int indexSec = end2-1;indexSec<line->getFlexSectionsCount();indexSec++)
//				{
//					std::vector<CLaneWaySection*> sections = line->getFlexSections(indexSec);
//					renderObject3->begin(tempStyle->getSupportImg(), Ogre::RenderOperation::OT_TRIANGLE_LIST,VirtualMine::Core::VR_MINE_DEFAULT_RESOURCE_GROUP);
//
//					int index2 = 0;
//					for (std::vector<CLaneWaySection*>::iterator iteflexSection  = sections.begin();iteflexSection!=sections.end();iteflexSection++)
//					{
//						CLaneWaySection* section = (*iteflexSection);
//						for (int i = 0;i<section->getPointsCount();i++)
//						{
//							renderObject3->position(section->getPoints()[i]);
//							if (i == 0)
//							{
//								renderObject3->textureCoord((float)index2/sections.size(),0);
//							}
//							if (i == 1)
//							{
//								renderObject3->textureCoord((float)index2/sections.size(),0.25);
//							}
//							if (i == 2)
//							{
//								renderObject3->textureCoord((float)index2/sections.size(),0.5);
//							}
//							if (i == 3)
//							{
//								renderObject3->textureCoord((float)index2/sections.size(),0.75);
//							}
//							if (i>3)
//							{
//								renderObject3->textureCoord((float)index2/sections.size(),0.75 + (i-3)*0.25/18);
//							}
//						}
//						index2++;
//					}
//
//					for (int i = 1;i<sections.size();i++)
//					{
//						for (int j = 1;j<line->getSection(0)->getPointsCount();j++)
//						{
//							renderObject3->triangle((i-1)*22 +j-1, i*22+j-1, i*22+j);
//							renderObject3->triangle(i*22+j, (i-1)*22+j, (i-1)*22+j-1);
//						}
//					}
//					renderObject3->end();
//				}
//#pragma endregion 
//
//		
//				geoExtentionData->setExtentionData(renderObject);
//				//kk
//				//*geoExtentionData2->setExtentionData(renderObject2);
//				geoExtentionData3->setExtentionData(renderObject3);
//				
//				
//				this->ref_mGeoExtantionDataVector->push_back(geoExtentionData);
//				
//				this->ref_mGeoExtantionDataVector->push_back(geoExtentionData3);
	#pragma endregion
			}	
#pragma endregion 
		}

		void CLanewayProgress_MeshCreator::buildIntersectionPart()
		{
			#pragma region 创建截面
			int index = 0;
			for (std::vector<CLaneWayCrossNodeGeometry*>::iterator iteCross = this->mLanewayCrossNodes.begin();iteCross!=this->mLanewayCrossNodes.end();iteCross++)
			{
				CLaneWayCrossNodeGeometry* crossNode = (*iteCross);

				if (crossNode == NULL || crossNode->getCrossNode() == NULL)
				{
					break;
				}
				///交叉点的邻近点为 0 
			    if (crossNode->getAdjancentNodesCount()  > 0)
			    {
				
					for (int i = 0;i<crossNode->getAdjancentNodesCount();i++)
					{
						CLaneWayNodeGeometry* node = crossNode->getAdjancentNode(i);
						//计算截面偏角
						Ogre::Vector3 direction = node->getPosition() - crossNode->getCrossNode()->getPosition();
						direction.y = 0;
						direction.normalise();
						float azimuthAngle = VirtualMine::MathEngine::CMathCalculator::CalculateAzimuth(direction);

						CLaneWaySection* section = this->createSection(this->mpStyle);
						section->Rotate(Ogre::Radian(azimuthAngle));

						Ogre::Vector3 startPos = this->getCrossOffsetPos(node,crossNode,this->mpStyle);
						section->setPosition(startPos);

						crossNode->addSection(section);				
					}
			    }

				
				index++;
			}
				
			#pragma endregion
			
			#pragma region 构建顶点和索引集合

			for (std::vector<CLaneWayCrossNodeGeometry*>::iterator iteCross = this->mLanewayCrossNodes.begin();iteCross!=this->mLanewayCrossNodes.end();iteCross++)
			{
				CLaneWayCrossNodeGeometry* crossNode = (*iteCross);

				assert(crossNode != NULL);

				CGeoExtentionData* geoExtentionData = new CGeoExtentionData(this->ref_mpSceneMgr);
				assert(geoExtentionData != NULL);
				Ogre::ManualObject* renderObject = this->ref_mpSceneMgr->createManualObject(crossNode->getCrossNode()->getName() + "_Intersection");
				assert(renderObject != NULL);

				renderObject->begin("testMaterial", Ogre::RenderOperation::OT_TRIANGLE_LIST,VirtualMine::Core::VR_MINE_DEFAULT_RESOURCE_GROUP);
			
					int pointCount = 0;
					for (int i = 0;i<crossNode->getSectionsCount();i++)
					{
						CLaneWaySection* section = crossNode->getSection(i);
						assert(section != NULL);

						for (int j = 0;j<section->getPointsCount();j++)
						{
							renderObject->position(section->getPoints()[j]);
							pointCount++;
						}		
					}

					for (int i = 0;i<crossNode->getSectionsCount();i++)
					{
						CLaneWaySection* section = crossNode->getSection(i);
						assert(section != NULL);

						renderObject->position(section->getPoints()[12]);
						pointCount++;		
					}

					Ogre::Vector3 topPt = Ogre::Vector3(0,0,0);
					Ogre::Vector3 bottomPt = Ogre::Vector3(0,0,0);

					if (crossNode->getSectionsCount() > 0)
					{
						for (int i = 0;i<crossNode->getSectionsCount();i++)
						{
							CLaneWaySection* section = crossNode->getSection(i);
							assert(section != NULL);

							topPt = topPt + section->getPoints()[12];
							bottomPt=bottomPt+section->getPoints()[1];
						}
					}
					if(crossNode->getSectionsCount() > 0)
					{
						topPt = topPt/crossNode->getSectionsCount();
						bottomPt = bottomPt/crossNode->getSectionsCount();
					}
					

					renderObject->position(topPt);
					pointCount++;

					renderObject->position(bottomPt);
					pointCount++;		

					if (crossNode->getAdjancentNodesCount() == 2)
					{
						//绘制底面
						for (int i = 0;i<crossNode->getSectionsCount();i++)
						{
							if (i ==crossNode->getSectionsCount()-1)
							{
								renderObject->triangle(i*22+2, i*22+1, 2);
								//renderObject->setMaterialName()

								renderObject->triangle(i*22+2, 1, 2);
							}
						}
					}
					else if (crossNode->getAdjancentNodesCount() > 2) ///原来是else
					{
						//绘制底面
						for (int i = 0; i < crossNode->getSectionsCount(); i++)
						{
							if (i != crossNode->getSectionsCount()-1)
							{
								renderObject->triangle(i*22+2, i*22+1, pointCount-1);
								renderObject->triangle(i*22+2, (i+1)*22+1, pointCount-1);
							}
							else
							{
								renderObject->triangle(i*22+2, i*22+1, pointCount-1);
								renderObject->triangle(i*22+2, 1, pointCount-1);
							}
						}

						//绘制顶面
						for (int i = 0;i<crossNode->getSectionsCount();i++)
						{
							int index = 22 * crossNode->getSectionsCount();
							if (i!=crossNode->getSectionsCount()-1)
							{
								renderObject->triangle(index+i+1,index+i,  pointCount-2);
							}
							else
							{
								renderObject->triangle(index+i,index,  pointCount-2);
							}		
						}
					}
			

					//绘制侧面
					for (int i = 0;i<crossNode->getSectionsCount();i++)
					{
						if (i != crossNode->getSectionsCount()-1)
						{
							renderObject->triangle(i*22+2,i*22+3, (i+1)*22);
							renderObject->triangle((i+1)*22,(i+1)*22+1, i*22+2);
						}
						else
						{
							renderObject->triangle(i*22+2,i*22+3, 0);
							renderObject->triangle(0, 1, i*22+2);
						}
					}

					for (int i = 0;i<crossNode->getSectionsCount();i++)
					{
						if (i != crossNode->getSectionsCount()-1)
						{
							for (int j=0;j<9;j++)
							{
								renderObject->triangle(i*22+3+j,(i+1)*22+21-j,  (i+1)*22+21-j-1);
								renderObject->triangle(i*22+3+j,i*22+3+j+1,(i+1)*22+21-j-1);
							}				
						}
						else
						{
							for (int j=0;j<9;j++)
							{
								renderObject->triangle(i*22+3+j,21-j,  21-j-1);
								renderObject->triangle(i*22+3+j,i*22+3+j+1, 21-j-1);
							}	
						}
					}			
					renderObject->end();	

					geoExtentionData->setExtentionData(renderObject);
					this->ref_mGeoExtantionDataVector->push_back(geoExtentionData);
				}
				
			
			#pragma endregion


			int i = 0;
		}

		void CLanewayProgress_MeshCreator::buildTextProgress(const Ogre::String& dateInfo,Ogre::Vector3 center){
				//Ogre::String lanewayName = dateInfo;
				////Ogre::String firstChar = lanewayName.substr(0,2);
				//Ogre::String firstChar = lanewayName.c_str();
				//
				//	int iWLen = MultiByteToWideChar( CP_ACP, 0, lanewayName.c_str(), lanewayName.size(), 0, 0 ); // 计算转换后宽字符串的长度。（不包含字符串结束符）  
				//	wchar_t *lpwsz = new wchar_t [iWLen + 1];  //wchar_t是C++的宽字符类型
				//	MultiByteToWideChar( CP_ACP, 0, lanewayName.c_str(), lanewayName.size(), lpwsz, iWLen ); // 正式转换。  
				//	//MultiByteToWideChar( CP_ACP, 0, "李佳康", 3, lpwsz, iWLen );
				//	//kk原始代码
				//	lpwsz[iWLen] = L'\0';//将末尾转换为Unicode
				//	Ogre::DisplayString disName(lpwsz);

				//	//////////////////////////////////////////////////////////////////////////
				//	VirtualMine::BaseRender::MovableText* pText = new VirtualMine::BaseRender::MovableText(lanewayName,
				//		Ogre::DisplayString(disName),Ogre::String("SimHei"),10,Ogre::ColourValue(1,0.843,0,1));//ColourValue::Green
				//	pText->showOnTop(true);
				//	pText->setTextAlignment(VirtualMine::BaseRender::MovableText::H_CENTER,VirtualMine::BaseRender::MovableText::V_ABOVE);//MovableText:: V_CENTER
				//	

		}


		//kk定义分段创建manuobject的函数
		void CLanewayProgress_MeshCreator::buildProgressPart(CLaneWayLineGeometry* line,int start,int end,Ogre::String name,LanewaySuppoetType type,Ogre::Vector3 textPos,Ogre::String& message){
			CLaneWayObjectPro* lanewayObjectPro = new CLaneWayObjectPro();

			VirtualMine::Style::CLanewayStyle* tempStyle =  new VirtualMine::Style::CLanewayStyle();
			tempStyle->setSupportType(type);

			CGeoExtentionData* geoExtentionData = new CGeoExtentionData(this->ref_mpSceneMgr);


			//kk第二个geoExtentionData
			geoExtentionData->setOwnerObject(lanewayObjectPro);

			Ogre::ManualObject* renderObject = this->ref_mpSceneMgr->createManualObject(name);

			Ogre::MaterialPtr mat = Ogre::MaterialManager::getSingletonPtr()->getByName(tempStyle->getSupportImg(),VirtualMine::Core::VR_MINE_DEFAULT_RESOURCE_GROUP);
			
			Ogre::Any any((VirtualMine::Core::CBaseObject*)(lanewayObjectPro));
			renderObject->setUserAny(any);
			#pragma region 开始创建 ManualObject
				renderObject->begin(mat->getName(), Ogre::RenderOperation::OT_TRIANGLE_LIST,VirtualMine::Core::VR_MINE_DEFAULT_RESOURCE_GROUP);

				for (int indexSec = start ;indexSec<end;indexSec++)
				{
					CLaneWaySection* section = line->getSection(indexSec);	

					float distance = 0.0f;
					if (indexSec % 2 != 0)
					{
						CLaneWaySection* preSection = line->getSection(indexSec-1);
						distance = (preSection->getPoints()[0]-section->getPoints()[0]).length();
					}

					for (int i = 0;i<section->getPointsCount();i++)
					{
						//设置位置
						renderObject->position(section->getPoints()[i]);
						if (indexSec % 2 == 0)
						{
							if (i == 0)
							{
								renderObject->textureCoord(0,0);
							}
							if (i == 1)
							{
								renderObject->textureCoord(0,0.25);
							}
							if (i == 2)
							{
								renderObject->textureCoord(0,0.5);
							}
							if (i == 3)
							{
								renderObject->textureCoord(0,0.75);
							}
							if (i>3)
							{
								renderObject->textureCoord(0,0.75 + (i-3)*0.25/18);
							}
						}
						else
						{
							if (i == 0)
							{
								renderObject->textureCoord(distance/3,0);
							}
							if (i == 1)
							{
								renderObject->textureCoord(distance/3,0.25);
							}
							if (i == 2)
							{
								renderObject->textureCoord(distance/3,0.5);
							}
							if (i == 3)
							{
								renderObject->textureCoord(distance/3,0.75);
							}
							if (i>3)
							{
								renderObject->textureCoord(distance/3,0.75 + (i-3)*0.25/18);
							}
						}

					}	
				}
				//i<line->getSectionCount()
				/*for (int i = 1;i<line->getSectionCount()/2;i++)
				{
					if (i%2 == 0)  continue;
					for (int j = 1;j<line->getSection(0)->getPointsCount();j++)
					{
						renderObject2->triangle((i-1)*22 +j-1, i*22+j-1, i*22+j);
						renderObject2->triangle(i*22+j, (i-1)*22+j, (i-1)*22+j-1);
					}
				}*/
				//getSectionCount()/2
				for (int i = 1;i<(end-start);i++)
				{
					if (i%2 == 0)  continue;
					for (int j = 1;j<line->getSection(0)->getPointsCount();j++)
					{
						renderObject->triangle((i-1)*22 +j-1, i*22+j-1, i*22+j);
						renderObject->triangle(i*22+j, (i-1)*22+j, (i-1)*22+j-1);
					}
				}
				renderObject->end();		
			#pragma endregion 


			#pragma region 创建ManualObject巷道拐角处				
				for (int indexSec = start;indexSec<end;indexSec++)
				{
					//kk判断是否超过拐角总数
					if (indexSec>=line->getFlexSectionsCount())
					{
						break;
					}
					std::vector<CLaneWaySection*> sections = line->getFlexSections(indexSec);
					renderObject->begin(tempStyle->getSupportImg(), Ogre::RenderOperation::OT_TRIANGLE_LIST,VirtualMine::Core::VR_MINE_DEFAULT_RESOURCE_GROUP);

					int index2 = 0;
					for (std::vector<CLaneWaySection*>::iterator iteflexSection  = sections.begin();iteflexSection!=sections.end();iteflexSection++)
					{
						CLaneWaySection* section = (*iteflexSection);
						for (int i = 0;i<section->getPointsCount();i++)
						{
							renderObject->position(section->getPoints()[i]);
							if (i == 0)
							{
								renderObject->textureCoord((float)index2/sections.size(),0);
							}
							if (i == 1)
							{
								renderObject->textureCoord((float)index2/sections.size(),0.25);
							}
							if (i == 2)
							{
								renderObject->textureCoord((float)index2/sections.size(),0.5);
							}
							if (i == 3)
							{
								renderObject->textureCoord((float)index2/sections.size(),0.75);
							}
							if (i>3)
							{
								renderObject->textureCoord((float)index2/sections.size(),0.75 + (i-3)*0.25/18);
							}
						}
						index2++;
					}

					for (int i = 1;i<sections.size();i++)
					{
						for (int j = 1;j<line->getSection(0)->getPointsCount();j++)
						{
							renderObject->triangle((i-1)*22 +j-1, i*22+j-1, i*22+j);
							renderObject->triangle(i*22+j, (i-1)*22+j, (i-1)*22+j-1);
						}
					}
					renderObject->end();
				}
			#pragma endregion 

			geoExtentionData->setExtentionData(renderObject);
			//kk
			this->ref_mGeoExtantionDataVector->push_back(geoExtentionData);


			/////////////////////////////////////////	
			//kk测试文字
			Ogre::String lanewayName2 = message;
			int iWLen2 = MultiByteToWideChar( CP_ACP, 0, lanewayName2.c_str(), lanewayName2.size(), 0, 0 ); // 计算转换后宽字符串的长度。（不包含字符串结束符）  
			wchar_t *lpwsz2 = new wchar_t [iWLen2 + 1];  //wchar_t是C++的宽字符类型
			MultiByteToWideChar( CP_ACP, 0, lanewayName2.c_str(), lanewayName2.size(), lpwsz2, iWLen2 ); // 正式转换。  
			//kk原始代码
			lpwsz2[iWLen2] = L'\0';//将末尾转换为Unicode
			Ogre::DisplayString disName2(lpwsz2);


			VirtualMine::BaseRender::MovableText* pText2 = new VirtualMine::BaseRender::MovableText(lanewayName2,
				Ogre::DisplayString(disName2),Ogre::String("SimHei"),10,Ogre::ColourValue(1,0.843,0,1));//ColourValue::Green
			pText2->showOnTop(true);
			pText2->setTextAlignment(VirtualMine::BaseRender::MovableText::H_CENTER,VirtualMine::BaseRender::MovableText::V_ABOVE);//MovableText:: V_CENTER
			
			Ogre::SceneNode* node2 = this->ref_mpSceneMgr->getRootSceneNode()->createChildSceneNode(textPos);
			node2->attachObject(pText2);
			//this->mBuildTextNodes.push_back(node2);
			this->mBuildTextNodes->push_back(node2);
			//this->mTextNodes.push_back(node2);
			

			//////////////////////////////////////////////////////////////////////////

		}
	}
}
