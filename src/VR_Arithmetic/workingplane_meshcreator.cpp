//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : 三维数字矿山平台
//  @ File Name : workingplane_meshcreator.cpp
//  @ Date : 2014/10/26
//  @ Author : 王凯
//  @ Implement : 
//  @ Company : 中国矿业大学(北京)
//  @ Copyright:  2014-2020
//  @ Description : 


#include "vrmine/vr_arithmetic/arithmetic/workingplane_meshcreator.h"
#include "vrmine/vr_core/geodatatype.h"
#include "vrmine/vr_spatialobject/mine/workingplaneobject.h"
#include "vrmine/vr_geometry/geometry/workingplane.h"
#include "vrmine/vr_spatialobject/mine/workingplaneproperty.h"
#include "vrmine/vr_style/style/workingplanestyle.h"
#include "vrmine/vr_arithmetic/arithmetic/geometryarithmeticlibrary.h"
#include <OGRE/OgreBlendMode.h>
#include "vrmine/vr_spatialinterface/iscene.h"

namespace VirtualMine
{
	namespace Arithmetic
	{
		CWorkingplane_MeshCreator::CWorkingplane_MeshCreator()
		{
			this->setType(VirtualMine::Core::GeoDataType::GDT_WORKINGPLANE);
		}

		CWorkingplane_MeshCreator::~CWorkingplane_MeshCreator()
		{


		}

		/*void CCoalSeam_MeshCreator::createData(VirtualMine::SpatialInterface::GeoObjectVector& geoObjectVector,std::vector<VirtualMine::SpatialInterface::CGeoExtentionData*>& geoExtentionDatas)
		{
		if (geoObjectVector.size() == 0)
		{
		return;
		}

		VirtualMine::Mine::CCoalSeamObject* coalObject = dynamic_cast<VirtualMine::Mine::CCoalSeamObject*>(geoObjectVector[0]);
		if (coalObject == NULL)
		{
		return;
		}
		VirtualMine::Geometry::CCoalSeamGeometry* coalGeometry = dynamic_cast<VirtualMine::Geometry::CCoalSeamGeometry*>(coalObject->getGeometry());
		VirtualMine::GeoProperty::CCoalSeamProperty* coalProperty = dynamic_cast<VirtualMine::GeoProperty::CCoalSeamProperty*>(coalObject->getGeoProperty());
		VirtualMine::Style::CCoalSeamStyle* coalStyle = dynamic_cast<VirtualMine::Style::CCoalSeamStyle*>(coalObject->getStyle());

		VirtualMine::SpatialInterface::CGeoExtentionData* data = new VirtualMine::SpatialInterface::CGeoExtentionData();
		Ogre::ManualObject* renderObject = this->ref_mpSceneMgr->createManualObject(coalProperty->getName());
		data->setExtentionData(renderObject);

		geoExtentionDatas.push_back(data);

		std::vector<Ogre::Vector3> coors;
		IntVector indexes;

		if (coalGeometry!= NULL && coalProperty!=NULL && coalStyle !=NULL)
		{
		renderObject->begin("testMaterial", Ogre::RenderOperation::OT_TRIANGLE_LIST);

		for (int i = 0;i<coalGeometry->getCount();i++)
		{
		VirtualMine::Geometry::CPoint point = coalGeometry->getPoint(i);
		Ogre::Vector3 realPoint = Ogre::Vector3(point.getX(),point.getY(),point.getZ());

		renderObject->position(realPoint);
		Ogre::Vector3 planePoint = realPoint;
		planePoint.y = 0;
		coors.push_back(planePoint);
		}

		VirtualMine::Arithmetic::CGeometryArithmeticLibrary::createTINData(coors,indexes);

		for (int i = 0;i<indexes.size()/3;i++)
		{
		renderObject->triangle(indexes[3*i],indexes[3*i+1],indexes[3*i+2]);
		}
		renderObject->end();	
		}				
		}*/

		void CWorkingplane_MeshCreator::createData(VirtualMine::SpatialInterface::GeoObjectVector& geoObjectVector,std::vector<VirtualMine::SpatialInterface::CGeoExtentionData*>& geoExtentionDatas)
		{
			if (geoObjectVector.size() == 0)
			{
				return;
			}

			int workingplaneObjectCount = geoObjectVector.size();
			for (int i = 0; i < workingplaneObjectCount; i++)
			{
				VirtualMine::Mine::CWorkingplaneObject* workingplaneObject = dynamic_cast<VirtualMine::Mine::CWorkingplaneObject*>(geoObjectVector[i]);
				if (workingplaneObject == NULL)
				{
					return;
				}
				VirtualMine::Geometry::CWorkingplaneGeometry* workingplaneGeometry = dynamic_cast<VirtualMine::Geometry::CWorkingplaneGeometry*>(workingplaneObject->getGeometry());
				VirtualMine::GeoProperty::CWorkingplaneProperty* workingplaneProperty = dynamic_cast<VirtualMine::GeoProperty::CWorkingplaneProperty*>(workingplaneObject->getGeoProperty());
				VirtualMine::Style::CWorkingplaneStyle* workingplaneStyle = dynamic_cast<VirtualMine::Style::CWorkingplaneStyle*>(workingplaneObject->getStyle());

				//不能设置？
				//workingplaneProperty->setName(workingplaneObject->getName());
				
				//workingplaneStyle->setFillColor(Ogre::ColourValue(1.0,1.0,0));


				/*VirtualMine::SpatialInterface::CGeoExtentionData* data = new VirtualMine::SpatialInterface::CGeoExtentionData();
				Ogre::ManualObject* renderObject = this->ref_mpSceneMgr->createManualObject(workingplaneObject->getName());
				data->setExtentionData(renderObject);

				geoExtentionDatas.push_back(data);*/

				Ogre::String workingplaneMaterial = "workingplaneMaterial";
				Ogre::MaterialPtr material = Ogre::MaterialManager::getSingletonPtr()->getByName(workingplaneMaterial,VirtualMine::Core::VR_MINE_DEFAULT_RESOURCE_GROUP);

				//Ogre::MaterialPtr material = Ogre::MaterialManager::getSingletonPtr()->create(workingplaneObject->getName(),VirtualMine::Core::VR_MINE_DEFAULT_RESOURCE_GROUP);

				if (!material.isNull())
				{
					Ogre::Pass* pass = material->getTechnique(0)->getPass(0);		
					pass->setCullingMode(Ogre::CULL_NONE);		
					/*Ogre::Pass* pass2 = material->getTechnique(0)->createPass();
					pass2->setSceneBlending(Ogre::SBT_TRANSPARENT_ALPHA);
					pass2->setCullingMode(Ogre::CULL_NONE);
					Ogre::TextureUnitState* unitestate = new Ogre::TextureUnitState(pass2);
					pass2->addTextureUnitState(unitestate);*/
					material->load();
				}

				if (workingplaneGeometry != NULL /*&& workingplaneProperty != NULL && workingplaneStyle != NULL*/)
				{

				
					VirtualMine::SpatialInterface::CGeoExtentionData* data = new VirtualMine::SpatialInterface::CGeoExtentionData(this->ref_mpSceneMgr);

					std::string wpname = workingplaneObject->getName();
					wpname.append("_WorkingPlane");
					Ogre::ManualObject* renderObject = this->ref_mpSceneMgr->createManualObject(wpname);
					data->setExtentionData(renderObject);

					geoExtentionDatas.push_back(data);

					Ogre::Any any((VirtualMine::Core::CBaseObject*)workingplaneObject);
					renderObject->setUserAny(any);

					renderObject->begin(workingplaneMaterial, Ogre::RenderOperation::OT_TRIANGLE_LIST);



				
					int count = workingplaneGeometry->getCount();

					double tmpminX(0);
					double tmpmaxX(0);
					double tmpminZ(0);
					double tmpmxaZ(0);
					//计算最大值和最小值
					for (int m = 0; m < count; m++)
					{
					
						if (workingplaneGeometry->getPoint(i).getX() < tmpminX)
						{
							tmpminX = workingplaneGeometry->getPoint(i).getX();
						}
						if (workingplaneGeometry->getPoint(i).getZ() < tmpminZ)
						{
						    tmpminZ = workingplaneGeometry->getPoint(i).getZ();
						}
					    if (workingplaneGeometry->getPoint(i).getX() > tmpmaxX)
					    {
							tmpmaxX = workingplaneGeometry->getPoint(i).getX();
					    }
						if (workingplaneGeometry->getPoint(i).getZ() > tmpmxaZ)
						{
							tmpmxaZ = workingplaneGeometry->getPoint(i).getZ();
						}

					}
					
					double Xlength = tmpmaxX - tmpminX;
					double Zlength = tmpmxaZ - tmpminZ;
					double uSize = Xlength / 100;
					double vSize = Zlength / 100;

					for (int i = 0 ; i < count; i++)
					{
						double x = workingplaneGeometry->getPoint(i).getX();
						double y = workingplaneGeometry->getPoint(i).getY();
						double z = workingplaneGeometry->getPoint(i).getZ();
						z *= -1; 
				        renderObject->position(x,y,z);	
						
						Ogre::Real u = uSize * (x - tmpminX)/ Xlength;
						Ogre::Real v = 1- (tmpmxaZ - z)/Zlength;
						v *= vSize;
						renderObject->textureCoord(u,v); 
						renderObject->colour(0,1.0,0);
					}

					for (int i = 1;i<count-1;i++)
					{
						//renderObject->triangle(i*2,i*2+1,(i+1)*2);
						//renderObject->triangle(i*2+1,(i+1)*2+1,(i+1)*2);
						renderObject->triangle(0,i,i+1);
					}

					renderObject->end();


				}	
			}


		}
	}
}