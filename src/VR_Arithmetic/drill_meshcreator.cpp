//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : 三维数字矿山平台
//  @ File Name : drill_meshcreator.cpp
//  @ Date : 2014/8/5
//  @ Author : 朱炜鹏
//  @ Implement : 
//  @ Company : 中国矿业大学(北京)
//  @ Copyright:  2014-2020
//  @ Description : 


#include "vrmine/vr_arithmetic/arithmetic/drill_meshcreator.h"
#include "vrmine/vr_core/geodatatype.h"
#include "vrmine/vr_spatialobject/mine/drillobject.h"
#include "vrmine/vr_spatialobject/geoproperty/drillproperty.h"
#include "vrmine/vr_spatialinterface/parameter.h"
#include "vrmine/vr_geometry/geometry/drillhole.h"
#include "vrmine/vr_style/style/drillholestyle.h"
#include <OGRE/Ogre.h>
namespace VirtualMine
{
	namespace Arithmetic
	{
		#pragma region 钻孔截面实现
		CDrillSection::CDrillSection()
		{

		}

		CDrillSection::~CDrillSection()
		{

		}
		void CDrillSection::setCenter(const Ogre::Vector3& center)
		{
			this->mCenter = center;
		}
		Ogre::Vector3 CDrillSection::getCenter()
		{
			return this->mCenter;
		}
		void CDrillSection::addPoint(const Ogre::Vector3& point)
		{
			this->mPoints.push_back(point);
		}
		int  CDrillSection::getPointsCount()
		{
			return this->mPoints.size();
		}
		Ogre::Vector3 CDrillSection::getPoint(const int& index)
		{
			return this->mPoints[index];
		}
		#pragma endregion 

		CDrill_MeshCreator::CDrill_MeshCreator()
		{
			this->setType(VirtualMine::Core::GeoDataType::GDT_DRILL);
		}

		CDrill_MeshCreator::~CDrill_MeshCreator()
		{

		}

		/*void CDrill_MeshCreator::createData(VirtualMine::SpatialInterface::GeoObjectVector& geoObjectVector,std::vector<VirtualMine::SpatialInterface::CGeoExtentionData*>& geoExtentionDatas)
		{
		if (geoObjectVector.size() == 0)
		{
		return;
		}

		VirtualMine::Mine::CDrillObject* drillObject = dynamic_cast<VirtualMine::Mine::CDrillObject*>(geoObjectVector[0]);

		if (!this->ref_mpSceneMgr->hasManualObject("UnitDrill"))
		{
		this->createUnitDrill();
		}
		
		Ogre::ManualObject* object = this->ref_mpSceneMgr->getManualObject("UnitDrill");
		VirtualMine::SpatialInterface::CGeoInstanceExtentionData* data = new VirtualMine::SpatialInterface::CGeoInstanceExtentionData();
		data->setExtentionData(object);

		VirtualMine::GeoProperty::CDrillProperty* pro = dynamic_cast<VirtualMine::GeoProperty::CDrillProperty*>(drillObject->getGeoProperty());
		VirtualMine::Geometry::CDrillHoleGeometry* geometry = dynamic_cast<VirtualMine::Geometry::CDrillHoleGeometry*>(drillObject->getGeometry());

		if (pro != NULL && geometry != NULL)
		{
		for (int i = 0; i< pro->getStratumCount(); i++)
		{
		VirtualMine::GeoProperty::CStratum* stratum = dynamic_cast<VirtualMine::GeoProperty::CStratum*>(pro->getStratum(i));
		float radius = pro->getRadius();
		VirtualMine::SpatialInterface::CParameter param;
		param.setScale(Ogre::Vector3(radius/2,stratum->getDepth(),radius/2));
		param.setTranslate(Ogre::Vector3(geometry->getX(),0,geometry->getZ()));
		data->addParameter(param);
		}
		}	
		geoExtentionDatas.push_back(data);
		}*/

		void CDrill_MeshCreator::createData(VirtualMine::SpatialInterface::GeoObjectVector& geoObjectVector,std::vector<VirtualMine::SpatialInterface::CGeoExtentionData*>& geoExtentionDatas)
		{
			Ogre::MaterialPtr material = Ogre::MaterialManager::getSingletonPtr()->create("testMaterial001",Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
		
			if (!material.isNull())
			{
				Ogre::Pass* pass = material->getTechnique(0)->getPass(0);
				pass->setCullingMode(Ogre::CULL_NONE);
				//pass->createTextureUnitState("laneway.jpg");
				material->load();
			}

			if (geoObjectVector.size() == 0)
			{
				return;
			}
			//dynamic_cast<CGeoSceneManager*>(this->ref_mpSceneMgr)->get
			for (size_t num = 0 ; num < geoObjectVector.size(); ++num)
			{
				this->mSections.clear();
				VirtualMine::Mine::CDrillObject* drillObject = dynamic_cast<VirtualMine::Mine::CDrillObject*>(geoObjectVector[num]);
				VirtualMine::GeoProperty::CDrillProperty* pro = dynamic_cast<VirtualMine::GeoProperty::CDrillProperty*>(drillObject->getGeoProperty());
				VirtualMine::Geometry::CDrillHoleGeometry* geometry = dynamic_cast<VirtualMine::Geometry::CDrillHoleGeometry*>(drillObject->getGeometry());
				VirtualMine::Style::CDrillHoleStyle* style = dynamic_cast<VirtualMine::Style::CDrillHoleStyle*>(drillObject->getStyle());

				int totalDepth = geometry->getY();
				Ogre::Vector3 startPoint = Ogre::Vector3(geometry->getX(),geometry->getY(),geometry->getZ());
			
			
			 
				
				float radius = pro->getRadius(); 
				this->mSections.push_back(this->createSectionPoints(startPoint,radius));
				for (int i = 0; i<pro->getStratumCount();i++)
				{
					VirtualMine::GeoProperty::CStratum* stratum = pro->getStratum(i);
					totalDepth -= stratum->getDepth();
					Ogre::Vector3 point = Ogre::Vector3(startPoint.x,totalDepth,startPoint.z);
					if (i == pro->getStratumCount() - 1 )
					{
						this->mSections.push_back(this->createSectionPoints(point,radius));
					}
					else
					{
						this->mSections.push_back(this->createSectionPoints(point,radius));
						this->mSections.push_back(this->createSectionPoints(point,radius));
					}
				}
				VirtualMine::SpatialInterface::CGeoExtentionData* data = new VirtualMine::SpatialInterface::CGeoExtentionData(this->ref_mpSceneMgr);
				//this->ref_mpSceneMgr->setAmbientLight(Ogre::ColourValue(0.8,0.8,0.8,1));
				Ogre::ManualObject* renderObject = this->ref_mpSceneMgr->createManualObject(pro->getName());
				data->setExtentionData(renderObject);

				Ogre::Any any((VirtualMine::Core::CBaseObject*)drillObject);
				renderObject->setUserAny(any);

				for (int i =0;i<pro->getStratumCount();i++)
				{
					CDrillSection* firsSection = this->mSections[2*i];
					CDrillSection* secondSection = this->mSections[2*i+1];
					float dis = Ogre::Math::Abs((secondSection->getCenter() - firsSection->getCenter()).y);

					std::string stratuminame = pro->getStratum(i)->getDeccription();
					std::string yangshiName = style->getMaterialName(stratuminame);
					std::string materalName = this->createDrillMaterial(yangshiName);

					renderObject->begin(materalName, Ogre::RenderOperation::OT_TRIANGLE_LIST,VirtualMine::Core::VR_MINE_DEFAULT_RESOURCE_GROUP);
					
					for (int j = 0;j<firsSection->getPointsCount();j++)
					{
						renderObject->position(firsSection->getPoint(j));
						Ogre::Vector3 normal = firsSection->getPoint(j) - firsSection->getCenter();
						normal.normalise();
						renderObject->normal(normal);
						renderObject->textureCoord(j/float(firsSection->getPointsCount()),0);
						//renderObject->colour(255,0,0);
					}

					for (int j = 0;j<secondSection->getPointsCount();j++)
					{
						renderObject->position(secondSection->getPoint(j));
						Ogre::Vector3 normal = secondSection->getPoint(j) - secondSection->getCenter();
						normal.normalise();
						renderObject->normal(normal);
						renderObject->textureCoord(j/float(secondSection->getPointsCount()),dis/10);
						//renderObject->colour(255,0,0);
					}

					for (int j = 0;j<secondSection->getPointsCount()-1;j++)
					{
						renderObject->triangle(j,j+1,j+secondSection->getPointsCount());
						renderObject->triangle(j+1,j+secondSection->getPointsCount()+1,j+secondSection->getPointsCount());
					}


					renderObject->end();
				}

				geoExtentionDatas.push_back(data);
			}
		}

		Ogre::ManualObject* CDrill_MeshCreator::createUnitDrill()
		{
			std::vector<Ogre::Vector3> upCirclePt;
			std::vector<Ogre::Vector3> downCirclePt;

			int count = 30;
			for (int i = 0;i<count;i++)
			{
				Ogre::Quaternion q;
				q.FromAngleAxis(Ogre::Radian(i*2*Ogre::Math::PI/(count - 1)),Ogre::Vector3::UNIT_Y);
				Ogre::Vector3 tempDownPt = q * Ogre::Vector3(1,0,0);
				Ogre::Vector3 tempUpPt = tempDownPt + Ogre::Vector3(0,1,0);
				downCirclePt.push_back(tempDownPt);
				upCirclePt.push_back(tempUpPt);
			}

			Ogre::ManualObject* renderObject = this->ref_mpSceneMgr->createManualObject("UnitDrill");

			renderObject->begin("testMaterial", Ogre::RenderOperation::OT_TRIANGLE_LIST,VirtualMine::Core::VR_MINE_DEFAULT_RESOURCE_GROUP);

			for (int i = 0;i<upCirclePt.size();i++)
			{
				renderObject->position(upCirclePt[i]);
				Ogre::Vector3 normal = upCirclePt[i] - Ogre::Vector3(0,1,0);
				normal.normalise();
				renderObject->normal(normal);
				renderObject->colour(255,0,0);
			}

			for (int i = 0;i<downCirclePt.size();i++)
			{
				renderObject->position(downCirclePt[i]);
				Ogre::Vector3 normal = downCirclePt[i] - Ogre::Vector3(0,0,0);
				normal.normalise();
				renderObject->normal(normal);
				renderObject->colour(0,250,0);
			}

			for (int i = 0;i<count-1;i++)
			{
				renderObject->triangle(i,count+i,i+1);
				renderObject->triangle(i+1,count+i,count+i+1);
			}

			renderObject->end();

			return renderObject;
		}

		CDrillSection* CDrill_MeshCreator::createSectionPoints(const Ogre::Vector3& position,const float& radius)
		 {
			 CDrillSection* section = new CDrillSection();
			 section->setCenter(position);
			 int count = 60;
			 for (int i = 0;i<count;i++)
			 {
				 Ogre::Quaternion q;
				 q.FromAngleAxis(Ogre::Radian(i*2*Ogre::Math::PI/(count - 1)),Ogre::Vector3::UNIT_Y);
				 Ogre::Vector3 tempPoint = q * Ogre::Vector3(radius/2,0,0) + position;
				 section->addPoint(tempPoint);
			 }
			 return section;
		 }

		std::string CDrill_MeshCreator::createDrillMaterial(std::string materialName)
		{
			Ogre::MaterialPtr material = Ogre::MaterialManager::getSingletonPtr()->getByName(materialName,VirtualMine::Core::VR_MINE_DEFAULT_RESOURCE_GROUP);
			if (!material.isNull())
			{
				Ogre::Pass* pass = material->getTechnique(0)->getPass(0);
				pass->setCullingMode(Ogre::CULL_NONE);
				material->load();
			}

			return materialName;
		}

	/*	void CDrill_MeshCreator::setDEMLayer( VirtualMine::SpatialLayer::CDemLayer* demlayer )
		{
			this->ref_pDemLayer = demlayer;
		}

		VirtualMine::SpatialLayer::CDemLayer* CDrill_MeshCreator::getDEMLayer()
		{
			return ref_pDemLayer;
		}*/

	}
}