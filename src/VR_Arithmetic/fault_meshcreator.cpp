//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : 三维数字矿山平台
//  @ File Name : fault_meshcreator.cpp
//  @ Date : 2014/8/5
//  @ Author : 朱炜鹏
//  @ Implement : 
//  @ Company : 中国矿业大学(北京)
//  @ Copyright:  2014-2020
//  @ Description : 


#include "vrmine/vr_arithmetic/arithmetic/fault_meshcreator.h"
#include "vrmine/vr_core/geodatatype.h"
#include "vrmine/vr_spatialobject/mine/faultobject.h"
#include "vrmine/vr_spatialobject/geoproperty/faultproperty.h"
#include "vrmine/vr_spatialinterface/parameter.h"
#include "vrmine/vr_geometry/geometry/fault.h"
#include "vrmine/vr_style/style/faultstyle.h"
namespace VirtualMine
{
	namespace Arithmetic
	{
		CFault_MeshCreator::CFault_MeshCreator()
		{
			this->setType(VirtualMine::Core::GeoDataType::GDT_FAULT);
		}

		CFault_MeshCreator::~CFault_MeshCreator()
		{

		}

		void CFault_MeshCreator::createData(VirtualMine::SpatialInterface::GeoObjectVector& geoObjectVector,std::vector<VirtualMine::SpatialInterface::CGeoExtentionData*>& geoExtentionDatas)
		{
			

			if (geoObjectVector.size() == 0)
			{
				return;
			}
			VirtualMine::Mine::CFaultObject* faultObject = dynamic_cast<VirtualMine::Mine::CFaultObject*>(geoObjectVector[0]);
			VirtualMine::GeoProperty::CFaultProperty* pro = dynamic_cast<VirtualMine::GeoProperty::CFaultProperty*>(faultObject->getGeoProperty());
			VirtualMine::Geometry::CFaultGeometry* geometry = dynamic_cast<VirtualMine::Geometry::CFaultGeometry*>(faultObject->getGeometry());
			VirtualMine::Style::CFaultStyle* style = dynamic_cast<VirtualMine::Style::CFaultStyle*>(faultObject->getStyle());

			if (geometry->getCount() < 2)
			{
				return;
			}

			Ogre::MaterialPtr material = Ogre::MaterialManager::getSingletonPtr()->create(pro->getName() + "_material",Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);

			if (!material.isNull())
			{
				Ogre::Pass* pass = material->getTechnique(0)->getPass(0);
				pass->setSceneBlending(Ogre::SBT_TRANSPARENT_ALPHA);
				pass->setCullingMode(Ogre::CULL_NONE);
				Ogre::TextureUnitState* state = pass->createTextureUnitState(style->getTextureName());
				state->setAlphaOperation(Ogre::LBX_MODULATE,Ogre::LBS_TEXTURE,Ogre::LBS_MANUAL,1.0,0.5);
				material->load();
			}

			VirtualMine::SpatialInterface::CGeoExtentionData* data = new VirtualMine::SpatialInterface::CGeoExtentionData();
			Ogre::ManualObject* renderObject = this->ref_mpSceneMgr->createManualObject(pro->getName());
			data->setExtentionData(renderObject);
	
			renderObject->begin(pro->getName() + "_material", Ogre::RenderOperation::OT_TRIANGLE_LIST);
			float height = 50;
			float angle = pro->getDipAngle();
			


			for (int i = 0;i<geometry->getCount()-1;i++)
			{
				Ogre::Vector3 curStartPt(geometry->getPoint(i).getX(),geometry->getPoint(i).getY(),geometry->getPoint(i).getZ()*(-1));
				Ogre::Vector3 curEndPt(geometry->getPoint(i+1).getX(),geometry->getPoint(i+1).getY(),geometry->getPoint(i+1).getZ()*(-1));
				Ogre::Vector3 curRotateAxis = curStartPt - curEndPt;
				curRotateAxis.normalise();

				Ogre::Vector3 rotateDir = Ogre::Vector3::UNIT_Y.crossProduct(curRotateAxis);
				rotateDir.normalise();
				Ogre::Quaternion qUp,qDown;
				qUp.FromAngleAxis(Ogre::Radian(Ogre::Degree(angle).valueRadians()),curRotateAxis);
				qDown.FromAngleAxis(Ogre::Radian(Ogre::Degree(-(180 - angle)).valueRadians()),curRotateAxis);
				for (int i = 0; i<geometry->getCount();i++)
				{
					Ogre::Vector3 midPt(geometry->getPoint(i).getX(),geometry->getPoint(i).getY(),geometry->getPoint(i).getZ()*(-1));
					Ogre::Vector3 upDir = qUp * rotateDir;
					Ogre::Vector3 upPt = midPt + upDir * height;

					Ogre::Vector3 downDir = qDown * rotateDir;
					Ogre::Vector3 downPt = midPt + downDir * height;

					renderObject->position(upPt);
					renderObject->textureCoord(0,i*(1.0/(geometry->getCount()-1)));
					renderObject->position(midPt);
					renderObject->textureCoord(0,i*(1.0/(geometry->getCount()-1)));
					renderObject->position(downPt);
					renderObject->textureCoord(0,i*(1.0/(geometry->getCount()-1)));
				}
			}

//			Ogre::Vector3 startPt(geometry->getPoint(0).getX(),geometry->getPoint(0).getY(),geometry->getPoint(0).getZ());
//			Ogre::Vector3 endPt(geometry->getPoint(geometry->getCount()-1).getX(),geometry->getPoint(geometry->getCount()-1).getY(),geometry->getPoint(geometry->getCount()-1).getZ());
//			Ogre::Vector3 rotateAxis = startPt - endPt;
//			rotateAxis.normalise();
//			
//			/*Ogre::Quaternion q(Ogre::Degree(angle),axis);
//			Ogre::Quaternion q2(Ogre::Degree(-angle),axis);*/
//			//q.FromAngleAxis(Ogre::Degree(angle),axis);
//#if 0
//			for (int i = 0; i<geometry->getCount();i++)
//			{
//				Ogre::Vector3 midPt(geometry->getPoint(i).getX(),geometry->getPoint(i).getY(),geometry->getPoint(i).getZ());
//				//midPt = q * midPt;
//				Ogre::Vector3 upPt = midPt + Ogre::Vector3(0,height,0);
//				upPt = q * upPt;
//				Ogre::Vector3 downPt = midPt - Ogre::Vector3(0,height,0);
//				downPt = q2 * downPt;
//				renderObject->position(upPt);
//				renderObject->textureCoord(0,i*(1.0/(geometry->getCount()-1)));
//				renderObject->position(midPt);
//				renderObject->textureCoord(0,i*(1.0/(geometry->getCount()-1)));
//				renderObject->position(downPt);
//				renderObject->textureCoord(0,i*(1.0/(geometry->getCount()-1)));
//			}
//#else
//			Ogre::Vector3 rotateDir = Ogre::Vector3::UNIT_Y.crossProduct(rotateAxis);
//			rotateDir.normalise();
//			Ogre::Quaternion qUp,qDown;
//			qUp.FromAngleAxis(Ogre::Radian(Ogre::Degree(angle).valueRadians()),rotateAxis);
//			qDown.FromAngleAxis(Ogre::Radian(Ogre::Degree(-(180 - angle)).valueRadians()),rotateAxis);
//			for (int i = 0; i<geometry->getCount();i++)
//			{
//				Ogre::Vector3 midPt(geometry->getPoint(i).getX(),geometry->getPoint(i).getY(),geometry->getPoint(i).getZ());
//				Ogre::Vector3 upDir = qUp * rotateDir;
//				Ogre::Vector3 upPt = midPt + upDir * height;
//
//				Ogre::Vector3 downDir = qDown * rotateDir;
//				Ogre::Vector3 downPt = midPt + downDir * height;
//
//				renderObject->position(upPt);
//				renderObject->textureCoord(0,i*(1.0/(geometry->getCount()-1)));
//				renderObject->position(midPt);
//				renderObject->textureCoord(0,i*(1.0/(geometry->getCount()-1)));
//				renderObject->position(downPt);
//				renderObject->textureCoord(0,i*(1.0/(geometry->getCount()-1)));
//			}
//
//#endif

			for (int i = 0;i<geometry->getCount()-1;i++)
			{
				for (int j =0; j<2;j++)
				{			
					renderObject->triangle(i*3+j,i*3+j+1,(i+1)*3+j);
					renderObject->triangle(i*3+j+1,(i+1)*3+j+1,(i+1)*3+j);
				}
			}

			renderObject->end();
			
			geoExtentionDatas.push_back(data);

		}
	}
}