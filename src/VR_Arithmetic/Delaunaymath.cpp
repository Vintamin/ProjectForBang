//#include "stdafx.h"


//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : 三维数字矿山平台
//  @ File Name : Delaunay.cpp
//  @ Date : 2015/6/18
//  @ Author : 王向上
//  @ Implement : 
//  @ Company : 中国矿业大学(北京)
//  @ Copyright:  2014-2020
//  @ Description : 
#include "vrmine/vr_arithmetic/arithmetic/Delaunaymath.h"
namespace VirtualMine
{
	namespace Arithmetic
	{
		Tri_Delaunay::Tri_Delaunay()
		{
			global_w = 0;
			global_h = 0;
		}

		Tri_Delaunay::~Tri_Delaunay()
		{

		}

		void Tri_Delaunay::Triangle_2(std::vector<De_point>& v)
		{
			for (std::vector<De_point>::iterator it=v.begin();it!=v.end(); ++it)//遍历V2
			{
				double x,y;
				x=it->X;
				y=it->Y;
				points_add_point(x,y);
			}
		}

		void Tri_Delaunay::points_add_point( double x, double y )
		{
			vertices.push_back( Point_GL( x, y ) );

		}

		std::vector<De_point> Tri_Delaunay::points_triangulation()
		{
			Delaunay dt;//Delaunay数据结构，代表当前数据的一个且仅有一个的三角剖分，详情请参考CGAL_manual

			dt.insert(vertices.begin(), vertices.end());//输入数据
			Delaunay::Finite_faces_iterator fit;//遍历Delaunay的所有面（有限面），将每个面的边画出来
			//std::vector<De_point> v1;
			De_point p1,p2,p3;
			for( fit = dt.finite_faces_begin(); fit != dt.finite_faces_end(); fit ++)
			{
				p1.X=fit->vertex(0)->point().hx();
				p1.Y=fit->vertex(0)->point().hy();
				v1.push_back( p1 );

				p2.X=fit->vertex(1)->point().hx();
				p2.Y=fit->vertex(1)->point().hy();
				v1.push_back( p2 );
				p3.X=fit->vertex(2)->point().hx();
				p3.Y=fit->vertex(2)->point().hy();
				v1.push_back( p3 );
			}

			return v1;
		}

		std::vector<De_point> Tri_Delaunay::Triangle_Delaunay(std::vector<De_point>& v)
		{
			Triangle_2(v);
			//count=v.size();
			return points_triangulation();
		}

		std::vector<De_point>   Tri_Delaunay::Triangle_D3(std::vector<De_point>& v3,std::vector<De_point>& v)
		{
			for (int i=0;i<v3.size();++i)
			{
				for (int j=0;j<v.size();++j)
				{
					if (v3.at(i).X==v.at(j).X&&v3.at(i).Y==v.at(j).Y)
					{
						vv.push_back(v.at(j));
					}
				}
			}

			return vv;
		}
	}
}