//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : 三维数字矿山平台
//  @ File Name : surface.cpp
//  @ Date : 2014/7/6
//  @ Author : 盛佳良
//  @ Implement : 
//  @ Company : 中国矿业大学(北京)
//  @ Copyright:  2014-2020
//  @ Description : 


#include "vrmine\vr_geometry\geometry\surface.h"
#include "vrmine\vr_spatialinterface\iscene.h"

using namespace VirtualMine::SpatialInterface;

namespace VirtualMine
{
	namespace Geometry
	{
		CSurface::CSurface()
		{

		}

		CSurface::~CSurface()
		{

		}

		void CSurface::addPoint(CPoint& point)
		{
			this->mXCoors.push_back(point.getX());
			this->mYCoors.push_back(point.getY());
			this->mZCoors.push_back(point.getZ());
		}

		void CSurface::addPoint(const double& x,const double& y,const double& z)
		{
			this->mXCoors.push_back(x);
			this->mYCoors.push_back(y);
			this->mZCoors.push_back(z);
		}

		size_t CSurface::getCount()
		{
			return this->mXCoors.size();
		}

		CPoint CSurface::getPoint(const size_t& index)
		{
			assert(index < this->mXCoors.size());
			CPoint p;
			p.setX(this->mXCoors[index]);
			p.setY(this->mYCoors[index]);
			p.setZ(this->mZCoors[index]);
			return p;
		}

		void CSurface::removePoint(const size_t& index)
		{
			assert(index < this->mXCoors.size());
			this->mXCoors.erase(this->mXCoors.begin() + index);
			this->mYCoors.erase(this->mYCoors.begin() + index);
			this->mZCoors.erase(this->mZCoors.begin() + index);
		}


		void CSurface::computeRectangle(CPoint& upLeftPoint,CPoint& downRightPoint)
		{
			if (this->getCount() == 0)
			{
				return;
			}
			upLeftPoint = this->getPoint(0);
			downRightPoint = this->getPoint(0);
			for (int i = 0; i<this->getCount();i++)
			{
				CPoint tempPoint = this->getPoint(i);
				if (tempPoint.getX() < upLeftPoint.getX())  upLeftPoint.setX(tempPoint.getX());
				if (tempPoint.getZ() < upLeftPoint.getZ())  upLeftPoint.setZ(tempPoint.getZ());
				if (tempPoint.getX() > downRightPoint.getX()) downRightPoint.setX(tempPoint.getX());
				if (tempPoint.getZ() > downRightPoint.getZ()) downRightPoint.setZ(tempPoint.getZ());
			}
		}

		void CSurface::toStream(VirtualMine::Core::CVRDataStream& datastream)
		{
			int count = mXCoors.size();

			datastream.wirteInt32(count);
			for (int i = 0; i < count; i++)
			{
				datastream.wirteReal(mXCoors[i]);
			}
			for (int i = 0; i < count; i++)
			{
				datastream.wirteReal(mYCoors[i]);
			}
			for (int i = 0; i <count; i++)
			{
				datastream.wirteReal(mZCoors[i]);
			}

			/////test
			//int testcount = 20;
			//datastream.wirteInt32(testcount);
			//for (int i = 0; i < testcount; i++)
			//{
			//	datastream.wirteReal(mXCoors[i]);
			//}
			//for (int i = 0; i <testcount; i++)
			//{
			//	datastream.wirteReal(mYCoors[i]);
			//}
			//for (int i = 0; i < testcount; i++)
			//{
			//	datastream.wirteReal(mZCoors[i]);
			//}

		}

		void CSurface::fromStream(VirtualMine::Core::CVRDataStream& datastream)
		{
			int length(0);
			datastream.readInt32(length);
			double x,y,z;
			for (int i = 0; i < length; i++)
			{
				datastream.readReal(x);
				x = x - IScene::ReferenceCenter.x; 
				mXCoors.push_back(x);
			}
			for (int i = 0; i < length; i++)
			{
				datastream.readReal(y);
				y -= IScene::ReferenceCenter.y;
				mYCoors.push_back(y);
				
			}
			for (int i = 0; i < length; i++)
			{
				datastream.readReal(z);
				z = z - IScene::ReferenceCenter.z;
				//z *= IScene::CoefficientOfCoordinateTransform;
				mZCoors.push_back(z); 
			}

		}


		CGrid::CGrid()
			:mRow(0),mCol(0)
		{
		
		}
		
		CGrid::CGrid(const int& row,const int& col,const double& resolution)
			:mRow(row),mCol(col),mResolution(resolution)
		{
		
		}
		
		CGrid::~CGrid()
		{
		
		}

		CPoint CGrid::getPoint(const int& rowIndex,const int& colIndex)
		{
			int index = rowIndex * mCol + colIndex;
			if (this->mPoints.size() > 0)
			{
				return this->mPoints[index];
			}
			return CSurface::getPoint(index);
		}

		void CGrid::setResolution(const double& resolution)
		{
			this->mResolution = resolution;
		}
		
		double CGrid::getResolution()
		{
			return this->mResolution;
		}
		
		void CGrid::setRow(const int& row)
		{
			this->mRow = row;
		}
		
		int CGrid::getRow()
		{
			return this->mRow;
		}
		
		void CGrid::setCol(const int& col)
		{
			this->mCol = col;
		}
		
		int CGrid::getCol()
		{
			return this->mCol;
		}

        void CGrid::toStream(VirtualMine::Core::CVRDataStream& datastream)
        {
			datastream.wirteInt32(mRow);
			datastream.wirteInt32(this->mCol);
		
			datastream.wirteReal(mResolution);
			CSurface::toStream(datastream);
        }

		void CGrid::fromStream(VirtualMine::Core::CVRDataStream& datastream)
		{
			//datastream.reseek(0);
			datastream.readInt32(mRow);
			datastream.readInt32(mCol);
		
			datastream.readReal(mResolution);
			CSurface::fromStream(datastream);

			/*if (this->mRow > 100)
			{
			for (int i = this->mRow-1 ; i >=0 ; --i)
			{
			for (int j = 0 ; j < this->mCol ; ++j)
			{
			int index = i * mCol + j;
			CPoint point = CSurface::getPoint(index);
			this->mPoints.push_back(point);
			}
			}
			}*/
		
		}


	}
}
