//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : 三维数字矿山平台
//  @ File Name : geospatialcontrol.cpp
//  @ Date : 2014/7/6
//  @ Author : 盛佳良
//  @ Implement : 
//  @ Company : 中国矿业大学(北京)
//  @ Copyright:  2014-2020
//  @ Description : 


#include "vrmine\vr_scenecontrol\geospatialcontrol.h"
#include "vrmine\vr_spatialengine\geocameraoperator.h"
#include "vrmine\vr_spatialengine\georayscenequery.h"
#include <float.h>
#include "vrmine/vr_core/coredefine.h"
#include "vrmine/vr_core/event.h"
#include "OGRE/Threading/OgreThreadDefines.h"
#include "OGRE/OgreMath.h"
#include "vrmine/vr_spatiallayer/lanwaylayer.h"
#include "vrmine/vr_spatiallayer/layerfactory.h"
#include "vrmine\vr_scenecontrol\geospatialscene.h"
#include "vrmine\vr_scenecontrol\scenehelper.h"
#include "vrmine\vr_core\event.h"
#include "vrmine\vr_spatialinterface\event\eventobject.h"
#include "OGRE\OgreTimer.h"
#include "vrmine\vr_mathenine\mathengine\mathcalculator.h"
#include "vrmine\vr_core\geodatatype.h"
#include "vrmine\vr_spatialengine\geoscenecamera.h"
#include "ogre/OgreFont.h"
#include "ogre/OgreFontManager.h"
#include "vrmine/vr_scenecontrol/widget.h"
#include "vrmine/vr_arithmetic/arithmetic/fault_meshcreator.h"

using namespace VirtualMine::SpatialEngine;
using namespace VirtualMine::Core;
using namespace VirtualMine::SpatialLayer;
using namespace VirtualMine::SpatialInterface;
using namespace Ogre;


#define  ElementSize 113

namespace VirtualMine
{
	namespace Scene
	{
		class CControlFrameListener : public Ogre::FrameListener
		{
		public:

			CControlFrameListener()
			{

			}

			CControlFrameListener(CGeoSpatialControl* ref_pControl)
				:ref_mpControl(ref_pControl)
			{

			}

			~CControlFrameListener()
			{

			}

			virtual bool frameStarted(const Ogre::FrameEvent& evt)
			{
				ref_mpControl->frameStarted(evt);
				return true;
			}

		public:
			CGeoSpatialControl* ref_mpControl;
		};

		class CGeoSpatialControl_PrivateData
		{
		public :
			CGeoSpatialControl_PrivateData(CGeoSceneManager* pGeoSceneManager,
				CGeoSceneCamera* pGeoSceneCamera)
				:ref_mpGeoSceneManager(pGeoSceneManager),
				ref_mpGeoSceneCamera(pGeoSceneCamera),
				mpCamaraOperator(NULL),mCameraDirection(Ogre::Vector3::UNIT_Z),
				ref_mpGeoSpatialScene(NULL),ref_mpCompassTexUnit(NULL),
				mSceneDetailIndex(0),ref_mpTool(NULL),mpFrameListener(NULL),
				mIsSkyVisible(true),mpCompusOverlayElement(NULL),mpRootWidget(new CWidget())
			{

			}
			~CGeoSpatialControl_PrivateData()
			{

			}

			void createInternalResource()
			{
				this->mpCamaraOperator = new CGeocameraOperator(this->ref_mpGeoSceneManager,ref_mpGeoSceneCamera);
				this->registerFactory();
			}

			void setPolygonMode()
			{
				this->mSceneDetailIndex = (this->mSceneDetailIndex + 1) % 2;
				switch(this->mSceneDetailIndex)
				{
				case 0 : this->ref_mpGeoSceneCamera->setPolygonMode(Ogre::PM_SOLID); break;
				case 1 : this->ref_mpGeoSceneCamera->setPolygonMode(Ogre::PM_WIREFRAME); break;
				}
			}

			void registerFactory()
			{
				CFactory* pFactory = new CLaneWayLayerFactory();
				CLayerFactoryRegister::getSingletonPtr()->registerFactory(pFactory);
				pFactory = new CImageLayerFactory();
				CLayerFactoryRegister::getSingletonPtr()->registerFactory(pFactory);
				pFactory = new CDemLayerFactory();
				CLayerFactoryRegister::getSingletonPtr()->registerFactory(pFactory);
				pFactory = new CDrillLayerFactory();
				CLayerFactoryRegister::getSingletonPtr()->registerFactory(pFactory);
				pFactory = new CCoalLayerFactory();
				CLayerFactoryRegister::getSingletonPtr()->registerFactory(pFactory);
				pFactory = new CMiningAreaLayerFactory();
				CLayerFactoryRegister::getSingletonPtr()->registerFactory(pFactory);
				pFactory = new CModelLayerFactory();
				CLayerFactoryRegister::getSingletonPtr()->registerFactory(pFactory);
				pFactory = new CWorkingplaneLayerFactory();
				CLayerFactoryRegister::getSingletonPtr()->registerFactory(pFactory);
				pFactory = new CFaultLayerFactory();
				CLayerFactoryRegister::getSingletonPtr()->registerFactory(pFactory); 
				pFactory = new CTerraneLayerFactory();
				CLayerFactoryRegister::getSingletonPtr()->registerFactory(pFactory);
			}

		public:
			//关于场景操作部分
			CGeoSceneManager* ref_mpGeoSceneManager;
			CGeocameraOperator* mpCamaraOperator;
			CGeoSceneCamera* ref_mpGeoSceneCamera;
			VirtualMine::SpatialInterface::ITool* ref_mpTool;
			Ogre::int32 mSceneDetailIndex;

			//关于可视化场景数据组织部分
			CGeoSpatialScene* ref_mpGeoSpatialScene;
			CEventQueue mUIEventQueue;
			CEvent* mpCurEvent;
			OGRE_MUTEX(mEventMutex);

			//关于场景控制屏幕widget
			CWidget* mpRootWidget;

			//关于场景查询
			std::vector<CSceneQueryListener*> mSceneQueryListeners;
			//关于场景帧监听
			CControlFrameListener* mpFrameListener;

			Ogre::Timer mTimer;
			Ogre::Vector3 mCameraDirection;
			Ogre::TextureUnitState* ref_mpCompassTexUnit;

			//关于天空
			bool mIsSkyVisible;
			PanelOverlayElement* mpCompusOverlayElement;

			friend class CGeoSpatialControl;
		};

		void CGeoSpatialControl::frameStarted(const Ogre::FrameEvent& evt)
		{
			CFrameEvent frameEvt;
			frameEvt.setTime(evt.timeSinceLastEvent,evt.timeSinceLastFrame);
			frameEvt.setCurTime(this->mpPrivate->mTimer.getMicroseconds());
			this->mpPrivate->mpCamaraOperator->handleEvent(&frameEvt);

			if (this->mpPrivate->ref_mpCompassTexUnit)
			{
				Ogre::Vector3 direction = this->mpGeoSceneCamera->getDirection();
				this->mpPrivate->mCameraDirection = direction;
				this->mpPrivate->mCameraDirection.y = 0;
				float anglefloat = VirtualMine::MathEngine::CMathCalculator::CalculateAngleOfTwoVector(this->mpPrivate->mCameraDirection,Ogre::Vector3(0,0,-1));
				this->mpPrivate->ref_mpCompassTexUnit->setTextureRotate(Ogre::Radian(anglefloat));
			}
		}

		CGeoSpatialControl::CGeoSpatialControl()
			:mpRoot(NULL),mpRenderWindow(NULL),
			mpGeoSceneCamera(NULL),mpGeoSceneManager(NULL),
			mpViewPort(NULL),mpPrivate(NULL),compass_upOverlay(NULL),isslider(false)
		{
			CSceneLoadHandler_CGeoSpatialControl* pSceneloadHandler = new CSceneLoadHandler_CGeoSpatialControl(this);
		}

		void CGeoSpatialControl::setSkyState(const bool& visible)
		{
			if (this->mpPrivate)
			{
				this->mpPrivate->mIsSkyVisible = visible;
				this->mpGeoSceneManager->setSkyDomeEnabled(this->mpPrivate->mIsSkyVisible);
			}
		}

		bool CGeoSpatialControl::getSkyState()
		{
			if (this->mpPrivate)
			{
				return this->mpPrivate->mIsSkyVisible;
			}
			return false;
		}

		CGeoSpatialControl::~CGeoSpatialControl()
		{

		}

		VirtualMine::SpatialEngine::CGeocameraOperator* CGeoSpatialControl::getGeocameraOperator()
		{
			return this->mpPrivate->mpCamaraOperator;
		}

		/*void CGeoSpatialControl::setcene(CGeoSpatialScene* ref_pScene)
		{
		if (this->mpPrivate)
		{
		this->mpPrivate->ref_mpGeoSpatialScene = ref_pScene;
		}
		}

		CGeoSpatialScene* CGeoSpatialControl::getScene()
		{
		if (this->mpPrivate)
		{
		return this->mpPrivate->ref_mpGeoSpatialScene;
		}
		}*/

		void CGeoSpatialControl::load(VirtualMine::SpatialInterface::IScene* ref_pScene)
		{
			this->setScene(ref_pScene);
			/*CSceneRenderEvent evt;
			evt.setGeoScene(ref_pScene);
			CEventDispatcher::setEvent(&evt);*/
			//this->mpPrivate->ref_mpGeoSpatialScene->draw();
		}

		void CGeoSpatialControl::unLoad()
		{
			this->setScene(NULL);
		}

		void CGeoSpatialControl::flyTo(const double& x ,const double& y , const double& z)
		{
			CFlyToEvent flyEvent;
			flyEvent.setFlyToPosition(Ogre::Vector3(x,y,z));
			flyEvent.setCurTime(this->mpPrivate->mTimer.getMicroseconds());
			this->mpPrivate->mpCamaraOperator->handleEvent(&flyEvent);
		}

		void CGeoSpatialControl::updateCamaraState()
		{

		}

		void CGeoSpatialControl::updateSceneState()
		{
			Ogre::Light* pLight = this->mpGeoSceneManager->getLight("defaultLight"); 
			pLight->setDirection(this->mpGeoSceneCamera->getDirection()); 
			pLight->setPosition(this->mpGeoSceneCamera->getPosition()); 
		}

		void CGeoSpatialControl::upateOneFrame()
		{
			if (NULL != this->mpRoot && NULL != this->mpRenderWindow)
			{
				this->handleEvent();
				this->updateSceneState();
				this->mpRoot->renderOneFrame();
			}
		}

		void CGeoSpatialControl::initialScene()
		{
			////创建灯光
			Ogre::Light* pLight = this->mpGeoSceneManager->createLight("defaultLight"); 
			pLight->setType(Ogre::Light::LT_DIRECTIONAL); 
			pLight->setDiffuseColour(1.0,1.0,1.0); 
			Ogre::Vector3 lightPos(150,150,150);
			Ogre::Vector3 dir = lightPos * (- 1);
			dir.normalise();
			pLight->setDirection(dir); 
			pLight->setPosition(lightPos); 
			////light->setSpotlightRange(Degree(15), Degree(15)); 
			//mSceneMgr->setAmbientLight(Ogre::ColourValue(0.8, 0.8, 0.8));  // dim ambient lighting
			//Set ambient light off
			this->mpGeoSceneManager->setAmbientLight(Ogre::ColourValue(1,1,1));


			mpGeoSceneManager->setSkyDome(true, "VRMine/CloudySky",10.0,8.0,
				5,true,Ogre::Quaternion::IDENTITY,16,16,-1,Ogre::String(
				VirtualMine::Core::VR_MINE_DEFAULT_RESOURCE_GROUP.c_str()));
			//this->mpGeoSceneManager->setSkyBox(true,"Examples/MorningSkyBox");

			Ogre::OverlayElement* pushbackBtnPic =Ogre:: OverlayManager::getSingleton().createOverlayElement("Panel","pushbackBtnPic");
			pushbackBtnPic->setParameter("metrics_mode","pixels");
			pushbackBtnPic->setParameter("left","0");
			pushbackBtnPic->setParameter("top","240");
			//pushbackBtnPic->setParameter("top",StringConverter::toString(this->getRenderWindow()->getHeight()/2).c_str());
			pushbackBtnPic->setParameter("width","16");
			pushbackBtnPic->setParameter("height","71");
			pushbackBtnPic->setMaterialName("pushbackBtn_leftbtn");

		//	mppushbackBtn = Ogre::OverlayManager::getSingleton().create("pushbackBtnPic_Overlay");
		//	mppushbackBtn->add2D((Ogre::OverlayContainer*)pushbackBtnPic);

			//界面指北针导航widget
			//CCompassWidget* pCompassWidget = new CCompassWidget(this);
			//this->mpPrivate->mpRootWidget->addChildWidget(pCompassWidget);
			//this->mpPrivate->mpRootWidget->initialise();
			//pCompassWidget->initialise();
			//return;

#if 1 加载导航  
			Ogre::OverlayElement* compassPic =Ogre:: OverlayManager::getSingleton().createOverlayElement("Panel","compassPic");

			compassPic->setParameter("metrics_mode","pixels");
			compassPic->setParameter("left","32");
			compassPic->setParameter("top","19");
			compassPic->setParameter("width","69");
			compassPic->setParameter("height","258");
			compassPic->setMaterialName("compass");

			compassOverlay =Ogre::OverlayManager::getSingleton().create("Overlay");
			compassOverlay->add2D((Ogre::OverlayContainer*)compassPic);
			compassOverlay->show();

			Ogre::OverlayElement* compass_silderPic=Ogre::OverlayManager::getSingleton().createOverlayElement("Panel","compass_slider");
			compass_silderPic->setParameter("metrics_mode","pixels");
			//compass_silderPic->setLeft(this->mpRenderWindow->getWidth()-150);
			compass_silderPic->setParameter("left","56");
			compass_silderPic->setParameter("top","169");
			compass_silderPic->setParameter("width","22");
			compass_silderPic->setParameter("height","17");
			compass_silderPic->setMaterialName("compass_slider");

			compass_silderOverlay=Ogre::OverlayManager::getSingleton().create("compass_silderOverlay");
			compass_silderOverlay->add2D((Ogre::OverlayContainer*)compass_silderPic);
			compass_silderOverlay->show();
			
#endif


#if 1 加载compass_up、down、left、right 并设置不显示


			//compass_up
			Ogre::OverlayElement* compass_up=Ogre::OverlayManager::getSingleton().createOverlayElement("Panel","compass_up");
			compass_up->setParameter("metrics_mode","pixels");
			compass_up->setParameter("left","61");
			compass_up->setParameter("top","38");
			compass_up->setParameter("width","14");
			compass_up->setParameter("height","14");
			compass_up->setMaterialName("compass_up");

			compass_upOverlay = Ogre::OverlayManager::getSingleton().create("compass_upOverlay");
			compass_upOverlay->add2D((Ogre::OverlayContainer*)compass_up);


			//compass_down
			Ogre::OverlayElement* compass_down=Ogre::OverlayManager::getSingleton().createOverlayElement("Panel","compass_down");
			compass_down->setParameter("metrics_mode","pixels");
			compass_down->setParameter("left","61");
			compass_down->setParameter("top","63");
			compass_down->setParameter("width","14");
			compass_down->setParameter("height","14");
			compass_down->setMaterialName("compass_down");

			compass_downOverlay = Ogre::OverlayManager::getSingleton().create("compass_downOverlay");
			compass_downOverlay->add2D((Ogre::OverlayContainer*)compass_down);


			//compass_left
			Ogre::OverlayElement* compass_left=Ogre::OverlayManager::getSingleton().createOverlayElement("Panel","compass_left");
			compass_left->setParameter("metrics_mode","pixels");
			compass_left->setParameter("left","47");
			compass_left->setParameter("top","50");
			compass_left->setParameter("width","14");
			compass_left->setParameter("height","14");
			compass_left->setMaterialName("compass_left");

			compass_leftOverlay = Ogre::OverlayManager::getSingleton().create("compass_leftOverlay");
			compass_leftOverlay->add2D((Ogre::OverlayContainer*)compass_left);


			//compass_right
			Ogre::OverlayElement* compass_right=Ogre::OverlayManager::getSingleton().createOverlayElement("Panel","compass_right");
			compass_right->setParameter("metrics_mode","pixels");
			compass_right->setParameter("left","71");
			compass_right->setParameter("top","50");
			compass_right->setParameter("width","14");
			compass_right->setParameter("height","14");
			compass_right->setMaterialName("compass_right");

			compass_rightOverlay = Ogre::OverlayManager::getSingleton().create("compass_rightOverlay");
			compass_rightOverlay->add2D((Ogre::OverlayContainer*)compass_right);


			
			//outText

			Ogre::FontManager::getSingleton().getByName("MyFont")->load();

			this->outTextElement = Ogre::OverlayManager::getSingleton().createOverlayElement("TextArea","outTxt");
			//outTextElement->setParameter("metrics_mode","pixels");
			outTextElement->setMetricsMode(GuiMetricsMode::GMM_PIXELS);
			outTextElement->setDimensions(1.0, 1.0);

			int heiht = this->getRenderWindow()->getHeight();
			outTextElement->setParameter("left","0.001");
		 	//outTextElement->setParameter("top","560");
			outTextElement->setParameter("top","587");/////爆破系统
			outTextElement->setParameter("width","1500");
			outTextElement->setParameter("height","16");
			//outTextElement->setPosition(100,100);
			outTextElement->setParameter("font_name","MyFont");
			outTextElement->setParameter("char_height", "16");
			outTextElement->setParameter("horz_align", "left");


		

			//DisplayString str;
			//   str.append("X:  , Y:  , Z:  ");
		outTextElement->setCaption("X: 0 ,Y:  0,Z:  0");
			//outTextElement->setCaption(str);
			outTextElement->setColour(ColourValue::White);

			outTextOverlay = Ogre::OverlayManager::getSingleton().create("outTextOverlay");
			outTextOverlay->add2D((Ogre::OverlayContainer*)outTextElement);
			outTextOverlay->show();
			
#endif



#if 0
			// 平面create a plane 
			Ogre::Plane shadowPlane(Ogre::Vector3::UNIT_Y,0);
			Ogre::MeshManager::getSingleton().createPlane("ground",
				Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,shadowPlane,400000,400000,20,20,true,1,5,5,Ogre::Vector3::UNIT_Z);
			Ogre::Entity* ent = this->mpGeoSceneManager->createEntity("GroundEntity", "ground");
			Ogre::String matName("Examples/Rockwall");
			ent->setMaterialName(matName);//("Examples/Rockwall");Ocean2_Cg
			Ogre::MaterialPtr groundMaterial = ::Ogre::MaterialManager::getSingletonPtr()->getByName(matName);
			if (!groundMaterial->isLoaded())
			{
				groundMaterial->load();
			}
			groundMaterial->getTechnique(0)->getPass(0)->setCullingMode(Ogre::CULL_NONE);
			ent->setCastShadows(false);
			this->mpGeoSceneManager->getRootSceneNode()->createChildSceneNode()->attachObject(ent);
			ent->getParentNode()->translate(0,-5000,0);
			//ent->getParentNode()->rotate(Ogre::Vector3::UNIT_X,Ogre::Radian(1.57f));
			/*this->mpGeoSceneManager->setWorldGeometry("terrain.cfg");*/

			//CRayListener* pListener = new CRayListener();
			//pListener->ref_mpControl = this;
			//this->mpRoot->addFrameListener(pListener);
#endif
			std::string compusName("compusName");
			std::string compusElementName("compusElementName");

			Ogre::Overlay* compusOverlay = OverlayManager::getSingleton().create(compusName);
			this->mpPrivate->mpCompusOverlayElement = (PanelOverlayElement*)(OverlayManager::getSingleton().createOverlayElement("Panel",compusElementName));
			this->mpPrivate->mpCompusOverlayElement->setHeight(ElementSize);
			this->mpPrivate->mpCompusOverlayElement->setWidth(ElementSize);
			this->mpPrivate->mpCompusOverlayElement->setMetricsMode(GMM_PIXELS);

			this->mpPrivate->mpCompusOverlayElement->setTop(0);
			this->mpPrivate->mpCompusOverlayElement->setLeft(10);

			int  cx   =  GetSystemMetrics( SM_CXFULLSCREEN );
			int  cy   =  GetSystemMetrics( SM_CYFULLSCREEN );
			Ogre::Real lef = this->mpRenderWindow->getWidth();

			if (this->mpRenderWindow->getWidth() > 200)
			{
				this->mpPrivate->mpCompusOverlayElement->setLeft(this->mpRenderWindow->getWidth() - 150);
			}
			this->mpPrivate->mpCompusOverlayElement->setCaption(Ogre::DisplayString("adb"));

			compusOverlay->add2D(this->mpPrivate->mpCompusOverlayElement);
			compusOverlay->show();



#if 1

			MaterialPtr matPtr = MaterialManager::getSingletonPtr()->create(compusElementName,Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
			Pass* pass = matPtr->getTechnique(0)->getPass(0);
			pass->setLightingEnabled(false);
			pass->setSceneBlending(SBT_TRANSPARENT_ALPHA);
			Ogre::String texName("compusTexture");

			Ogre::Image image;
			image.load("compus.png",Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);

			TexturePtr texPtr = TextureManager::getSingletonPtr()->create(texName,Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
			if (!texPtr.isNull())
			{
				texPtr->loadImage(image);
				this->mpPrivate->ref_mpCompassTexUnit = pass->createTextureUnitState(texName,0);
				this->mpPrivate->ref_mpCompassTexUnit->setTextureCoordSet(0);

				this->mpPrivate->mCameraDirection.y = 0;

				float anglefloat = VirtualMine::MathEngine::CMathCalculator::CalculateAngleOfTwoVector(this->mpPrivate->mCameraDirection,Ogre::Vector3(0,0,-1));

				this->mpPrivate->ref_mpCompassTexUnit->setTextureRotate(Ogre::Radian(-anglefloat));

				this->mpPrivate->ref_mpCompassTexUnit->setColourOperation(LBO_REPLACE);
				this->mpPrivate->ref_mpCompassTexUnit->setTextureFiltering(FO_LINEAR,FO_LINEAR,FO_LINEAR);
				this->mpPrivate->mpCompusOverlayElement->setMaterialName(matPtr->getName());
				this->mpPrivate->mpCompusOverlayElement->setUV(0,0,1,1);
				this->mpPrivate->mpCompusOverlayElement->setHorizontalAlignment(GHA_LEFT);
				this->mpPrivate->mpCompusOverlayElement->setVerticalAlignment(GVA_TOP);
			}


#endif
			

		}

		void CGeoSpatialControl::setupResources()
		{
			//加载资源
			Ogre::ConfigFile cf;
#ifdef _DEBUG
			cf.load(mResourcePath + "resources_d.cfg");
#else
			cf.load(mResourcePath + "resources.cfg");
#endif
			Ogre::ConfigFile::SectionIterator seci = cf.getSectionIterator();
			Ogre::String secName, typeName, archName;
			while(seci.hasMoreElements())
			{
				secName = seci.peekNextKey();
				Ogre::ConfigFile::SettingsMultiMap *settings = seci.getNext();
				Ogre::ConfigFile::SettingsMultiMap::iterator i =settings->begin();
				for(;i!= settings->end();++i)
				{
					typeName = i->first;
					archName = i->second;
					Ogre::ResourceGroupManager::getSingleton().addResourceLocation(
						archName,
						typeName,
						secName
						);
				}
			}
		}

		Ogre::RenderWindow* CGeoSpatialControl::getRenderWindow()
		{
			return this->mpRenderWindow;
		}

		void CGeoSpatialControl::setupWindowView(const size_t& HWND,const int& width,const int& height)
		{
			if (NULL == this->mpRenderWindow)
			{
				Ogre::String  pluginsPath;
#ifdef _DEBUG
				pluginsPath = this->mResourcePath + "plugins_d.cfg"; 
#else
				pluginsPath = this->mResourcePath + "plugins.cfg"; 
#endif
				//构造根结点
				this->mpRoot = OGRE_NEW Ogre::Root(pluginsPath, 
					mConfigPath + "ogre.cfg", mResourcePath + "Ogre.log");
				this->setupResources();
				if (!this->mpRoot->restoreConfig())
				{
					//要处理成自定义配置对话框
					//暂时先用Ogre自带的对话框
					if (!this->mpRoot->showConfigDialog())
						return ;
				}
				this->mpRoot->initialise(false);
				CGeoSceneManagerFactory* pGeoSceneManager = new CGeoSceneManagerFactory();
				this->mpRoot->addSceneManagerFactory(pGeoSceneManager);

				Ogre::NameValuePairList params;
				params["left"] = "0";
				params["top"] = "0";
				params["border"] = "none";//parentWindowHandle
				params["externalWindowHandle"] = Ogre::StringConverter::toString(HWND);
				this->mpRenderWindow = this->mpRoot->createRenderWindow("vrSceneView",width,height,false,&params);
				//this->mpRenderWindow = this->mpRoot->createRenderWindow("vrSceneView",width,height,false);
			}
			//初始化场景管理器
			this->mpGeoSceneManager = dynamic_cast<CGeoSceneManager*>(this->mpRoot->createSceneManager("CGeoSceneManager","geoSceneManager"));
			//VirtualMine:: // ::getSingletonPtr()->setGeoSceneManager(mpGeoSceneManager);
			//初始化相机
			Ogre::Camera* pCamera = this->mpGeoSceneManager->createCamera(CGeoSceneCamera::DEFAULT_CAMERA_NAME);
			this->mpGeoSceneCamera = static_cast<CGeoSceneCamera*>(pCamera);
			this->mpGeoSceneCamera->setPosition(Ogre::Vector3(0,300,400));
			this->mpGeoSceneCamera->lookAt(Ogre::Vector3(0,0,0));
			//近裁剪面距离，不能修改（修改之后会影响射线选中）
			this->mpGeoSceneCamera->setNearClipDistance(0.01);//值为2时选中准确，为0.01时不闪烁

			//初始化视口
			// Create one viewport, entire window
			this->mpViewPort = this->mpRenderWindow->addViewport(this->mpGeoSceneCamera);
			this->mpViewPort->setBackgroundColour(Ogre::ColourValue(0.3,0.3,0.3,1));

			// Alter the camera aspect ratio to match the viewport
			this->mpGeoSceneCamera->setAspectRatio(
				Ogre::Real(this->mpViewPort->getActualWidth()) / Ogre::Real(this->mpViewPort->getActualHeight()));

			this->mpGeoSceneManager->setCameraRelativeRendering(true);

#if 1
			Ogre::ResourceGroupManager::getSingleton().initialiseAllResourceGroups();
			//
#endif
			Ogre::TextureManager::getSingleton().setDefaultNumMipmaps(5);
			//初始化内部对象
			this->mpPrivate = new CGeoSpatialControl_PrivateData(this->mpGeoSceneManager,this->mpGeoSceneCamera);
			this->mpPrivate->mpFrameListener = new CControlFrameListener(this);
			this->mpRoot->addFrameListener(this->mpPrivate->mpFrameListener);
			this->mpPrivate->createInternalResource();
			this->initialScene();
		}

		CGeoSceneManager* CGeoSpatialControl::getGeoSceneManager()
		{
			return this->mpGeoSceneManager;
		}

		CGeoSceneCamera* CGeoSpatialControl::getGeoSceneCamera()
		{
			return this->mpGeoSceneCamera;
		}

		void CGeoSpatialControl::updateVRScene()
		{
			this->upateOneFrame();
		}

		void CGeoSpatialControl::mouseReleaseEvent(const int& x ,const int& y , const int& button)
		{
			VirtualMine::Core::CMouseEvent evt(CEvent::MouseButtonRelease);
			evt.setX(x);
			evt.setY(y);
			evt.setButton(button);
			if (this->mpPrivate->ref_mpTool != NULL)
			{
				this->mpPrivate->ref_mpTool->handleEvent(&evt);
			}
			this->mpPrivate->mpCamaraOperator->mouseReleaseEvent(x,y,button);


			isslider=false;
			compass_silderOverlay->getChild("compass_slider")->setParameter("top","169");
		}

		void CGeoSpatialControl::mousePressEvent(const int& x ,const int& y , const int& button)
		{
			bool hasAccepted = false;
#pragma region 指北针导航
			if ((61<x && x<70) && (38<y && y<50))
			{
				//this->getGeocameraOperator()->zoomAt(Ogre::Vector3::ZERO,100);
				Ogre::Vector3 compasscoor = this->getGeoSceneCamera()->getPosition();
				this->getGeoSceneCamera()->setPosition(compasscoor.x,compasscoor.y+10,compasscoor.z);

			}
			else if((61<x && x<70) && (63<y && y<77))
			{
				//this->getGeoSceneCamera()->getPosition()
				Ogre::Vector3 compasscoor = this->getGeoSceneCamera()->getPosition();
				this->getGeoSceneCamera()->setPosition(compasscoor.x,compasscoor.y-10,compasscoor.z);
			}
			else if((47<x && x<61) && (50<y && y<64))
			{
				Ogre::Vector3 compasscoor = this->getGeoSceneCamera()->getPosition();
				this->getGeoSceneCamera()->setPosition(compasscoor.x-10,compasscoor.y,compasscoor.z);

			}
			else if((71<x && x<83) && (50<y && y<64))
			{
				Ogre::Vector3 compasscoor = this->getGeoSceneCamera()->getPosition();
				this->getGeoSceneCamera()->setPosition(compasscoor.x+10,compasscoor.y,compasscoor.z);

			}
			else if ((61<x && x<70) && (95<y && y<102))    // ZoomIn
			{
				this->getGeocameraOperator()->zoomAt(Ogre::Vector3::ZERO,100);
			}
			else if ((61<x && x<70) && (255<y && y<262))  // ZoomOut
			{
				this->getGeocameraOperator()->zoomAt(Ogre::Vector3::ZERO,-100);
			}
#pragma endregion	

#pragma region 指北针silder移动

			if ((55<x && x<73) && (169<y && y<187))
			{
				isslider=true;

			}

#pragma  endregion


			VirtualMine::Core::CMouseEvent evt(CEvent::MouseButtonPress);
			evt.setX(x);
			evt.setY(y);
			evt.setButton(button);
			if (this->mpPrivate->mpRootWidget->handleEvent(&evt))
				return ;

			if (this->mpPrivate->ref_mpTool != NULL)
			{
				this->mpPrivate->ref_mpTool->handleEvent(&evt);
			}
			this->mpPrivate->mpCamaraOperator->mousePressEvent(x,y,button);
		}

		void CGeoSpatialControl::mouseDoubleClickEvent(const int& x ,const int& y , const int& button)
		{
			bool hasAccepted = false;
#pragma region 指北针导航
			if ((61<x && x<70) && (38<y && y<50))
			{
				//this->getGeocameraOperator()->zoomAt(Ogre::Vector3::ZERO,100);
				Ogre::Vector3 compasscoor = this->getGeoSceneCamera()->getPosition();
				this->getGeoSceneCamera()->setPosition(compasscoor.x,compasscoor.y-10,compasscoor.z);
				hasAccepted = true;
			}
			else if((61<x && x<70) && (63<y && y<77))
			{
				//this->getGeoSceneCamera()->getPosition()
				Ogre::Vector3 compasscoor = this->getGeoSceneCamera()->getPosition();
				this->getGeoSceneCamera()->setPosition(compasscoor.x,compasscoor.y+10,compasscoor.z);
				hasAccepted = true;
			}
			else if((47<x && x<61) && (50<y && y<64))
			{
				Ogre::Vector3 compasscoor = this->getGeoSceneCamera()->getPosition();
				this->getGeoSceneCamera()->setPosition(compasscoor.x-10,compasscoor.y,compasscoor.z);
				hasAccepted = true;
			}
			else if((71<x && x<83) && (50<y && y<64))
			{
				Ogre::Vector3 compasscoor = this->getGeoSceneCamera()->getPosition();
				this->getGeoSceneCamera()->setPosition(compasscoor.x+10,compasscoor.y,compasscoor.z);
				hasAccepted = true;
			}
			else if ((61<x && x<70) && (95<y && y<102))    // ZoomIn
			{
				this->getGeocameraOperator()->zoomAt(Ogre::Vector3::ZERO,100);
				hasAccepted = true;
			}
			else if ((61<x && x<70) && (255<y && y<262))  // ZoomOut
			{
				this->getGeocameraOperator()->zoomAt(Ogre::Vector3::ZERO,-100);
				hasAccepted = true;
			}
#pragma endregion	

#pragma region 指北针silder移动

			if ((55<x && x<73) && (169<y && y<187))
			{
				hasAccepted = true;
			}

			if (hasAccepted)
				return;
#pragma  endregion

			VirtualMine::Core::CMouseEvent evt(CEvent::MouseButtonDblClick);
			evt.setX(x);
			evt.setY(y);
			evt.setButton(button);
			if (this->mpPrivate->mpRootWidget->handleEvent(&evt))
				return ;
			if (button == 1)
			{
				Ogre::Vector3 p;
				this->mpGeoSceneManager->getRayIntersectedPoint(x,y,p);
				CFlyToEvent flyEvent;
				flyEvent.setFlyToPosition(p);
				flyEvent.setCurTime(this->mpPrivate->mTimer.getMicroseconds());
				this->mpPrivate->mpCamaraOperator->handleEvent(&flyEvent);
			}
		}

		void CGeoSpatialControl::mouseMoveEvent(const int& x ,const int& y, const int& button)
		{
			bool hasAccepted = false;
#pragma region 指北针导航
			//加载compass_up down left right
			if ((61<x && x<70) && (38<y && y<50))
			{
				compass_upOverlay->show();
				hasAccepted = true;

			}
			else if((61<x && x<70) && (63<y && y<77))
			{
				compass_downOverlay->show();
				hasAccepted = true;
			}
			else if((47<x && x<61) && (50<y && y<64))
			{
				compass_leftOverlay->show();
				hasAccepted = true;
			}
			else if((71<x && x<83) && (50<y && y<64))
			{
				compass_rightOverlay->show();
				hasAccepted = true;
			}
			else if (0<x && x<17)
			{
				//mppushbackBtn->show();
				hasAccepted = true;
			}
			else
			{
				compass_upOverlay->hide();
				compass_downOverlay->hide();
				compass_leftOverlay->hide();
				compass_rightOverlay->hide();
			//	mppushbackBtn->hide();

			}


#pragma endregion 

#pragma region 指北针silder移动
			if (isslider)
			{

				int y_temp=StringConverter::parseInt(compass_silderOverlay->getChild("compass_slider")->getParameter("top"));
				compass_silderOverlay->getChild("compass_slider")->setParameter("top",StringConverter::toString(y).c_str());

				if (y<y_temp)
				{
					this->getGeocameraOperator()->zoomAt(Ogre::Vector3::ZERO,100);
				}
				else if (y>y_temp)
				{
					this->getGeocameraOperator()->zoomAt(Ogre::Vector3::ZERO,-100);
				}
				if (y<100)
				{
					compass_silderOverlay->getChild("compass_slider")->setParameter("top","100");

				}
				if (y>239)
				{
					compass_silderOverlay->getChild("compass_slider")->setParameter("top","239");

				}
				hasAccepted = true;
			}

#pragma endregion




			VirtualMine::Core::CMouseEvent evt(CEvent::MouseMove);
			evt.setX(x);
			evt.setY(y);
			evt.setButton(button);
			if (this->mpPrivate->mpRootWidget->handleEvent(&evt))
				return ;

			if (this->mpPrivate->ref_mpTool != NULL)
			{
				this->mpPrivate->ref_mpTool->handleEvent(&evt);
			}
			if (!hasAccepted)
				this->mpPrivate->mpCamaraOperator->mouseMoveEvent(x,y,button);
		}

		void CGeoSpatialControl::wheelEvent(const int& x ,const int& y , const int& delta)
		{
			VirtualMine::Core::CMouseEvent evt(CEvent::Wheel);
			evt.setX(x);
			evt.setY(y);
			evt.setDelta(delta);
			if (this->mpPrivate->mpRootWidget->handleEvent(&evt))
				return ;
			if (this->mpPrivate->ref_mpTool != NULL)
			{
				this->mpPrivate->ref_mpTool->handleEvent(&evt);
			}
			//kk源码
			this->mpPrivate->mpCamaraOperator->wheelEvent(x,y,delta);
#if 0
			Ogre::Vector3 camPos = this->getGeoSceneManager()->getDefaultCamera()->getPosition();
		
			if (!this->getScene()->getImageLayer())
			{
				return;
			}
			Ogre::Vector3 imagePos = dynamic_cast<CImageLayer*>(this->getScene()->getImageLayer())->getRenderableObject()->getNode()->getPosition();
			Ogre::Real distance = (camPos - imagePos).length();
			if (distance > 300)
			{
				int count = this->getScene()->getLayerCount();
				LayerMap layerMap = this->getScene()->getLayerMap();
				LayerMap::iterator itr = layerMap.begin();
				while(itr != layerMap.end())
				{
					VirtualMine::SpatialInterface::ILayer* player = itr->second;

					if (player->getType() == VirtualMine::Core::GeoDataType::GDT_COALSEAM)
					{
					
							player->setVisible(false);
					}

					itr++;
				}
			}
				
			
#endif
		
		}

		void CGeoSpatialControl::keyPressEvent(const int& key)
		{
			VirtualMine::Core::CKeyEvent evt(CEvent::KeyPress);
			evt.setKey(key);
			if (this->mpPrivate->ref_mpTool != NULL)
			{
				this->mpPrivate->ref_mpTool->handleEvent(&evt);
			}
			if (!evt.isAccepted())
			{
				this->mpPrivate->mpCamaraOperator->keyPressEvent(key);
				switch(key)
				{
				case 82:
					{
						this->mpPrivate->setPolygonMode();
						break;
					}
				case 32:
					{
						this->mpPrivate->mpCamaraOperator->resetCamera();


						////空格键，飞到场景中心

						break;
					}
				}
			}
			this->updateVRScene();
		}

		void CGeoSpatialControl::setScene(VirtualMine::SpatialInterface::IScene* ref_pScene)
		{
			if (ref_pScene == NULL)
			{
				this->mpPrivate->ref_mpGeoSpatialScene = NULL;
			}
			else
			{
				ref_pScene->setGeoSceneManager(this->mpGeoSceneManager);
				this->mpPrivate->ref_mpGeoSpatialScene = dynamic_cast<CGeoSpatialScene*>(ref_pScene);
			}
			//
			CControlInitialEvent evt;
			evt.setBindingObject(this);
			CEventDispatcher::setEvent(&evt);
		}

		VirtualMine::SpatialInterface::IScene* CGeoSpatialControl::getScene()
		{
			return this->mpPrivate->ref_mpGeoSpatialScene;
		}

		void beforeRayQuery()
		{

		}

		void CGeoSpatialControl::afterRayQuery(Ogre::RaySceneQueryResultEntry& resultObject)
		{
			std::vector<CSceneQueryListener*>::iterator bItr = this->mpPrivate->mSceneQueryListeners.begin();
			std::vector<CSceneQueryListener*>::iterator eItr = this->mpPrivate->mSceneQueryListeners.end();
			while (bItr != eItr)
			{
				(*bItr)->onRayQuery(resultObject);
				++bItr;
			}
		}

		double CGeoSpatialControl::getSlope(const double& x,const double& y,const double& z)
		{
			if (this->mpPrivate->ref_mpGeoSpatialScene)
			{
				CDemLayer* pDemLayer = dynamic_cast<CDemLayer*>(this->mpPrivate->ref_mpGeoSpatialScene->getDemLayer());
				return pDemLayer->getSlope(x,y,z);
			}
			return DBL_MAX;
		}

		double CGeoSpatialControl::getHeight(const double& x,const double& z)
		{
			if (this->mpPrivate->ref_mpGeoSpatialScene)
			{
				/*CImageLayer* pImageLayer = dynamic_cast<CImageLayer*>(this->mpPrivate->ref_mpGeoSpatialScene->getImageLayer());
				return pImageLayer->getHeight(x,z);*/
				CDemLayer* pDemLayer = (CDemLayer*)(this->mpPrivate->ref_mpGeoSpatialScene->getDemLayer());
				if (pDemLayer)
				{
					return pDemLayer->getHeight(x,z);
				}
			}
			return 0;
		}

		void CGeoSpatialControl::resizeEvent(const int& width,const int& height)
		{
			if (this->mpRenderWindow)
			{
				this->mpRenderWindow->windowMovedOrResized();
				this->mpGeoSceneCamera->setAspectRatio(Ogre::Real(width) / Ogre::Real(height));
				this->mpRenderWindow->resize(width,height);
				int heightInt = mpRenderWindow->getHeight();
				int widthInt = mpRenderWindow->getWidth();
				
				std::string hei = Ogre::StringConverter::toString(heightInt -10);
				this->outTextElement->setParameter("top",hei.c_str());

				if (this->mpRenderWindow->getWidth() > 200)
				{
					//this->mpPrivate->mpCompusOverlayElement->setLeft(this->mpRenderWindow->getWidth() - 150);


				}
#if 0

				///
				if (this->getScene())
				{
					if (this->getScene()->getImageLayer())
					{
						dynamic_cast<CImageLayer* >(this->getScene()->getImageLayer())->resetResource();
					}
				}

#endif		
				
			}
		}

		void CGeoSpatialControl::handleEvent()
		{
			/*OGRE_LOCK_MUTEX(this->mpPrivate->mEventMutex);
			{
			EventVector& events = this->mpPrivate->mUIEventQueue;
			EventVector::iterator bItr = events.begin();
			EventVector::iterator eItr = events.end();
			while(bItr != eItr)
			{
			CEvent* pEvent = *bItr;
			if (this->mpPrivate->mpCamaraOperator->handleEvent(pEvent))
			{
			pEvent->setHandled(true);

			}
			++bItr;
			}

			this->mpPrivate->mUIEventQueue.clear();
			}*/

		}

		void CGeoSpatialControl::timerEvent()
		{
		}

		void CGeoSpatialControl::setCurrentFlyPath()
		{

		}

		void CGeoSpatialControl::getCurrentFlyPath()
		{

		}

		VirtualMine::SpatialInterface::IWidget* CGeoSpatialControl::getRootWidget()
		{
			return this->mpPrivate->mpRootWidget;
		}

		void CGeoSpatialControl::startFly()
		{

		}

		void CGeoSpatialControl::stopFly()
		{

		}

		void CGeoSpatialControl::pauseFly()
		{

		}

		void CGeoSpatialControl::continueFly()
		{

		}

		void CGeoSpatialControl::setCurrentTool(VirtualMine::SpatialInterface::ITool* pTool )
		{
			if (pTool == NULL)
			{
				this->mpPrivate->ref_mpTool = pTool;
			}
			else
			{
				if (this->mpPrivate->ref_mpTool != NULL)
				{
					throw std::exception("current tool is working , you must set it NULL !");
				}
				else
				{
					this->mpPrivate->ref_mpTool = pTool;
				}
			}
		}

		VirtualMine::SpatialInterface::ITool* CGeoSpatialControl::getCurrentTool()
		{
			return this->mpPrivate->ref_mpTool;
		}

		void CGeoSpatialControl::addSceneQueryListener(CSceneQueryListener* ref_SceneQueryListener)
		{
			this->mpPrivate->mSceneQueryListeners.push_back(ref_SceneQueryListener);
		}

		void CGeoSpatialControl::removeSceneQueryListener(CSceneQueryListener* ref_SceneQueryListener)
		{
			std::vector<CSceneQueryListener*>::iterator bItr = this->mpPrivate->mSceneQueryListeners.begin();
			std::vector<CSceneQueryListener*>::iterator eItr = this->mpPrivate->mSceneQueryListeners.end();
			while (bItr != eItr)
			{
				if (*bItr == ref_SceneQueryListener)
				{
					this->mpPrivate->mSceneQueryListeners.erase(bItr);
					return ;
				}
				++bItr;
			}
		}

		CSceneLoadHandler_CGeoSpatialControl::CSceneLoadHandler_CGeoSpatialControl()
		{

		}

		CSceneLoadHandler_CGeoSpatialControl::CSceneLoadHandler_CGeoSpatialControl(CGeoSpatialControl* pControl)
			:ref_mpControl(pControl)
		{

		}

		CSceneLoadHandler_CGeoSpatialControl::~CSceneLoadHandler_CGeoSpatialControl()
		{

		}

		bool CSceneLoadHandler_CGeoSpatialControl::handleEvent(VirtualMine::Core::CEvent* evt)
		{
			CSceneLoadEvent* pSceneEvent = dynamic_cast<CSceneLoadEvent*>(evt);
			if (pSceneEvent && this->ref_mpControl)
			{
				this->ref_mpControl->load(pSceneEvent->getGeoScene());
				evt->accept();
			}

			CSceneUnLoadEvent* pSceneUnLoadEvent = dynamic_cast<CSceneUnLoadEvent*>(evt);
			if (pSceneUnLoadEvent && this->ref_mpControl)
			{
				this->ref_mpControl->unLoad();
				evt->accept();
			}

			return evt->isAccepted();
		}

		CControlInitialEvent::CControlInitialEvent()
			:ref_mpBindingObject(NULL)
		{

		}

		CControlInitialEvent::~CControlInitialEvent()
		{

		}

		void CControlInitialEvent::setBindingObject(CGeoSpatialControl* ref_pBindingObject)
		{
			this->ref_mpBindingObject = ref_pBindingObject;
		}

		CGeoSpatialControl* CControlInitialEvent::getBindingObject()
		{
			return this->ref_mpBindingObject;
		}


		void CGeoSpatialControl::settabwidget( const bool& visible )
		{
			istabwidget=visible;
		}

		bool CGeoSpatialControl::gettabwidget()
		{
			return istabwidget;
		}

		Ogre::Overlay* CGeoSpatialControl::getcompassPic()
		{
			return compassOverlay;
		}

		Ogre::Overlay* CGeoSpatialControl::getcompassPic_slider()
		{
			return compass_silderOverlay;
		}

		Ogre::Overlay* CGeoSpatialControl::getcompass_up()
		{
			return compass_upOverlay;
		}

		Ogre::Overlay* CGeoSpatialControl::getcompass_down()
		{
			return compass_downOverlay;

		}

		Ogre::Overlay* CGeoSpatialControl::getcompass_left()
		{
			return compass_leftOverlay;
		}

		Ogre::Overlay* CGeoSpatialControl::getcompass_right()
		{
			return compass_rightOverlay;
		}

		/*	Ogre::Overlay* CGeoSpatialControl::getmppushbackBtn()
		{
		return mppushbackBtn;
		}*/

		Ogre::Overlay* CGeoSpatialControl::getOutTextOverlay()
		{
			return outTextOverlay;
		}

		Ogre::OverlayElement* CGeoSpatialControl::getOutTextElement()
		{
			return outTextElement;
		}

	}
}
