//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : 三维数字矿山平台
//  @ File Name : cdemlayer.cpp
//  @ Date : 2014/7/27
//  @ Author : 盛佳良
//
//


#include "vrmine/vr_spatiallayer/demlayer.h"
#include "vrmine\vr_geometry\geometry\point.h"
#include "vrmine\vr_core\geodatatype.h"
#include "vrmine\vr_spatialobject\mine\demobject.h"
#include "vrmine\vr_databaseengine\database\ifeature.h"
#include "vrmine/vr_core/event.h"
#include "vrmine/vr_spatialinterface/event/eventobject.h"

using namespace VirtualMine::Mine;
using namespace VirtualMine::SpatialInterface;
using namespace VirtualMine::Database;
using namespace VirtualMine::Geometry;
using namespace VirtualMine::Core;

#define  _USENEWMETHOD_ 0

namespace VirtualMine
{
    namespace SpatialLayer
	{
		CDemLayer::CDemLayer()
			:mpGridData(NULL)
		{
			this->mType = VirtualMine::Core::GeoDataType::GDT_DEM;
		}
		
		CDemLayer::~CDemLayer()
		{
			if (this->mpGridData != NULL)
			{
				delete this->mpGridData;
				this->mpGridData = NULL;
			}
			CLayerEvent evt;
			evt.setLayer(this);
			evt.setType(CLayerEvent::LET_UNINITIAL);
			CEventDispatcher::setEvent(&evt);
		}

		void CDemLayer::setDemData(VirtualMine::Geometry::CGrid* ref_pGridData)
		{
			this->mpGridData = ref_pGridData;
		}

		void CDemLayer::draw()
		{

		}

		void CDemLayer::initialise()
		{
			if (this->mHasInitialised)
			{
				return;
			}
			if (this->ref_mpDataSet)
			{
				int featureCount = this->ref_mpDataSet->getCount();//需要数据库引擎提供接口
				//最第一条记录
				for (int i = 0 ; i < featureCount; ++i)
				{
					IFeature* pFeature = this->ref_mpDataSet->getFeature(i);
					CDemObject tempDemoObject;
					tempDemoObject.fromFeature(pFeature);
					
					this->mpGridData = dynamic_cast<CGrid*>(tempDemoObject.getGeometry());
					if (this->mpGridData)
					{
						int pointCount = this->mpGridData->getCount();
						Ogre::Vector3 maxCoor = Ogre::Vector3::ZERO;
						Ogre::Vector3 minCoor = Ogre::Vector3::ZERO; 

						int row = this->mpGridData->getRow();
						int col = this->mpGridData->getCol();
						for (int i = 0 ; i < row ; ++i)
						{
							for (int j = 0 ; j < col ; ++j)
							{
								CPoint& p = this->mpGridData->getPoint(i,j);
								if (maxCoor == Ogre::Vector3::ZERO)
								{
									maxCoor.x = p.getX();
									maxCoor.y = p.getY();
									maxCoor.z = p.getZ();
								}

								if (minCoor == Ogre::Vector3::ZERO)
								{
									minCoor.x = p.getX();
									minCoor.y = p.getY();
									minCoor.z = p.getZ();
								}

								if (p.getX() > maxCoor.x) maxCoor.x = p.getX();
								if (p.getY() > maxCoor.y) maxCoor.y = p.getY();
								if (p.getZ() > maxCoor.z) maxCoor.z = p.getZ();

								if (p.getX() < minCoor.x) minCoor.x = p.getX();
								if (p.getY() < minCoor.y) minCoor.y = p.getY();
								if (p.getZ() < minCoor.z) minCoor.z = p.getZ();
							}
						}
						this->mBoundingBox.setMinimum(minCoor);
						this->mBoundingBox.setMaximum(maxCoor);
				
						break;
					}
				}

				this->mHasInitialised = true;

				CLayerEvent evt;
				evt.setLayer(this);
				evt.setType(CLayerEvent::LET_INITIAL);
				CEventDispatcher::setEvent(&evt);
				
			}
		}

		double CDemLayer::getSlope(const double& x,const double& y,const double& z)
		{
			if (NULL == mpGridData
				|| !this->contains(x,z))
			{
				return 0;
			}

			Ogre::Vector3 maxCoor = this->mBoundingBox.getMaximum();
			Ogre::Vector3 minCoor = this->mBoundingBox.getMinimum();

			double resolution_x = 0;
			double resolution_z = 0;
			double dx = maxCoor.x - minCoor.x;
			double dz = maxCoor.z - minCoor.z;

			resolution_x = dx / this->mpGridData->getCol();
			resolution_z = dz / this->mpGridData->getRow();
			double curRelativeZ = abs(z - minCoor.z);
			double curRelativeX = abs(x - minCoor.x);
			int curRow = (int)(curRelativeZ / resolution_z);
			int curCol = (int)(curRelativeX / resolution_x);

			if (curRow >= (this->mpGridData->getRow())
				|| curCol >= (this->mpGridData->getCol()))
			{
				return DBL_MAX;
			}
			else
			{
				VirtualMine::Geometry::CPoint curMinCoor_left_bottom = this->mpGridData->getPoint(curRow,curCol);
				VirtualMine::Geometry::CPoint curCoor_left_top = this->mpGridData->getPoint(curRow+1,curCol);
				VirtualMine::Geometry::CPoint curCoor_right_bottom = this->mpGridData->getPoint(curRow,curCol+1);
				VirtualMine::Geometry::CPoint curCoor_right_top = this->mpGridData->getPoint(curRow+1,curCol+1);
				
				CPoint* minPoint = &curMinCoor_left_bottom;
				CPoint* maxPoint = &curCoor_right_top;

				std::vector<CPoint*> tempPoins;
				tempPoins.push_back(&curMinCoor_left_bottom);
				tempPoins.push_back(&curCoor_left_top);
				tempPoins.push_back(&curCoor_right_bottom);
				tempPoins.push_back(&curCoor_right_top);

				for (size_t i = 0 ; i < tempPoins.size(); ++i)
				{
					CPoint* pPoint = tempPoins.at(i);
					if (pPoint->getY() < minPoint->getY())
					{
						minPoint->setY(pPoint->getY());
					}

					if (pPoint->getY() > maxPoint->getY())
					{
						maxPoint->setY(pPoint->getY());
					}
				}
				Ogre::Vector2 p1(minPoint->getX(),minPoint->getZ());
				Ogre::Vector2 p2(maxPoint->getX(),maxPoint->getZ());
				Ogre::Real horizonDis = p1.distance(p2);
				Ogre::Real dltHeight = maxPoint->getY() - minPoint->getY();
				double slope = atan(dltHeight / horizonDis);
				slope = Ogre::Radian(slope).valueDegrees();
				return slope;

			}
			return 0;
		}

		double CDemLayer::getHeight(const double& x,const double& z)
		{
			if (!this->mHasInitialised)
			{
				return 0;
			}
#ifdef _USENEWMETHOD_

			double curX = x;
			double curZ = z;
			if (NULL == mpGridData
				|| !this->contains(x,z))
			{
				//处理当前点
				Ogre::Vector3 maxCoor = this->mBoundingBox.getMaximum();
				Ogre::Vector3 minCoor = this->mBoundingBox.getMinimum();
				if (curX < minCoor.x)
				{
					curX = minCoor.x;
				}
				else if ( curX > maxCoor.x)
				{
					curX = maxCoor.x;
				}

				if ( curZ < minCoor.z)
				{
					curZ = minCoor.z;
				}
				else if (curZ > maxCoor.z)
				{
					curZ = maxCoor.z;
				}
			}

			Ogre::Vector3 maxCoor = this->mBoundingBox.getMaximum();
			Ogre::Vector3 minCoor = this->mBoundingBox.getMinimum();

			double resolution_x = 0;
			double resolution_z = 0;
			double dx = maxCoor.x - minCoor.x;
			double dz = maxCoor.z - minCoor.z;

			resolution_x = dx / (double)(this->mpGridData->getCol() - 1);
			resolution_z = dz / (double)(this->mpGridData->getRow() - 1);

#if 0
			double curRelativeZ = abs(z - minCoor.z);
			double curRelativeX = abs(x - minCoor.x);
#else
			double curRelativeZ = curZ - minCoor.z;
			double curRelativeX = curX - minCoor.x;
#endif
			int curRow = (int)(curRelativeZ / resolution_z);
			int curCol = (int)(curRelativeX / resolution_x);

			//在(x,z)所在的方格中进行线性插值计算
			if (curRow > (this->mpGridData->getRow()- 1)
				|| curCol > (this->mpGridData->getCol() - 1))
			{
				return 0;
			}
			else if (curRow > (this->mpGridData->getRow()- 2)
				|| curCol > (this->mpGridData->getCol() - 2))
			{
				return this->mpGridData->getPoint(curRow,curCol).getY();
			}
			else
			{
				VirtualMine::Geometry::CPoint curMinCoor_left_bottom = this->mpGridData->getPoint(curRow,curCol);
				VirtualMine::Geometry::CPoint curCoor_left_top = this->mpGridData->getPoint(curRow+1,curCol);
				VirtualMine::Geometry::CPoint curCoor_right_bottom = this->mpGridData->getPoint(curRow,curCol+1);
				VirtualMine::Geometry::CPoint curCoor_right_top = this->mpGridData->getPoint(curRow+1,curCol+1);

				double curY = 0;

				double curDx = (x - curMinCoor_left_bottom.getX()) / resolution_x;
				double curDz = (z - curMinCoor_left_bottom.getZ()) / resolution_z;

				curDx = abs(curDx);
				curDz = abs(curDz);

				//横向高度变化，与纵向高度变化
				double deltaRow = curDx;
				double deltaCol = curDz;

				double curY_left = curMinCoor_left_bottom.getY() * (1 - deltaCol) 
					+ deltaCol * curCoor_left_top.getY();

				double curY_right = curCoor_right_bottom.getY() * (1 - deltaCol) 
					+  deltaCol * curCoor_right_top.getY();

				float interpolatedElevation = curY_left * (1-deltaRow) + curY_right * deltaRow;

				return interpolatedElevation;
			}

#else
			if (NULL == mpGridData
				|| !this->contains(x,z))
			{
				return 0;
			}

			Ogre::Vector3 maxCoor = this->mBoundingBox.getMaximum();
			Ogre::Vector3 minCoor = this->mBoundingBox.getMinimum();

			double resolution_x = 0;
			double resolution_z = 0;
			double dx = maxCoor.x - minCoor.x;
			double dz = maxCoor.z - minCoor.z;

			resolution_x = dx / this->mpGridData->getCol();
			resolution_z = dz / this->mpGridData->getRow();

			double curRelativeZ = abs(z - minCoor.z);
			double curRelativeX = abs(x - minCoor.x);
			int curRow = (int)(curRelativeZ / resolution_z);
			int curCol = (int)(curRelativeX / resolution_x);

			//在(x,z)所在的方格中进行线性插值计算
			if (curRow >= (this->mpGridData->getRow()-1)
				|| curCol >= (this->mpGridData->getCol() -1))
			{
				return 0;
			}
			else
			{
				VirtualMine::Geometry::CPoint curMinCoor_left_bottom = this->mpGridData->getPoint(curRow,curCol);
				VirtualMine::Geometry::CPoint curCoor_left_top = this->mpGridData->getPoint(curRow+1,curCol);
				VirtualMine::Geometry::CPoint curCoor_right_bottom = this->mpGridData->getPoint(curRow,curCol+1);
				//VirtualMine::Geometry::CPoint curCoor_right_top = this->mpGridData->getPoint(curRow+1,curCol+1);

				double curY = 0;

				double curDx = (x - curMinCoor_left_bottom.getX()) / resolution_x;
				double curDz = (z - curMinCoor_left_bottom.getZ()) / resolution_z;

				curDx = abs(curDx);
				curDz = abs(curDz);

				//横向高度变化，与纵向高度变化
				double curDY_Row = curCoor_right_bottom.getY() - curMinCoor_left_bottom.getY();
				double curDY_Col = curCoor_left_top.getY() - curMinCoor_left_bottom.getY();

				double curY_Row = curMinCoor_left_bottom.getY() + curDx * curDY_Row;
				double curY_Col = curMinCoor_left_bottom.getY() + curDz * curDY_Col;

				curY = (curY_Row + curY_Col) / 2;

				return curY;
			}
#endif
		}
        
    }
}
