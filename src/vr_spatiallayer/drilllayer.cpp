//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : 三维数字矿山平台
//  @ File Name : CDrillLayer.cpp
//  @ Date : 2014/7/27
//  @ Author : 盛佳良
//
//

#include "vrmine\vr_spatiallayer\demlayer.h"
#include "vrmine/vr_spatiallayer/drilllayer.h"
#include "vrmine/vr_databaseengine/database/ifeature.h"
#include "vrmine/vr_spatialinterface/igeoobject.h"
#include "vrmine/vr_spatialrender/spatialrender/drillrenderableobject.h"
#include "vrmine/vr_style/style/drillholestyle.h"
#include "vrmine/vr_spatialobject/geoproperty/drillproperty.h"
#include "vrmine/vr_geometry/geometry/drillhole.h"
#include <list>
#include "vrmine/vr_utility/objecttransformer.h"
#include "vrmine/vr_spatialobject/mine/drillobject.h"
#include "vrmine/vr_core/geodatatype.h"
#include "vrmine/vr_spatialobject/mine/drillobject.h"
#include "vrmine/vr_geometry/geometry/point.h"

using namespace VirtualMine::Database;
using namespace VirtualMine::Base;
using namespace VirtualMine::SpatialRender;
using namespace VirtualMine::SpatialInterface;
using namespace VirtualMine::Mine;
using namespace VirtualMine::Geometry;
using namespace VirtualMine::Style;
using namespace VirtualMine::GeoProperty;
using namespace VirtualMine::Style;
namespace VirtualMine
{
    namespace SpatialLayer
    {

		CDrillLayer::CDrillLayer()
		{
			this->mType = VirtualMine::Core::GeoDataType::GDT_DRILL;
		}

		CDrillLayer::~CDrillLayer()
		{
		
		}

		void CDrillLayer::update()
		{
		
		}

		void CDrillLayer::initialise()
		{
			//assert(this->ref_mpDataSet);
			if (NULL == this->ref_mpDataSet)
				return;
			this->ref_mpGeoSceneManager = this->getScene()->getGeoSceneManager();
			CDemLayer* pDemLayer = dynamic_cast<CDemLayer*>(this->ref_mpGeoSpatialScene->getDemLayer());
            if (!pDemLayer)
            {
				return;
            }
			
			
			CDrillRenderableObject* pRenderableObject(NULL);
			int featureCount = this->ref_mpDataSet->getCount();//需要数据库引擎提供接口
			for (int i = 0 ; i < featureCount; ++i)
			{
				IFeature* pFeature = this->ref_mpDataSet->getFeature(i);
				VirtualMine::SpatialInterface::IGeoObject* pGeoObject = new VirtualMine::Mine::CDrillObject();
				pGeoObject->fromFeature(pFeature);

				double drillX = dynamic_cast<CDrillHoleGeometry*>(pGeoObject->getGeometry())->getX();
				double drillY = dynamic_cast<CDrillHoleGeometry*>(pGeoObject->getGeometry())->getY();
				double drillZ = dynamic_cast<CDrillHoleGeometry*>(pGeoObject->getGeometry())->getZ();
				drillZ *= -1;
				double demY = pDemLayer->getHeight(drillX,drillZ);
				if (drillY > demY || drillY < demY)
				{
					dynamic_cast<CDrillHoleGeometry*>(pGeoObject->getGeometry())->setY(demY);
				}

			
				if(NULL == pRenderableObject)
					pRenderableObject = new  CDrillRenderableObject();
				pRenderableObject->addGeoObject(pGeoObject);
			}
			if (pRenderableObject)
			{
				if(NULL != this->mpRenderableObject)
				{
					this->mpRenderableObject->deRender();
					SAFE_DELETE(this->mpRenderableObject);
				}
				pRenderableObject->setGeoSceneManager(this->ref_mpGeoSceneManager);
				pRenderableObject->build();
				pRenderableObject->setNode(this->ref_mpGeoSceneManager->createSceneNode());
				this->mpRenderableObject = pRenderableObject;
			}
			CSceneLayer::initialise();
		}

		void CDrillLayer::notifyUpdate()
		{
			
		}

		void CDrillLayer::getNearerGeoObjects(const Ogre::Vector3& referencePoint,
			const int& numOfNearerGeoObject,
			VirtualMine::SpatialInterface::GeoObjectMap& result)
		{
			if (this->mpRenderableObject)
			{
				VirtualMine::SpatialInterface::GeoObjectMap tempResult;
				RealVector disVector;
				CDrillRenderableObject* pRenderableObject = dynamic_cast<CDrillRenderableObject*>(this->mpRenderableObject);
				for (int i = 0; i < pRenderableObject->getGeoObjectCount(); ++i)
				{
					CDrillObject* pDrillObject = dynamic_cast<CDrillObject*>(pRenderableObject->getGeoObject(i));
					CPoint* pPoint = dynamic_cast<CPoint*>(pDrillObject->getGeometry());
					Ogre::Vector3 pos(pPoint->getX(),pPoint->getY(),pPoint->getZ());
					double dis = pos.distance(referencePoint);
					tempResult.insert(std::pair<double,CDrillObject*>(dis,pDrillObject));
					disVector.push_back(dis);
				}
				std::sort(disVector.begin(),disVector.end());
				int resultGeoCount = pRenderableObject->getGeoObjectCount() > numOfNearerGeoObject ? numOfNearerGeoObject : pRenderableObject->getGeoObjectCount();
				for (size_t i = 0 ; i < resultGeoCount; ++i)
				{
					double key = disVector.at(i);
					VirtualMine::SpatialInterface::GeoObjectMap::iterator bItr = tempResult.begin();
					VirtualMine::SpatialInterface::GeoObjectMap::iterator eItr = tempResult.end();
					while (bItr != eItr)
					{
						if (abs(bItr->first - key) < 0.000001)
						{
							result.insert(std::pair<double,VirtualMine::SpatialInterface::IGeoObject*>(key,bItr->second));
							break;
						}
						++bItr;
					}
				}
			}
			return;
		}


		void CDrillLayer::setFrameMode(bool isFrameMode)
		{
			CDrillRenderableObject* drillRenderObject = dynamic_cast<CDrillRenderableObject*>(this->mpRenderableObject);
			if (drillRenderObject == NULL)
			{
				return;
			}
			int objectCount = drillRenderObject->getGeoObjectCount();
			for (int i = 0; i<objectCount; ++i)
			{
				CDrillObject* drillObject = dynamic_cast<CDrillObject*>(drillRenderObject->getGeoObject(i));
				CDrillProperty* drillPro = dynamic_cast<CDrillProperty*>(drillObject->getGeoProperty());
				CDrillHoleStyle* drillStyle = dynamic_cast<CDrillHoleStyle*>(drillObject->getStyle());
				Ogre::ManualObject* renderObject = this->ref_mpGeoSceneManager->getManualObject(drillPro->getName());
				int count = renderObject->getNumSections();
				if (isFrameMode)
				{
					for (int j = 0; j< count; ++j)
					{
						Ogre::MaterialPtr material = renderObject->getSection(j)->getMaterial();
						Ogre::Pass* pass = material->getTechnique(0)->getPass(0);
						pass->setPolygonMode(Ogre::PM_WIREFRAME);
						pass->getTextureUnitState(0)->setTextureName("");
					}
				}
				else
				{
					for (int j = 0;j<drillPro->getStratumCount(); ++j)
					{
						Ogre::MaterialPtr material = renderObject->getSection(j)->getMaterial();
						Ogre::Pass* pass = material->getTechnique(0)->getPass(0);
						pass->setPolygonMode(Ogre::PM_SOLID);

						std::string stratuminame = drillPro->getStratum(j)->getDeccription();
						std::string yangshiName = drillStyle->getMaterialName(stratuminame);
						yangshiName.append(".jpg");
						pass->getTextureUnitState(0)->setTextureName(yangshiName);
					}
				}
				
				
			}

		}
        
    }
}
