//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : 三维数字矿山平台
//  @ File Name :modellayer.cpp
//  @ Date : 2014/7/27
//  @ Author : 盛佳良
//
//


#include "vrmine/vr_spatiallayer/modellayer.h"
#include "vrmine/vr_databaseengine/database/ifeature.h"
#include "vrmine/vr_spatialinterface/igeoobject.h"
#include <list>
#include "vrmine/vr_utility/objecttransformer.h"
#include "vrmine/vr_spatialobject/mine/modelobject.h"
#include "vrmine/vr_core/geodatatype.h"
#include "vrmine/vr_geometry/geometry/point.h"
#include <OGRE/Ogre.h>
#include "vrmine/vr_spatialobject/geoproperty/modelProperty.h"
#include "vrmine/vr_databaseengine/database/modelfeature.h"
#include "vrmine/vr_style/style/modelstyle.h"
#include "vrmine/vr_spatialinterface/parameter.h"
using namespace VirtualMine::Database;
using namespace VirtualMine::Base;
using namespace VirtualMine::SpatialInterface;
using namespace VirtualMine::Geometry;
using namespace VirtualMine::GeoProperty;
using namespace VirtualMine::Style;

namespace VirtualMine
{
    namespace SpatialLayer
    {
		CModelLayer::CModelLayer()
		{
			this->mType = VirtualMine::Core::GeoDataType::GDT_MODEL;
		}

		CModelLayer::~CModelLayer()
		{
			if (mModelEntities.size() != 0)
			{
				std::vector<Ogre::Entity*>::iterator itrBegin = this->mModelEntities.begin();
				std::vector<Ogre::Entity*>::iterator itrEnd = this->mModelEntities.end();
				while(itrBegin != itrEnd)
				{
					 this->ref_mpGeoSceneManager->destroyEntity(*itrBegin);
					 itrBegin++;
				}
				mModelEntities.clear();
			}
		}

		void CModelLayer::update()
		{
		
		}

		void CModelLayer::initialise()
		{
			//assert(this->ref_mpDataSet);
			if (NULL == this->ref_mpDataSet
				|| this->mHasInitialised)
				return;

			this->ref_mpGeoSceneManager = this->getScene()->getGeoSceneManager();
	
			if (this->mGeoObjects.empty())
			{
				int featureCount = this->ref_mpDataSet->getCount();//需要数据库引擎提供接口
				for (int i = 0 ; i < featureCount; ++i)
				{
					IFeature* pFeature = this->ref_mpDataSet->getFeature(i);
					CModelFeature* pModelFeature = dynamic_cast<CModelFeature*>(pFeature);
					std::string type =  pModelFeature->getFieldType();
					VirtualMine::Core::DeviceType dType = (VirtualMine::Core::DeviceType)(Ogre::StringConverter::parseInt(type));
					VirtualMine::Mine::CModelObject* pGeoObject = new VirtualMine::Mine::CModelObject();
					this->mGeoObjects.push_back(pGeoObject);
					pGeoObject->setDeviceType(dType);
					pGeoObject->fromFeature(pFeature);
					//CPoint* position =dynamic_cast<CPoint*> (pGeoObject->getGeometry());
					std::string name = pGeoObject->getName();
					if (!this->ref_mpGeoSceneManager->hasEntity(name))
					{
						CModelProperty* pro = dynamic_cast<CModelProperty*> (pGeoObject->getGeoProperty());
						std::string a = pro->getMeshName();
						Ogre::Entity* entObject = this->ref_mpGeoSceneManager->createEntity(pGeoObject->getName(), pro->getMeshName(),VirtualMine::Core::VR_MINE_DEFAULT_RESOURCE_GROUP);
						Ogre::Any any((VirtualMine::Core::CBaseObject*)pGeoObject);
						entObject->setUserAny(any);
						entObject->setRenderQueueGroup(0);
						//Ogre::MaterialManager::getSingletonPtr()
						/*for (int i = 0;i<entObject->getNumSubEntities();i++)
						{
							Ogre::MaterialPtr material = entObject->getSubEntity(i)->getMaterial();
							Ogre::Pass* pass = material->getTechnique(0)->getPass(0);
							pass->setDepthWriteEnabled(false);
							pass->setDepthCheckEnabled(false);
							pass->setTransparentSortingEnabled(true);
							pass->setSceneBlending(Ogre::SBT_TRANSPARENT_ALPHA);

							material->load();
						}*/
						

						this->mModelEntities.push_back(entObject);
					}
				}
			}
			else
			{
				GeoObjectVector::iterator bItr = this->mGeoObjects.begin();
				GeoObjectVector::iterator eItr = this->mGeoObjects.end();
				while (bItr != eItr)
				{
					VirtualMine::Mine::CModelObject* pGeoObject = dynamic_cast<VirtualMine::Mine::CModelObject*>(*bItr);
					std::string name = (*bItr)->getName();
					if (!this->ref_mpGeoSceneManager->hasEntity(name))
					{
						CModelProperty* pro = dynamic_cast<CModelProperty*> ((*bItr)->getGeoProperty());
						std::string a = pro->getMeshName();
						if (a.length() == 0 || a.empty())
						{

						}
						else
						{
							Ogre::Entity* entObject = this->ref_mpGeoSceneManager->createEntity((*bItr)->getName(), pro->getMeshName(),VirtualMine::Core::VR_MINE_DEFAULT_RESOURCE_GROUP);
					        if (entObject)
					        {
								Ogre::Any any((VirtualMine::Core::CBaseObject*)(pGeoObject));
								entObject->setUserAny(any);
								entObject->setRenderQueueGroup(90);
								//Ogre::MaterialManager::getSingletonPtr()
								for (int i = 0;i<entObject->getNumSubEntities();i++)
								{
									Ogre::MaterialPtr material = entObject->getSubEntity(i)->getMaterial();
									Ogre::Pass* pass = material->getTechnique(0)->getPass(0);
									pass->setDepthWriteEnabled(true);
									pass->setDepthCheckEnabled(true);
									pass->setSceneBlending(Ogre::SBT_TRANSPARENT_ALPHA);

									material->load();
								}
								this->mModelEntities.push_back(entObject);
					        }
						}
					
					}
					++bItr;
				}
			}
			VirtualMine::SpatialLayer::CSceneLayer::initialise();
		}

		void CModelLayer::notifyUpdate()
		{
			
		}  

		void CModelLayer::getGeoObjects(VirtualMine::SpatialInterface::GeoObjectVector& geoObjects)
		{
			if (this->mGeoObjects.empty())
			{
				if (this->ref_mpDataSet)
				{
					int featureCount = this->ref_mpDataSet->getCount();//需要数据库引擎提供接口
					for (int i = 0 ; i < featureCount; ++i)
					{
						IFeature* pFeature = this->ref_mpDataSet->getFeature(i);
						CModelFeature* pModelFeature = dynamic_cast<CModelFeature*>(pFeature);
						std::string type =  pModelFeature->getFieldType();
						VirtualMine::Core::DeviceType dType = (VirtualMine::Core::DeviceType)(Ogre::StringConverter::parseInt(type));
						VirtualMine::Mine::CModelObject* pGeoObject = new VirtualMine::Mine::CModelObject();
						pGeoObject->setDeviceType(dType);
						pGeoObject->fromFeature(pFeature);
						this->mGeoObjects.push_back(pGeoObject);
					}
				}
				
			}
			VirtualMine::SpatialLayer::CSceneLayer::getGeoObjects(geoObjects);

		}

		void CModelLayer::draw()
		{
			if (!this->mHasInitialised)
			{
				return ;
			}
			/*if (this->mModelEntities.size() > 0)
				return;*/

			if (this->mModelEntities.size() == 0)  return;

			for (std::vector<Ogre::Entity*>::iterator itr = this->mModelEntities.begin();itr!= this->mModelEntities.end();itr++)
			{
				Ogre::Entity* entity = dynamic_cast<Ogre::Entity*>(*itr);

				if (mpNode == NULL)
				{
					mpNode = this->ref_mpGeoSceneManager->getRootSceneNode()->createChildSceneNode();
				}

				Ogre::SceneNode* node = mpNode->createChildSceneNode();

				node->attachObject(entity);

				if (!entity->getUserAny().isEmpty())
				{
					VirtualMine::Core::CBaseObject* pUserData = entity->getUserAny().get<VirtualMine::Core::CBaseObject*>();

					VirtualMine::Mine::CModelObject* object = dynamic_cast<VirtualMine::Mine::CModelObject*>(pUserData);
					if (object!=NULL)
					{
						CModelStyle* style = dynamic_cast<CModelStyle*>(object->getStyle());
						CParameter param = style->getParameter();
						
						CPoint* position =dynamic_cast<CPoint*> (object->getGeometry());
						
						Ogre::Quaternion q;
						Ogre::Matrix3 mat;
						mat.FromEulerAnglesXYZ(Ogre::Radian(Ogre::Degree(param.getRoate().x)),
							Ogre::Radian(Ogre::Degree(param.getRoate().y)),
							Ogre::Radian(Ogre::Degree(param.getRoate().z)));
						q.FromRotationMatrix(mat);

						node->setOrientation(q);

						node->translate(position->getX(),position->getY(),position->getZ());

						node->setPosition(position->getX(),position->getY(),position->getZ());
						node->scale(param.getScale());	

						//node->showBoundingBox(true);
					}
				}
				
			}
		}

		std::vector<Ogre::Entity*> CModelLayer::getModelEntities()
		{
			return this->mModelEntities;
		}

    }
}
