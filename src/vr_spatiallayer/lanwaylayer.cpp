//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : 三维数字矿山平台
//  @ File Name : CLanewayLayer.cpp
//  @ Date : 2014/7/27
//  @ Author : 盛佳良
//
//


#include "vrmine/vr_spatiallayer/lanwaylayer.h"
#include "vrmine/vr_databaseengine/database/ifeature.h"
#include "vrmine/vr_spatialinterface/igeoobject.h"
#include "vrmine/vr_spatialrender/spatialrender/lanewayrenderableobject.h"
#include <list>
#include "vrmine/vr_utility/objecttransformer.h"
#include "vrmine/vr_spatialobject/mine/lanwayobject.h"
#include "vrmine/vr_core/geodatatype.h"
#include "vrmine/vr_style/style/lanewaystyle.h"
#include "vrmine/vr_geometry/geometry/laneway.h"
#include "OGRE/Ogre.h"
#include "vrmine/vr_spatialrender/baserender/moveabletext.h"


using namespace VirtualMine::Database;
using namespace VirtualMine::Base;
using namespace VirtualMine::SpatialRender;
using namespace VirtualMine::SpatialInterface;
using namespace VirtualMine::Style;
using namespace VirtualMine::Mine;
using namespace VirtualMine::Geometry;
//using namespace VirtualMine::BaseRender;
namespace VirtualMine
{
    namespace SpatialLayer
    {

		CLanewayLayer::CLanewayLayer()
		{
			this->mType = VirtualMine::Core::GeoDataType::GDT_LANWAY;
		}

		CLanewayLayer::~CLanewayLayer()
		{
		
		}

		void CLanewayLayer::update()
		{
		
		}

		void CLanewayLayer::initialise()
		{
			//assert(this->ref_mpDataSet);
			if (NULL == this->ref_mpDataSet)
				return;
			this->ref_mpGeoSceneManager = this->getScene()->getGeoSceneManager();
			CLanewayRenderableObject* pRenderableObject(NULL);
			int featureCount = this->ref_mpDataSet->getCount();//需要数据库引擎提供接口
			for (int i = 0 ; i < featureCount; ++i)
			{
				IFeature* pFeature = this->ref_mpDataSet->getFeature(i);
				VirtualMine::SpatialInterface::IGeoObject* pGeoObject = new VirtualMine::Mine::CLaneWayObject();
				pGeoObject->fromFeature(pFeature);	

				/*if (this->mLanywayTexts.size() >= 0)
				{
				std::vector<MovableText*>::iterator itr = this->mLanywayTexts.begin();
				std::vector<MovableText*>::iterator itrEnd = this->mLanywayTexts.end();
				while (itr != itrEnd)
				{
				MovableText* text = dynamic_cast<MovableText*>(*itr);
				if (text->getParentNode())
				{
				text->detachFromParent();
				delete text;
				}
				}
				this->mLanywayTexts.clear();
				}*/

#if 1 ////////////////////////巷道字体

                    ////根据name写字体
					void* data =  pFeature->getPropertySet()->getFields().at(1).getVarient().data();
					char* name = (char*)data;
					Ogre::String lanewayName = name;
					pGeoObject->setName(lanewayName);
					Ogre::String firstChar = lanewayName.substr(0,2);
					if (firstChar != "巷" || firstChar == "巷" ) 
					{
						int count = dynamic_cast<CLaneWayLineGeometry*>(pGeoObject->getGeometry())->getNodesCount();											
						Ogre::Vector3 centerPoint =  dynamic_cast<CLaneWayLineGeometry*>(pGeoObject->getGeometry())->getNode(count/2)->getPosition();						
						centerPoint.y += 15; 

						//Ogre::UTFString str(L"abx");

						//////////////////////////////////////////////////////////////////////////
						int iWLen = MultiByteToWideChar( CP_ACP, 0, lanewayName.c_str(), lanewayName.size(), 0, 0 ); // 计算转换后宽字符串的长度。（不包含字符串结束符）  
						wchar_t *lpwsz = new wchar_t [iWLen + 1];  
						MultiByteToWideChar( CP_ACP, 0, lanewayName.c_str(), lanewayName.size(), lpwsz, iWLen ); // 正式转换。  
						lpwsz[iWLen] = L'\0';   
						Ogre::DisplayString disName(lpwsz);

						//////////////////////////////////////////////////////////////////////////
						VirtualMine::BaseRender::MovableText* pText = new VirtualMine::BaseRender::MovableText(lanewayName,
							Ogre::DisplayString(disName),Ogre::String("SimHei"),10,Ogre::ColourValue(1,0.843,0,1));

						pText->setTextAlignment(VirtualMine::BaseRender::MovableText::H_CENTER,VirtualMine::BaseRender::MovableText::V_CENTER);

						

						if (this->ref_mpGeoSceneManager)
						{
							Ogre::SceneNode* node = this->ref_mpGeoSceneManager->getRootSceneNode()->createChildSceneNode(centerPoint);
							node->attachObject(pText);
							this->mTextNodes.push_back(node);
						}
						if (this->mTextNodes.size() > 0)
						{
							this->mNeedLabel = true;
						}
					}
				 							

					//this->mpCameraListener->ref_mpObject = pText;
#endif  

				if(NULL == pRenderableObject)
					pRenderableObject = new  CLanewayRenderableObject();
				pRenderableObject->addGeoObject(pGeoObject);
			
			 
				this->mGeoObjects.push_back(pGeoObject);
			}
			if (pRenderableObject)
			{
				if(NULL != this->mpRenderableObject)
				{
					this->mpRenderableObject->deRender();
					SAFE_DELETE(this->mpRenderableObject);
				}
				pRenderableObject->setGeoSceneManager(this->ref_mpGeoSceneManager);
				pRenderableObject->build();


				pRenderableObject->setNode(this->ref_mpGeoSceneManager->createSceneNode());
				
				this->mpRenderableObject = pRenderableObject;

			
			}
			CSceneLayer::initialise();
		}

		void CLanewayLayer::notifyUpdate()
		{
			CSceneLayer::notifyUpdate();
		}

		void CLanewayLayer::setLanewayState(const VirtualMine::Style::LanewayStateType& lanewayState)
		{
			CLanewayRenderableObject* pRenderableObject = dynamic_cast<CLanewayRenderableObject*>(this->mpRenderableObject);
		
		 

			GeoExtentionDataVector geoDatas;
			pRenderableObject->getGeoExtentionDatas(geoDatas);
			int index = 0;
			if (geoDatas.size() > 0)
			{
				GeoExtentionDataVector::iterator bItr = geoDatas.begin();
				GeoExtentionDataVector::iterator eItr = geoDatas.end();
				while (bItr != eItr)
				{
					Ogre::ManualObject* pRenderObject = (*bItr)->getExtentionData();

					CLaneWayObject* lanewayObject = (CLaneWayObject*)(*bItr)->getOwnerObject();//dynamic_cast<CLaneWayObject*>(pRenderableObject->getGeoObject(index++));
					if (lanewayObject)
					{

						CLanewayStyle* lanewayStyle = dynamic_cast<CLanewayStyle*>(lanewayObject->getStyle());

						if (pRenderObject)
						{
							//获取pRenderObject绑定的巷道通风类型来确定材质
							std::string matName; //= VirtualMine::Core::GeoMaterialType::GMT_LANEWAY_WIND;
							if (lanewayState == LST_NORMAL)
							{
								//matName = VirtualMine::Core::GeoMaterialType::GMT_LANEWAY_NORMAL;
								matName = lanewayStyle->getSupportImg();
							}
							else if (lanewayState == LST_WIND)
							{
								switch (lanewayStyle->getWindType())
								{
								case LanewayWindType::LWT_NOAIR:
									matName = VirtualMine::Core::GeoMaterialType::GMT_LANEWAY_NOAIR;
									break;
								case LanewayWindType::LWT_FRESHAIR_FORWARD:
									matName = VirtualMine::Core::GeoMaterialType::GMT_LANEWAY_FRESHWIND_FORWARD;
									break;
								case LanewayWindType::LWT_FRESHAIR_REVERSE:
									matName = VirtualMine::Core::GeoMaterialType::GMT_LANEWAY_FRESHWIND_REVERSE;
									break;
								case LanewayWindType::LWT_WASTEAIR_FORWARD:
									matName = VirtualMine::Core::GeoMaterialType::GMT_LANEWAY_WASTEWIND_FORWARD;
									break;
								case LanewayWindType::LWT_WASTEAIR_REVERSE:
									matName = VirtualMine::Core::GeoMaterialType::GMT_LANEWAY_WASTEWIND_REVERSE;
								default:
									matName = VirtualMine::Core::GeoMaterialType::GMT_LANEWAY_NOAIR;
									break;
								}
								//matName = VirtualMine::Core::GeoMaterialType::GMT_LANEWAY_WIND;
							}
							Ogre::MaterialPtr matPtr = Ogre::MaterialManager::getSingletonPtr()->getByName(matName,VirtualMine::Core::VR_MINE_DEFAULT_RESOURCE_GROUP);
							if (!matPtr.isNull()
								&& !matPtr->isLoaded())
							{
								matPtr->load();
							}
							for (size_t i = 0; i < pRenderObject->getNumSections();++i)
							{
								pRenderObject->setMaterialName(i,matName,
									VirtualMine::Core::VR_MINE_DEFAULT_RESOURCE_GROUP);
							}
						}
					}
					++bItr;
				}
			}
		}

		void CLanewayLayer::setStyle(VirtualMine::SpatialInterface::IStyle* pStyle)
		{
			/*if (this->mpRenderableObject)
			{
				VirtualMine::Style::CLanewayStyle* pLanewayStyle = dynamic_cast<VirtualMine::Style::CLanewayStyle*>(pStyle);
				if (pLanewayStyle)
				{
					LanwwayStateType stateType = pLanewayStyle->getLanewayStateType();
					if (stateType == LST_NORMAL)
					{
						this->setLanewayState(VirtualMine::Core::GeoMaterialType::GMT_LANEWAY_NORMAL);
					}
					else if (stateType == LST_WIND)
					{
						this->setLanewayState(VirtualMine::Core::GeoMaterialType::GMT_LANEWAY_WIND);
					}
				}
			}*/
		}

		void CLanewayLayer::setFrameMode(bool isFrameMode)
		{
			Ogre::MaterialPtr material = Ogre::MaterialManager::getSingletonPtr()->getByName("pureMaterial",Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);

			if (!material.isNull())
			{
				Ogre::Pass* pass = material->getTechnique(0)->getPass(0);
				pass->setCullingMode(Ogre::CULL_NONE);
				pass->setPolygonMode(Ogre::PM_WIREFRAME);
				material->load();
			}

			if	(this->mpRenderableObject == NULL) return;
			CLanewayRenderableObject* lanewayRenderObject = dynamic_cast<CLanewayRenderableObject*>(this->mpRenderableObject);
			if (lanewayRenderObject == NULL)
			{
				return;
			}
			int objectCount = lanewayRenderObject->getGeoObjectCount();
			for (int i = 0; i<objectCount	; ++i)
			{
				CLaneWayObject* lanewayObject = dynamic_cast<CLaneWayObject*>(lanewayRenderObject->getGeoObject(i));
				CLaneWayLineGeometry* lanewayGeometry = dynamic_cast<CLaneWayLineGeometry*>(lanewayObject->getGeometry());
				CLanewayStyle* lanewayStyle = dynamic_cast<CLanewayStyle*>(lanewayObject->getStyle());

				Ogre::ManualObject* renderObject = this->ref_mpGeoSceneManager->getManualObject(lanewayGeometry->getName() + "_line");
				int count = renderObject->getNumSections();
				if (isFrameMode)
				{
					for (int j = 0; j< count; ++j)
					{
						renderObject->getSection(j)->setMaterialName("pureMaterial");
					}
				}
				else
				{
					for (int j = 0; j< count; ++j)
					{
						renderObject->getSection(j)->setMaterialName(lanewayStyle->getSupportImg());
					}
				}

			}

		}
        
    }
}
