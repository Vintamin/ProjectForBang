//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : 三维数字矿山平台
//  @ File Name : cimagelayer.cpp
//  @ Date : 2014/7/27
//  @ Author : 盛佳良
//
//
#include <windows.h>
#include "vrmine/vr_spatiallayer/imagelayer.h"
#include "OGRE\OgreVector3.h"
#include "OGRE\OgreManualObject.h"
#include "vrmine\vr_spatiallayer\demlayer.h"
#include "vrmine\vr_core\geodatatype.h"
#include "vrmine\vr_databaseengine\database\ifeature.h"
#include "vrmine\vr_spatialengine\georayscenequery.h"
#include "OGRE/OgreTextureManager.h"
#include "vrmine/vr_databaseengine/database/imagedataset.h"
#include "vrmine/vr_databaseengine/database/imagefeature.h"
#include "vrmine/vr_core/event.h"
#include "vrmine/vr_spatialinterface/event/eventobject.h"

#include "vrmine/vr_mathenine/mathengine/mathcalculator.h"
#include "vrmine\vr_scenecontrol\geospatialscene.h"

using namespace VirtualMine::Core;
using namespace VirtualMine::SpatialInterface;
using namespace VirtualMine::Database;
using namespace VirtualMine::Geometry;
using namespace VirtualMine::SpatialEngine;

namespace VirtualMine
{
    namespace SpatialLayer
    {
		class CDemEventHandler : VirtualMine::Core::CEventHandler
		{
		public:
			CDemEventHandler(CImageLayer* ref_pLayer)
			{
				this->ref_mpLayer = ref_pLayer;
			}

			~CDemEventHandler()
			{

			}

			virtual bool handleEvent(CEvent* evt)
			{
				if (this->ref_mpLayer == NULL)
					return false;

				CLayerEvent* pLayerEvent = dynamic_cast<CLayerEvent*>(evt);
				if (pLayerEvent)
				{
					if (pLayerEvent->getType() == CLayerEvent::LET_INITIAL)
					{
						CDemLayer* pDemLayer = dynamic_cast<CDemLayer*>(pLayerEvent->getLayer());
						if (pDemLayer && pLayerEvent->getType() == CLayerEvent::LET_INITIAL)
						{
							this->ref_mpLayer->reCreateGridBuffer(true);
						}
					}
					else if (pLayerEvent->getType() == CLayerEvent::LET_UNINITIAL)
					{
						this->ref_mpLayer->reCreateGridBuffer(false);
					}
				}
			}
		public:
			CImageLayer* ref_mpLayer;
		};

		CImageLayer::CImageLayer()
			:mXSamplingStrategy(150),mYSamplingStrategy(150),
			mXSamplingPrecision(1.0f),mYSamplingPrecision(1.0f),
			mpRenderObject(NULL)
		{
			this->mType = VirtualMine::Core::GeoDataType::GDT_IMAGE;
			this->mpTerrainEventHandler = new CDemEventHandler(this);
		}

		CImageLayer::~CImageLayer()
		{
			if (mpRenderObject != NULL)
			{
				this->ref_mpGeoSpatialScene->getGeoSceneManager()->destroyManualObject(mpRenderObject);
				mpRenderObject;
			}
			if (this->mpTerrainEventHandler)
			{
				delete this->mpTerrainEventHandler;
				this->mpTerrainEventHandler = NULL;
			}
		}

		void CImageLayer::reCreateGridBuffer(const bool& hasDemData)
		{
			CDemLayer* pDemLayer = dynamic_cast<CDemLayer*>(this->ref_mpGeoSpatialScene->getDemLayer());

			if (this->mpRenderObject)
			{
				Ogre::RenderOperation ro;
				this->mpRenderObject->getSection(0)->getRenderOperation(ro);
				std::vector<Ogre::Vector3> points;
				//顶点buffer
				const Ogre::VertexElement* pPosElement = ro.vertexData->vertexDeclaration->findElementBySemantic(Ogre::VES_POSITION);
				Ogre::HardwareVertexBufferSharedPtr vBufPtr = ro.vertexData->vertexBufferBinding->getBuffer(pPosElement->getSource());
				//////////////////////////////////////////////////////////////////////////
				unsigned char* vertex = static_cast<unsigned char*>(vBufPtr->lock(Ogre::HardwareBuffer::LockOptions::HBL_DISCARD));
				float* pReal = (float*)(vertex);
				float* pOriData = pReal;
				//std::vector<float> datas;
				for( size_t j = 0; j < ro.vertexData->vertexCount; ++j, vertex += vBufPtr->getVertexSize())
				{
					//位置
					float values[5];
					values[0] = *pReal++;
					values[1] = *pReal++;
					values[2] = *pReal++;
					values[3] = *pReal++;
					values[4] = *pReal++;

					double height = 0;//IScene::ReferenceCenter.y;
					double curZ = values[2] * IScene::CoefficientOfCoordinateTransform;
					if (hasDemData && pDemLayer)
						height = pDemLayer->getHeight(values[0],curZ);
					values[1] = height;

					*pOriData++ = values[0];
					*pOriData++ = values[1];
					*pOriData++ = values[2];
					*pOriData++ = values[3];
					*pOriData++ = values[4];
				}
				vBufPtr->unlock();
			}
		}
		

		void CImageLayer::setXSamplingStrategy(const int& samplingStrategy)
		{
			this->mXSamplingStrategy = samplingStrategy;
		}

		void CImageLayer::setYSamplingStrategy(const int& samplingStrategy)
		{
			this->mYSamplingStrategy = samplingStrategy;
		}

		int CImageLayer::getXSamplingStrategy()
		{
			return this->mXSamplingStrategy;
		}

		int CImageLayer::getYSamplingStrategy()
		{
			return this->mYSamplingStrategy;
		}
		
		double CImageLayer::getXSamplingPrecision()
		{
			return this->mXSamplingPrecision;
		}

		double CImageLayer::getYSamplingPrecision()
		{
			return this->mYSamplingPrecision;
		}

		double CImageLayer::getHeight(const double& x,const double& z)
		{
			Ogre::Vector3 intersectPoint(0,0,0);
			if (this->mpRenderObject)
			{
				Ogre::SceneNode* pNode = this->mpRenderObject->getParentSceneNode();
				if (!pNode)
				{
					return 0;
				}
				Ogre::Matrix4 worldMatrix = Ogre::Matrix4::IDENTITY;
				worldMatrix.makeTransform(pNode->_getDerivedPosition(),
					pNode->_getDerivedScale(),
					pNode->_getDerivedOrientation());

				Ogre::Ray ray;
				Ogre::Vector3 originPos(x,5000,z);
				Ogre::Vector3 dir(Ogre::Vector3::NEGATIVE_UNIT_Y);
				dir.normalise();
				ray.setOrigin(originPos);
				ray.setDirection(dir);
				Ogre::Real intersectDis = DBL_MAX;
				for (Ogre::uint32 i = 0 ; i < this->mpRenderObject->getNumSections(); ++i)
				{
					std::pair<bool,Ogre::Real> result(false,DBL_MAX);
					Ogre::ManualObject::ManualObjectSection* pSection = this->mpRenderObject->getSection(i);
					if (pSection)
					{
						Ogre::RenderOperation ro;
						pSection->getRenderOperation(ro);
						result = CGeoRayIntersector::intersect(ray,ro,worldMatrix);
						if (result.first)
						{
							if (result.second < intersectDis)
							{
								intersectDis = result.second;
							}
						}
					}
				}
				if (abs(intersectDis - DBL_MAX) > 0.0001)
				{
					Ogre::Vector3 dir = ray.getDirection();
					intersectPoint = ray.getOrigin() + dir * intersectDis;
					return intersectPoint.y;
				}
			}
			return 0;
		}
        
		void CImageLayer::initialise()
		{
#if 0
			if (this->ref_mpDataSet)
			{
				int featureCount = this->ref_mpDataSet->getCount();//需要数据库引擎提供接口
				//最第一条记录
				for (int i = 0 ; i < featureCount; ++i)
				{
					IFeature* pFeature = this->ref_mpDataSet->getFeature(i);
					
				}
			}
#endif
			if (NULL == this->ref_mpDataSet)
			{
				return;
			}

			CImageDataset* imagedataset = dynamic_cast<CImageDataset*>(this->ref_mpDataSet);
			if ( NULL == imagedataset)
			{
				return;
			}
			CImageFeature* imagefeature = dynamic_cast<CImageFeature*>(imagedataset->getFeature(0));
			if (NULL == imagefeature)
			{
				return;
			}
			this->ref_mpGeoSceneManager = this->getScene()->getGeoSceneManager();
			CDemLayer* pDemLayer = dynamic_cast<CDemLayer*>(this->ref_mpGeoSpatialScene->getDemLayer());

			Ogre::Vector3 maxCoor(imagefeature->getFieldMaxPosX(),
				imagefeature->getFieldMaxPosY(),
				imagefeature->getFieldMaxPosZ());
			Ogre::Vector3 minCoor(imagefeature->getFieldMinPosX(),
				imagefeature->getFieldMinPosY(),
				imagefeature->getFieldMinPosZ());
			maxCoor -= IScene::ReferenceCenter;
			minCoor -= IScene::ReferenceCenter;

#if 1
			//此处这样设置避免包围盒y值最大值比最小值小
			maxCoor.y = 200;
			minCoor.y = -200;
#endif		
			//Ogre::Vector3(4281.2202,134.5,2875.72)
			//Ogre::Vector3(-4238.7798,-134.5,-2884.28)
			this->mBoundingBox.setMaximum(maxCoor);
			this->mBoundingBox.setMinimum(minCoor);

			double dx = maxCoor.x - minCoor.x;
			double dy = maxCoor.z - minCoor.z;

			double xSamperPrecision = 20;
			double ySamperPrecision = 20;
			this->mXSamplingStrategy = dx / xSamperPrecision + 1;
			this->mYSamplingStrategy = dy / xSamperPrecision + 1;
			CoorVector vertexes;
			IntVector indexes;

			//std::string matName = "imageMat";
			//Ogre::MaterialPtr mat = Ogre::MaterialManager::getSingletonPtr()->create(matName,VirtualMine::Core::VR_MINE_DEFAULT_RESOURCE_GROUP);
			

#if 1

			Ogre::uchar* pData = NULL;
			int length = 0;
			pData = imagefeature->getFieldBlob();
			length = imagefeature->getFieldBlobLength();

			Ogre::MemoryDataStream* videoStream = new Ogre::MemoryDataStream(pData,length,false, true);
			Ogre::DataStreamPtr datastreamPtr(videoStream,Ogre::SPFM_DELETE);
			//datastreamPtr->seek(0);		
		
			Ogre::Image ima;
			ima.load(datastreamPtr);
			
		
		
			std::string fileName = (this->getScene())->getCurDirName();
					
			//Ogre::String fileName = VirtualMine::MathEngine::CMathCalculator::getCurrentDir();
			//Ogre::String fileName = "E:\\VRMine_Code_0731\\bin\\Release";
			fileName += "\\vrmineresourcegroup\\minetexture\\newsurface.jpg";
			ima.save(fileName);

			///tianjiajinziyuanzu				
			Ogre::ResourceGroupManager::getSingletonPtr()->addResourceLocation(fileName, "FileSystem",VirtualMine::Core::VR_MINE_DEFAULT_RESOURCE_GROUP);
			//datastreamPtr->close();

			char* resourceName = "newsurface.jpg";
			mImageData.load(resourceName,VirtualMine::Core::VR_MINE_DEFAULT_RESOURCE_GROUP);

			Ogre::ResourceGroupManager::getSingletonPtr()->initialiseAllResourceGroups();

			if (Ogre::ResourceGroupManager::getSingletonPtr()->resourceExists(VirtualMine::Core::VR_MINE_DEFAULT_RESOURCE_GROUP,resourceName))
			{
				int idx = 0;
				idx = 0;
			}
#endif

			std::string matName = "shaderMat";
			//std::string matName = "surfaceMat";
			Ogre::MaterialPtr mat = Ogre::MaterialManager::getSingletonPtr()->getByName(matName,VirtualMine::Core::VR_MINE_DEFAULT_RESOURCE_GROUP);

			if (!mat.isNull())
			{
			
			
#if 1
				Ogre::Pass* pass = mat->getTechnique(0)->getPass(0);
				
					
			    Ogre::TexturePtr texture = Ogre::TextureManager::getSingleton().createManual("RttTex",VR_MINE_DEFAULT_RESOURCE_GROUP , 
					Ogre::TEX_TYPE_2D,ima.getWidth(), ima.getHeight(), 0, Ogre::PF_R8G8B8, Ogre::TU_RENDERTARGET);
				texture->loadImage(ima);


			/*	Ogre::TexturePtr texture = Ogre::TextureManager::getSingleton().load("newsurface.jpg",VirtualMine::Core::VR_MINE_DEFAULT_RESOURCE_GROUP);
				texture->loadImage(mImageData);*/
				
				Ogre::TextureUnitState* pTexUnit = pass->getTextureUnitState(0);
				if (!pTexUnit)
				{
					pTexUnit = pass->createTextureUnitState();
				}

				pTexUnit->setTexture(texture);
				mat->setCullingMode(Ogre::CullingMode::CULL_NONE);
#endif

			
				mat->load();
			
			}
			//mat->reload();
			
			this->mpRenderObject = this->ref_mpGeoSpatialScene->getGeoSceneManager()->createManualObject(Ogre::String(this->mName));
			//暂时绑定 空对象
			VirtualMine::Core::CBaseObject* object = new VirtualMine::Core::CBaseObject();
			Ogre::Any any((VirtualMine::Core::CBaseObject*)object);
			this->mpRenderObject->setUserAny(any);

			this->mpRenderObject->begin(matName,Ogre::RenderOperation::OT_TRIANGLE_LIST,VR_MINE_DEFAULT_RESOURCE_GROUP);


			//创建顶点
			for (int row = 0 ; row < this->mYSamplingStrategy; ++row)
			{
				for (int col = 0 ; col < this->mXSamplingStrategy; ++col)
				{
					Ogre::Vector3 samplingPoint;
					samplingPoint.x = minCoor.x + col * xSamperPrecision;
					samplingPoint.z = minCoor.z + row * ySamperPrecision;
					/*samplingPoint.z *= -1;*/
					//需要根据（x,z）的值去dem图层中取出相应点的高程
					samplingPoint.y = 0;
					if (pDemLayer != NULL)
						samplingPoint.y = pDemLayer->getHeight(samplingPoint.x,samplingPoint.z);
					//翻转坐标系
					samplingPoint.z *= IScene::CoefficientOfCoordinateTransform;
					vertexes.push_back(samplingPoint);
					
					Ogre::Real u = col / (Ogre::Real)(this->mXSamplingStrategy);
					Ogre::Real v = 1 - row / (Ogre::Real)(this->mYSamplingStrategy);
					this->mpRenderObject->position(samplingPoint);
					this->mpRenderObject->textureCoord(u,v);
				}
			}
			//
			//创建索引
			for (int row = 0 ; row < this->mYSamplingStrategy - 1; ++row)
			{
				for (int col = 0 ; col < this->mXSamplingStrategy - 1; ++col)
				{
					int index_0_0 = row *  this->mXSamplingStrategy + col;
					int index_0_1 = (row + 1) *  this->mXSamplingStrategy + col;
					int index_0_2 = row *  this->mXSamplingStrategy + col + 1;

					int index_1_0 = row *  this->mXSamplingStrategy + col + 1;
					int index_1_1 = (row + 1) *  this->mXSamplingStrategy + col;
					int index_1_2 = (row + 1) *  this->mXSamplingStrategy + col + 1;

					this->mpRenderObject->index(index_0_0);
					this->mpRenderObject->index(index_0_1);
					this->mpRenderObject->index(index_0_2);

					this->mpRenderObject->index(index_1_0);
					this->mpRenderObject->index(index_1_1);
					this->mpRenderObject->index(index_1_2);
				}
			}
			/////////////////////////////////////////
			this->mpRenderObject->end();
			//构建地表网格渲染对象
			//this->regetGeoSceneManager()->getRootSceneNode()->createChildSceneNode()
			Ogre::SceneNode* pNode = this->ref_mpGeoSceneManager->createSceneNode();
			pNode->attachObject(this->mpRenderObject);
			CSceneLayer::initialise();
		}

		void CImageLayer::draw()
		{
			if (this->mHasRenderToScene)
			{
				return;
			}
			if (this->mpNode 
				&& this->mpRenderObject
				&& this->mpRenderObject->getParentNode())
			{
				this->mpNode->addChild(this->mpRenderObject->getParentNode());
				this->mHasRenderToScene = true;
			}
		}
		
		void CImageLayer::setFrameMode(bool isFrameMode)
		{
			if (this->mpRenderObject == NULL)
			{
				return;
			}
			int sectionCount = this->mpRenderObject->getNumSections();
			for (int i = 0;i<sectionCount;++i)
			{
				Ogre::MaterialPtr material = this->mpRenderObject->getSection(i)->getMaterial();
				Ogre::Pass* pass = material->getTechnique(0)->getPass(0);
				if (isFrameMode)
				{
					pass->setPolygonMode(Ogre::PM_WIREFRAME);
					pass->getTextureUnitState(0)->setTextureName("");
				}
				else
				{
					pass->setPolygonMode(Ogre::PM_SOLID);
					pass->getTextureUnitState(0)->setTextureName("surface.jpg");
				}
			
				//material->load();
			}
		}

		void CImageLayer::resetResource()
		{
//#if 0
//
//	if (NULL == this->ref_mpDataSet)
//			{
//				return;
//			}
//			this->ref_mpGeoSceneManager = this->getScene()->getGeoSceneManager();
//		
//			CDemLayer* pDemLayer = dynamic_cast<CDemLayer*>(this->ref_mpGeoSpatialScene->getDemLayer());
//			if (pDemLayer)
//			{
//				this->mBoundingBox = pDemLayer->getBoundingBox();
//			}
//
//			Ogre::Vector3 maxCoor = this->mBoundingBox.getMaximum();
//			Ogre::Vector3 minCoor = this->mBoundingBox.getMinimum();
//
//			double dx = maxCoor.x - minCoor.x;
//			double dy = maxCoor.z - minCoor.z;
//
//			double xSamperPrecision = 20;
//			double ySamperPrecision = 20;
//			this->mXSamplingStrategy = dx / xSamperPrecision + 1;
//			this->mYSamplingStrategy = dy / xSamperPrecision + 1;
//
//			CoorVector vertexes;
//			IntVector indexes;
//			
//			std::string matName = "imageMat";
//			//std::string matName = "shaderMat";
//			Ogre::MaterialPtr mat = Ogre::MaterialManager::getSingletonPtr()->getByName(matName,VR_MINE_DEFAULT_RESOURCE_GROUP);
//			if (!mat.isNull())
//			{
//				Ogre::Pass* pass = mat->getTechnique(0)->getPass(0);
//
//				Ogre::uchar* pData = NULL;
//				int length = 0;
//				CImageDataset *imagedataset = dynamic_cast<CImageDataset*>(this->ref_mpDataSet);
//			    CImageFeature *imagefeature = dynamic_cast<CImageFeature*>(imagedataset->getFeature(0));
//				pData = imagefeature->getFieldBlob();
//				length = imagefeature->getFieldBlobLength();
//				
//				
//				///方式不同
//		
//				//Ogre::DataStreamPtr datastreamPtr = Ogre::DataStreamPtr(OGRE_NEW Ogre::MemoryDataStream(pData, length, false, true));
//					
//
//				
//				Ogre::MemoryDataStream* videoStream = new Ogre::MemoryDataStream(pData,length,false, true);
//				Ogre::DataStreamPtr datastreamPtr(videoStream,Ogre::SPFM_DELETE);
//				datastreamPtr->seek(0);
//			
//
//			
//				////加载有问题
//			 /*  Ogre::Image* image = new Ogre::Image();
//			   image->load(datastreamPtr);*/
//				Ogre::Image ima;
//				ima.load(datastreamPtr);
//
//				
//				/////////
//
//				Ogre::TexturePtr texture = Ogre::TextureManager::getSingleton().createManual("RttTex", Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME, 
//			                             	Ogre::TEX_TYPE_2D,ima.getWidth(), ima.getHeight(), 0, Ogre::PF_R8G8B8, Ogre::TU_RENDERTARGET);
//				texture->loadImage(ima);
//
//				Ogre::TextureUnitState* pTexUnit = pass->getTextureUnitState(0);
//				if (!pTexUnit)
//				{
//					pTexUnit = pass->createTextureUnitState();
//				}
//				pTexUnit->setTexture(texture);
//				
//				
//				datastreamPtr->close();
//
//				mat->load();
//				
//				
//			}
//			if (!this->mpRenderObject)
//			{
//				this->mpRenderObject = this->ref_mpGeoSpatialScene->getGeoSceneManager()->createManualObject(Ogre::String(this->mName));
//
//			}
//
//			this->mpRenderObject->setMaterialName(0,matName,VR_MINE_DEFAULT_RESOURCE_GROUP);
//
//
//
//#if 0
//
//			//暂时绑定 空对象
//			VirtualMine::Core::CBaseObject* object = new VirtualMine::Core::CBaseObject();
//			Ogre::Any any((VirtualMine::Core::CBaseObject*)object);
//			this->mpRenderObject->setUserAny(any);
//
//			this->mpRenderObject->begin(matName,Ogre::RenderOperation::OT_TRIANGLE_LIST,VR_MINE_DEFAULT_RESOURCE_GROUP);
//
//
//			//创建顶点
//			for (int row = 0 ; row < this->mYSamplingStrategy; ++row)
//			{
//				for (int col = 0 ; col < this->mXSamplingStrategy; ++col)
//				{
//					Ogre::Vector3 samplingPoint;
//					samplingPoint.x = minCoor.x + col * xSamperPrecision;
//					samplingPoint.z = minCoor.z + row * ySamperPrecision;
//					/*samplingPoint.z *= -1;*/
//					//需要根据（x,z）的值去dem图层中取出相应点的高程
//					samplingPoint.y = 0;
//					if (pDemLayer != NULL)
//						samplingPoint.y = pDemLayer->getHeight(samplingPoint.x,samplingPoint.z);
//					//翻转坐标系
//					samplingPoint.z *= IScene::CoefficientOfCoordinateTransform;
//					vertexes.push_back(samplingPoint);
//
//					Ogre::Real u = col / (Ogre::Real)(this->mXSamplingStrategy);
//					Ogre::Real v = 1 - row / (Ogre::Real)(this->mYSamplingStrategy);
//					this->mpRenderObject->position(samplingPoint);
//					this->mpRenderObject->textureCoord(u,v);
//				}
//			}
//			//
//			//创建索引
//			for (int row = 0 ; row < this->mYSamplingStrategy - 1; ++row)
//			{
//				for (int col = 0 ; col < this->mXSamplingStrategy - 1; ++col)
//				{
//					int index_0_0 = row *  this->mXSamplingStrategy + col;
//					int index_0_1 = (row + 1) *  this->mXSamplingStrategy + col;
//					int index_0_2 = row *  this->mXSamplingStrategy + col + 1;
//
//					int index_1_0 = row *  this->mXSamplingStrategy + col + 1;
//					int index_1_1 = (row + 1) *  this->mXSamplingStrategy + col;
//					int index_1_2 = (row + 1) *  this->mXSamplingStrategy + col + 1;
//
//					this->mpRenderObject->index(index_0_0);
//					this->mpRenderObject->index(index_0_1);
//					this->mpRenderObject->index(index_0_2);
//
//					this->mpRenderObject->index(index_1_0);
//					this->mpRenderObject->index(index_1_1);
//					this->mpRenderObject->index(index_1_2);
//				}
//			}
//			/////////////////////////////////////////
//			this->mpRenderObject->end();
//
//
//#endif
//			
//			//构建地表网格渲染对象
//			//this->regetGeoSceneManager()->getRootSceneNode()->createChildSceneNode()
//			//Ogre::SceneNode* pNode = this->ref_mpGeoSceneManager->createSceneNode();
//			//pNode->attachObject(this->mpRenderObject);
//			//CSceneLayer::initialise();
//
//
//			////////
//
//
//			//Ogre::Vector3 centerCoor = 0.5 * (minCoor + maxCoor);
//			//
//			//this->ref_mpGeoSpatialScene->getGeoSceneManager()->getCamera(CGeoSceneCamera::DEFAULT_CAMERA_NAME)->lookAt(centerCoor);
//			//this->ref_mpGeoSpatialScene->getGeoSceneManager()->getCamera(CGeoSceneCamera::DEFAULT_CAMERA_NAME)->setPosition(centerCoor);
//
//
//
//#endif
//			std::string matName = "shaderMat";
//			Ogre::MaterialPtr mat = Ogre::MaterialManager::getSingletonPtr()->getByName(matName,VR_MINE_DEFAULT_RESOURCE_GROUP);
//
//			if (!mat.isNull())
//			{
//#if 1
//				Ogre::Pass* pass = mat->getTechnique(0)->getPass(0);
//				Ogre::TextureUnitState* pTexUnit = pass->getTextureUnitState(0);
//				pTexUnit->_getTexturePtr()->loadImage(mImageData);
//				mImageData.save("c:\\test.jpg");
//#endif
//				mat->load();
//
//			}


            std::string matName = "shaderMat";
			Ogre::MaterialPtr mat = Ogre::MaterialManager::getSingletonPtr()->getByName(matName,VirtualMine::Core::VR_MINE_DEFAULT_RESOURCE_GROUP);

			if (!mat.isNull())
			{
			
			
#if 1
				Ogre::Pass* pass = mat->getTechnique(0)->getPass(0);
								
		    	Ogre::TexturePtr texture = Ogre::TextureManager::getSingleton().load("newsurface.jpg",VirtualMine::Core::VR_MINE_DEFAULT_RESOURCE_GROUP);
				texture->loadImage(mImageData);
				
				Ogre::TextureUnitState* pTexUnit = pass->getTextureUnitState(0);
				if (!pTexUnit)
				{
					pTexUnit = pass->createTextureUnitState();
				}

				pTexUnit->setTexture(texture);
				mat->setCullingMode(Ogre::CullingMode::CULL_NONE);
#endif

			
				mat->load();
			
			}

		}


    }
}
