//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : 三维数字矿山平台
//  @ File Name : geoscenemanager.cpp
//  @ Date : 2014/7/6
//  @ Author : 盛佳良
//  @ Implement : 
//  @ Company : 中国矿业大学(北京)
//  @ Copyright:  2014-2020
//  @ Description : 


#include "vrmine\vr_spatialengine\geoscenemanager.h"
#include "vrmine\vr_spatialengine\georayscenequery.h"
#include "OGRE\Ogre.h"

using namespace Ogre;

namespace VirtualMine
{
	namespace SpatialEngine
	{
		CGeoSceneManager::CGeoSceneManager(const String& instanceName)
			:Ogre::SceneManager(instanceName),mpGeoCamera(NULL)
		{
			std::cout<<"我是CGeoSceneManager哈哈哈哈哈哈哈"<<instanceName<<std::endl;
		}

		const String& CGeoSceneManager::getTypeName(void) const
		{
			return CGeoSceneManagerFactory::FACTORY_TYPE_NAME;
		}

		CGeoSceneManager::~CGeoSceneManager(void)
		{

		}

		CGeoSceneCamera* CGeoSceneManager::getDefaultCamera()
		{
			if(NULL == mpGeoCamera)
				mpGeoCamera = static_cast<CGeoSceneCamera*>(this->getCamera(CGeoSceneCamera::DEFAULT_CAMERA_NAME));
			return this->mpGeoCamera;
		}

		void CGeoSceneManager::rayQuery(const int& screenX ,const int& screenY,Ogre::Vector3& intersectPoint,
				Ogre::RaySceneQueryResultEntry& queryObject)
		{
			OGRE_LOCK_MUTEX(this->mPickMutex);
			intersectPoint = Ogre::Vector3::ZERO;
			bool result(false);

			//this->getDefaultCamera()->setNearClipDistance(2);

			Ogre::Real rDeltaX = Ogre::Real(screenX/(Ogre::Real)this->getDefaultCamera()->getViewport()->getActualWidth());
			Ogre::Real rDeltaY = Ogre::Real(screenY/(Ogre::Real)this->getDefaultCamera()->getViewport()->getActualHeight());

			Ogre::Ray ray = this->getDefaultCamera()->getCameraToViewportRay(rDeltaX,rDeltaY);
			Ogre::RaySceneQuery* pRayQuery = this->createRayQuery(ray);
			pRayQuery->setRay(ray);
			pRayQuery->setSortByDistance(true,1);
			pRayQuery->setQueryTypeMask(Ogre::SceneManager::ENTITY_TYPE_MASK);
			Ogre::RaySceneQueryResult rayResult = pRayQuery->execute();
			Ogre::RaySceneQueryResult::iterator itr = rayResult.begin();
			Ogre::Real curIntersectDis(DBL_MAX);
			Ogre::RaySceneQueryResult::iterator rayIterator; 
			for ( rayIterator = rayResult.begin( );rayIterator != rayResult.end( );rayIterator++ ) 
			{
				if ( ( *rayIterator ).movable != NULL ) 
				{ 
					if ( ( *rayIterator ).distance < curIntersectDis)
					{
						curIntersectDis = ( *rayIterator ).distance;
						queryObject = *rayIterator;
						result = true;
					}
				}
			}
			if (result)
			{
				Ogre::Vector3 dir = ray.getDirection();
				dir.normalise();
				intersectPoint = ray.getOrigin() + dir * curIntersectDis;
			}
			this->destroyQuery(pRayQuery);
			//this->getDefaultCamera()->setNearClipDistance(0.01);
		}

		bool CGeoSceneManager::getRayIntersectedPoint(const int& screenX ,const int& screenY,Ogre::Vector3& intersectPoint)
		{
			Ogre::RaySceneQueryResultEntry queryObject;
			this->rayQuery(screenX,screenY,intersectPoint,queryObject);
			return (queryObject.movable != NULL);
		}

		Ogre::RaySceneQuery* CGeoSceneManager::createRayQuery(const Ogre::Ray& ray, unsigned long mask)
		{
			Ogre::RaySceneQuery* q = new CGeoRaySceneQuery(this);
			q->setRay(ray);
			q->setQueryMask(mask);
			return q;
		}

		Ogre::Camera* CGeoSceneManager::createCamera(const Ogre::String& name)
		{
			// Check name not used
			if (mCameras.find(name) != mCameras.end())
			{
				OGRE_EXCEPT(
					Exception::ERR_DUPLICATE_ITEM,
					"A camera with the name " + name + " already exists",
					"SceneManager::createCamera" );
			}

			CGeoSceneCamera *c = OGRE_NEW CGeoSceneCamera(name, this);
			mCameras.insert(CameraList::value_type(name, c));

			// create visible bounds aab map entry
			mCamVisibleObjectsMap[c] = VisibleObjectsBoundsInfo();

			return c;
		}
		/*void CGeoSceneManager::setcene(VirtualMine::SpatialEngine::CGeoSpatialScene* ref_pScene)
		{
			this->ref_mpScene = ref_pScene;
		}

		VirtualMine::SpatialEngine::CGeoSpatialScene* CGeoSceneManager::getSceneRef()
		{
			return this->ref_mpScene;
		}*/

		const String CGeoSceneManagerFactory::FACTORY_TYPE_NAME = "CGeoSceneManager";
		//-----------------------------------------------------------------------
		void CGeoSceneManagerFactory::initMetaData(void) const
		{
			mMetaData.typeName = FACTORY_TYPE_NAME;
			mMetaData.description = "The CGeoSceneManager";
			mMetaData.sceneTypeMask = ST_GENERIC;
			mMetaData.worldGeometrySupported = false;
		}
		//-----------------------------------------------------------------------
		SceneManager* CGeoSceneManagerFactory::createInstance(const String& instanceName)
		{
			//return OGRE_NEW CGeoSceneManager(instanceName);
			return OGRE_NEW CGeoSceneManager(instanceName);
		}
		//-----------------------------------------------------------------------
		void CGeoSceneManagerFactory::destroyInstance(SceneManager* instance)
		{
			OGRE_DELETE instance;
		}

	}
}
